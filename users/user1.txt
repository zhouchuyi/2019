right could remove parameter sure passed clearly unused
looked already tests overridden implementation think need make additional changes
way cache know may sophisticated pre-read code
think also want broken packext
create static helper method presizes packext.values .length
method static
math.max pos + 1 packext.values .length
simpler system.arraycopy expect 0 vals 0 expect.length int expect.length vals.length i++ vals new atomiclong
whoops thanks review fixed
use default access constructor
comment longer accurate
done
really fixed condition testing done
done
done
done
changed ignore cache size writing time really cared stream recommended blocksize
removed conditional altogether always perform refresh think hurts performance significantly change correctness always refresh/clearcache
usually integer.valueof offending location want implicit boxing execution paths boxing exception message fine
think could integer.valueof entry.gettype fix warning
close dead
wanted allow dfsobjdatabase implementations override comparator move dfsreftable subclass dfsreftable declare factory method make dfsreftable override use subclass simpler
going sort maxupdateindex
nah builder pattern overused probably return void setpackstats
could want respin entire series
done automatically dfsblockcache calling readoneblock
done
done
done
means get strings like 00,99,100.
yes *and* fixed
structure correct statement *last* log block fixed
block_offset absolute bytes start file index types concern overshoot readers read block_offset record seek byte position file read 'll rename block_offset block_position
've already made pretty clear document file level min_update_index max_update_index ordering files right next paragraph log record level update_index ordering individual log records within scope ref explained log record section
clarified importing section
done
done
done
fixed singular thanks
correct means 0..n occurrences point later drafts ref_index changed ref_index* multiple index blocks multi-level index see current version
interacts badly dfsblockcache dfs system day_job works easier say starts 0 includes file header
yes interpretation correct log blocks really blocks chunks data stored without block alignment reused term block lack better term maybe changing log_chunk would help
unfortunately want fixed size header occupy entire 64 kib using 64 kib block size better account part first block
done
length suffix suffix longer suffix_length 've clarified rewriting ` suffix_length ` value provides number bytes available ` suffix ` copy ` suffix ` complete reference name
meant reference-like used adjective
clarified section making explicit index block must stay within file format max block size 15.99 mib
done
yes done
done
done
done
done
done
done
fixed point update transactions update_index field 64 bit counter wo overflow
done
reworded
done
done
done
done
rewrote added comment
rowcursor.next advances return value reports sitting value true eof false pop queue.remove pass rowcursor add add calls next advances cursor finds eof eof closes cursor throws away next returned true add puts back priority queue priority queue heap sort insertion means queue.peek points lowest entry may refcursor popped refcursor
done
done
done
done
lets shim readablechannel setreadahead dfs glue run async read ahead scanning large region sequentially misses dfsblockcache
done
done sometimes javadoc overrated
done
yea needed removed
fixed
correct
done
fixed removing chained format per discussion git-core list
fixed removing chained format per discussion git-core list
done
done
done
done
writelog would update loglasttimeusec lower value code dead gone discussion git-core comment thread moot
done
done
done
done
done
done
done
done
done
done
done
done
done
done
done
done
done
done
ms 0 thread.sleep 0 may may scheduling yield undefined platform docs
maybe interruptedioexception
isreflogdisabled
hoist loop identity refs transaction way log timestamps even logging activity spans turn second
see conditional command type update fast-forward matter batchrefupdate configured allow
10 20 default 10 mib allows users specify configuration standard suffix units e.g merge incorelimit 10m 10 mib limit
use incorelimit convert units mibs
correct reverse index persisted disk packext constant
assign variable declared try-with-resources block assign cache miss decide open stream fulfill miss
suggestion much different comes side effect needing yet another variable scope whose purpose know close transparent finally still need finally anyway readblockmicros really saving us anything
see line 331 return list sorted
listpacks return mutated
done
comment added
depends eclipse version think done
storage configuration file currently specified hence implemented
rfc anymore also fixing bug right
done defined integer.max_value instead
done
replaced reentrantlock
confusing 4 easier understand
yup part slow still objcheck every object goes
think mean readcurs.has obj checkobjectcollision obj coded skip checking object soon first object exist locally
wrong place need catch throwing readcurs.open
done
done
ooh good catch thanks done
oops yes true missed implementation
copied
successfully
deleting
nit missing space
jgit adheres api standards prevent us breaking method signature iirc also declared repository return empty set using empty set lot places instead value returned file implementation sort filtering inside objectdatabase creates list alternates rather every time iterating
yes please
thanks fixed
really enable safehash system property method 've also flipped around new version log warning throwing caller
done
done
done
done
done
done
done
new conditional 339 evaluates false ca skip lastidx
explained terry one reasons coding idiom bitten double nested loops jgit break continue attempt inner loop implement intention due code following inner loop outer loop somewhat explicit intent double nested loop naming outer loop explicitly writing intent continue outer loop rather break inner loop even worse switch statements inside inner loop want abort inner loop run next iteration outer loop break course applies switch inner loop personally 'd keep continue object_scan part
way make obvious jit nogarbage value allocated register assumed never change execution loop heavily used packwriter many phases execution across large number objects moved helper method accessing field virtually impossible jit prove avoidunreachable field changed execution loop setter method visible world outside class amount method calls made loop high enough following data flow prove setter invoked nearly impossible jit must constantly load current value field object register test conditional even though never changing curious packing especially finding sizes searching reuse phases slower change
weird blank line middle javadoc please either delete line include like 1393
looks like method missing since 4.7 annotation
fields final never modified
quite difficult change behavior packwriter either punt fixing bug 6-8 months
done
done
within
within
s/the
within
covered commit message improve clarity understanding logic random time future 've forgotten history think straightforward omit ` git blame ` find
large
within
please fix jrn recommended
double
trailing whitespace
think justifies method suggestion earlier comments method
think helper useful may easier two callers setestimatedpacksize may shorter code time remove javadoc method declaration
input file 12 byte header/20 byte trailer output file also file 'd getfilesize pack 32 initialize size 32
double
crazy idea stored estimated size setfilesize packext.pack size way even need new field fill estimate allow implementation get 0 filled replace accurate number later
comment compactor subtracting 32 header/trailer initializing 32
basically method maybe combine implementations making helper takes varags packsource enum copies enumset packsource iterates source packs cost varags enumset nothing compared cost actual packing work need micro-optimize filter loop
gc_txn something
think ask packrevidx offset object next object pack subtract compute length object accumulate size estimate hold packrevidx alongside packindex free per-object basis
directory system temp directory
reworked use instant converter function create timestamp instant
probably really wanted java.sql.timestamp reviewdb objects gerrit
done
extracted constant added javadoc comment
done
done
sort thing virtually impossible maven need make new module new directory new pom.xml hosts single source file depend jgit module may able convince maven use pattern matches single source file new module excludes jgit module could difficult
gah looks like eclipse jgit workspace ordering imports differently last author file
unused imports package looks like test moved package outside imports cleaned move
done
done
done
done
done
done
done
library java supported creating objects git repository would need depend executing git fast-import junit test
treeformatter happily accept anything append byte name filemode mode anyobjectid id
crazy symlink read string encoded byte sequence shoved inputstream leak decoded using different fs instance used read symlink wonder much nfc-nfd bug caused transitions going
use streamposition length file endinput invoked assignment inside method onpackfooter trailer hash read lets avoid countinginputstream altogether
s/this.//
need save stats object see comment
throw away parser connectivity check think runs caller gets control could query stats object obtain field get packlock packsize
ca packparser use existing packstatistics
constants class like jgittext jgittext.properties formatted messageformat.format
done
expanded javadoc document takes ownership list
remove trailing
close list /ul
line wrap breaking written long
dropped think right made change
done
think 0 would sufficient stuff created epoch
formatting
matches.size max_resolve_matches reverse ordering harder read
seems unnecessary caller invokes us empty set matches.size max_resolve_matches need redundant check
remove converting pending foundobject returning caller touch pending skeptical change packs findallimpl path packlist.dirty true rescan pending empty maybe could find wanted left pending non-empty 'd produce duplicate results r one set foundobject saying missing another set saying exists would good either
maybe somehow defer line packlist.dirty second pass
sorts may deferred packlist.dirty second pass
fwiw yes agree safe
yea agree premature optimization lets avoid something ugly unless data shows horrible source garbage fixed
think need something like pending.isempty packlist.dirty written right might well check packlist.dirty front rescan running findallimpl
need check packs.length 0 return early protection empty repository throwing arrayindexoutofboundsexception given list objects find
like compareandput see need mark dirty successfully wrote ref object order command
right good point ok lets go approach markdirty scanallrefs implementation
unlike places class one makes sense wonder base dfsrefdatabase part caller scanallrefs iirc caller scanallrefs dfsrefdatabase
think need mark object database dirty store ref object already visible newref
marking dirty deleting ref new objects introduced
done
changed comment think messageoutwrapper overkill
true would likely violation wire protocol got portion pack could written server server received complete pack yet in.read returning data data aka report-status channel 1 server failures going reported channel 2 channel 3 in.read consumes *most* time get data data channel may message channel 2 channel 3 in.read consume make available us byte data channel really care finish writing pack network failure writing pack e1 may relevant anything server trying say report-status channel without first told us something channel 2 channel 3
done
consider reftree client side 've focused server side use ketch reason reftree ca used client side except bugs implementation fetch_head merge_head orig_head etc coded going wind reftree storage reported getrefs stored maybe need rework update paths say refs outside refs/ namespace named head shoved bootstrap layer allow transient names like fetch_head merge_head git_dir managed bootstrap layer probably going remain refdirectory look lot like refdirectory small text file per ref
sounds like bug initialization path reftree exist head symref pointing refs/heads/master without surprised commands failed downstream ` jgit init ` earlier probably created head symref git_dir switched refsstorage reftree disappeared view ` jgit debug-rebuild-ref-tree ` might migrate might allow commands work
use atomicboolean volatile boolean sufficient e.g private volatile boolean failing
please fix formatting comment spans 2 lines
unnecessary
search needle haystack
right way urisyntaxexception thrown current code follower url incorrectly specified leader config file message text currently correct
formatted client wanted show success failure read nicer ending line
done
done
done
done
future tbd given manually elected system running proof concept need changing leadership expiring leadership
done
going drop string id part
done
done
yea confusing changed full follower_only point follower_only additional replicas serve content counted voting allows making 5.1 system example 6 replicas 5 vote 1 keeps current follower_only 'd get 4/6 votes every operation 6 replica system
done
think mean even *can* done
done
done
done
done
done
done
done
done
done
done
correct fast allow two pushes run concurrently allows commit potentially go faster less transfer combined next batch sending objects
correct wait commit proposal used text
done
done line wrapping forcing think improved readability code
done
done
done
done
done
done
done
done
done
done reasonably certain return current
done
done
done
done
turned mess much else 'll try rework initialize ctor
done
done
done
done
done
done
forcing visibility modifications result fields inside individual receivecommands threads go lock object flush writes made pusher thread make visible leader thread might viewing results however actually necessary push running async using multiple threads happen stock jgit might happen day_job system async rpcs could synchronization think going drop locking seems like required
relic discarded prior approach removed done field simplified always call replica.afterpush setexception done
done
inside afterpush see line saying leader.lock.lock comment stands
yes
added javadoc afterpush
done
copied proposed comment code last one true broadcasting commit handled round
done
done
yes sometimes modify reftree sentence added javadoc
renamed runasync added javadoc
done
done
plans use index value leader steady state trying determine replica behind leader needs advance forward using logid index meant run revwalk time code completely done yet one use inside ketchreplica.removestaged
done
done
done
added text
done
hmm maybe right renamed logindex
done
done
done
done
done push respin later gather feedback
done
done
done
done also moved top level class avoid weird name leadersnapshot.replicasnapshot
done
done
done
done many config type things jgit use pattern 've left fromconfig instance method
package private useless subclasses ca package real system even get replica configuration per repository going something like gerrit code review server repositories mirrored identically peer gerrit servers replica configuration going statically defined configuration system per-repository gerrit subclass override createreplicas even look config keys
default default default expect real applications e.g gerrit use configuration files select scheduledexecutorservice work make scheduledexecutorservice pass constructor accepts scheduledexecutorservice would completely bypass code
done
think want daemon currently replicating kind want execute see default default default real servers configure thread pool using native configuration system pass executor constructor fact servers may subclass ketchsystem override methods like newcommitter supply name/email values finds suitable like customizing site ketch eclipse.org wants per-server ketch ` hostname ` leaving number configuration possibilities table embedders/application builders ` jgit daemon ` may one day grow flag knows setup thread pool early still thinking jgit daemon simple excuse play prototype real applications going things like gerrit gitblit
done however pasting eclipse peter picked pickled pepper starts every line paragraph reworded text bit get away formatting drove crazy
done
done
done
sure almost never defensively copy inside jgit internals way leads slow performance shuffling around things 8 10 copies deep n large
done
done
not_completed enum ca easily add not_completed public api going horrible breaking change given receivecommand.result enum used add new state like
done
yes tostring
done
done runnables get invoked proposal enters either state executed aborted intermediate states like queued trigger runnable
oy vey yes reworked ketchleader slightly drop leader lock running notifystate executed listeners run without leader lock held
done
done
done created new base commit series creates utility method used ketch
well stock git server act voter without ketch-aware added instead p remote replica may fully ketch-aware standard git server
done transport implement autocloseable add commit series introduce
done
done
done
done
intent object instance die leader deposed term 'll try document
done thanks
done
log
done
think 9 kind crazy system configuration 1 special case simple testing
done
done
losing reference purpose held proposalround
done
reasonable use n/2+1 quorum future round include least one therefore able carry system forward requiring places unnecessary constraints acceptance
done
done
done
done
done
done
done
done
done
done
oy vey notify holding lock prevent race background thread picked scheduleleader also grabs lock grabbed lock set proposal state running set queued would incorrect state change queued done state proposal user listeners run fast operation inside proposal set state field queued returns immediately think need anything
hate year changes code started 2015. get yelled 2015 copyright date new file reviewed 2016. updated dates 2016 uploading still get commented copyright us 95 years first publication 120 years creation whichever shorter copyright either ends 2016 + 95 2111 2015 + 120 2135. note matter earlier date 2111 wins either way 95 years pretty long time next year wo bother writing anything interesting months november december
done
done
done
done
proposal fixed
objects documentation correct
consider chain commits b c. get following parent pointers c. new branch points another points c 2 unique objects c set stage naive stage algorithm would create 2 stage refs one one c. smarter one rely connectivity creating 1 stage c. automatically implied stage virtue c staged
hah meant oldtree newtree fixed
done
done
done
done
done
done
128 wag pulled constant javadoc
done
try use spearce.org jgit since got involved joined google google.com gerrit since joined google truth lot work google laptop forget configure jgit repository user.email spearce spearce.org 've sometimes committed jgit sop google.com eh
done
done
done
ca lot reasons redeclaring close told implementors throw checked exceptions allows us promise callers although autocloseable says throw exception never throw exception catch exception us keep close override narrow exception set runtimeexception error also keep close keep api compatibility existing java bytecode complied call close method think delete still binary api compatible method stick around least jgit 5.0. even want delete close mentioned throws issue want throw exception want throw nothing
done
yes done
done
done
done
done extracted method called none
change ifda4450f5e488cbfefd728382b7d30797e229217
done
done
yea probably
done
done
use jgit debug-rebuild-ref-tree refs/txn/committed argument output name input
done ancestor commit introduces variable allows null
renamed txncommitted gettxncommitted leaving update alone update refs/txn/committed refs test updating user refs inside reftree read back using reftreedatabase
think see point layering going remove altogether disallow writes refs/txn/ namespace
done
done
done
done 've wanted make class reasons started method
done
done
done
used update rename already split certain behaviors added javadoc safety check case caller builds update rename changes violates expected contract
correct objectinserter never returns null null checks return true line 224 operation no-op renamed nextid newcommitid
good point thinking use case like txncommitted reftree discussed git mailing list case sane namespace txnnamespace null aka namespace still inferred txncommitted name
done
done
done
probably hesitant put public api right lets see anyone else winds needing commit method living around basically forever public class refupdate
done
done
good catch prior version package declared internal since moved internal forgot remove since
done
done
done
done
done
discussed offline today want discuss review thread right code ready
decided two uses want public
understand wanted going ask person today sounds like figure computer
hate jgit eclipse code written first published 2015. sure update date 2016 2016. done
tried expanding javadoc receivecommand stuff useful much mostly future commit seen yet easier define wrapping constructor commit
actually matter network new packed loose storage ignored used network probably receivecommand came git push client network caused command created processed really loose relationship storage irrelevant unfortunately required constructors
done
done
done
done
done patterned notemap offers many overloads reading maybe overkill couple call sites impacted 1 unit test work general low-level types jgit like try accept anyobjectid clear type going correct avoids unnecessary overhead making revwalk object pool allocate revtree whatever assert type think places using reftree getting based commit sha-1 means need parse commit object get tree header fastest way today jgit use revwalk give revtree
done
peel depends storage system day_job version dfsrefdatabase every reference always stored fully peeled day_job dfsrefdatbase.exactref always returns peeled value never returns unpeeled value yet produce unpeeled data add exactpeeledref method refdirectory depends storage type ref found packed-refs file *and* file with-peeled annotation every ref file already peeled ref found packed-refs file refdirectory.exactref result peeled unpeel result satisfy new random constraint thought refdirectory certainly exactpeeledref
exactref thing reads input give input search path
misunderstood code peeled tag object 1 value thinking issymbolic case line 224. handle 5 levels using recursion 5 magic number hardcoded limit anything batshit insane
resolved storage time read time example tag m2 tag m1 commit peeled id tag m2 always m. skips tag m1 reftree code happens automatically inside command constructor revwalk.peel revobject uses loop walk chain tags terminal non-tag returns non-tag e.g store reftree m2^
matter loose vs. packed hints refdirectory leaked api years ago fixture api irrelevant implementations like one use packed semantically like packed loose editing packed reference may require writing one reference make change several things share single storage file similar several refs may share tree object
matter see prefer packed
commits 'll need exactref give us close approximation current reference order handle update computations ref deeply nested need still able read least part path construct command delete check keeps us recursing forever long chain return know good enough throwing would disastrous would able read broken reference order prepare update remove broken reference
future commits need work asking reftree update ref future work may take time future work may still fail reasons leave status alone success caller future work need set success case
done used c avoid line wrapping
ok. 'll rewrite class force caller alway pass objectreader since like property
almost never reader reused restarted closed
made refdatabase.max_symbolic_ref_depth public used directly dropping declaration
good points not_attempted happened once-upon-a-time never thought 'd retry anything multiple stages not_attempted got baked public api ca easily change hindsight bad thing stuck least jgit 5.0. even worried breaking applications adding iscomplete method still going cause difficulties gerrit code review downstream code consuming enum
really really want add another value status enum going ripple nasty ways not_attempted not_completed need handled way lot places
noted think right thing larger context attempting make ok going come back another 5 10 commits change not_attempted
done
live used constructor
could 've pretty heavily penalized synthetic accessors created compiler use private around things private ca really private runtime package visible good enough trust folks package go mucking around badly parts package
done
done
done
yes code treats low high low inclusive high exclusive setting high mid never consider mid set high mid 1 also never consider value mid -1. wrong considered yet might thing looking
high 1 past end point mid 1 'd move end point 1 position low fail find entries may interest
git sorts paths flat string order q.c b q bmode tree need sort b comparing put file named c inside q ordering q.c q/c directory q must come file q.c yes b tree compare next position
good point went nul char literal match '/ char literal readability perspective
done
test added a406ebf4018f change ifc6c61592d9b54d26c66367163acdebea369145c broken fixing different bug makes wonder test working expected
split caller changes commits
requires osgi apis osgi jar deps list ca compile think sane approach buck ca build osgi binary anyway
done
correct previously ignored stage used paths identical indicate path skipping stages using fact cheaper check stage compare paths short-circuit conditional without checking path every entry really change continue continue cases still check path stage 0 sufficient ensure path could path conflict still check path assume stage 0 common therefore use avoid expensive tests path check know would fail
assumevalid never true existing entry point test entry null entry.isassumevalid keep exiting entry without looking working tree means never get assumevalid set never need clear assumevalid part code updateneeded used unit tests look like cares left true force false
think old code wrong reusing old entry lost things like assumevalid updateneeded flags
done
oh evil thanks fixing
think could mytimer null mytimer way create shutdown thread reason instead create one thread see anything timeout code requires throwing away one made constructor
return url
yes discard children done subtree src/main/a done discard children main probably reclaimed java gc enter src/other/b issue treewalk get attributes code walking tree would get attributes src/main/a src/main src src resets look .gitattributes clobbers live children src/main src/main/a
accurate stand wrote commit message every abstracttreeiterator canonicaltreeparser contains path byte iterator dives subtree supplies path instance child 1 share byte allows child append current entry name 2 end byte contiguous representation path file diving grandchild tree grandchild shares path buffer instance ancestors granchild append name 3 path src/main/frobinator.c ^1 ^2 ^3 upon creation child iterator adds path buffer end parent entry appends entries parses parent suddenly goes back reprocesses entries using path buffer overwrites entry name path .gitattributesnator.c path src/main/frobinator.c ^1 ^2 ^3 notice lost much /main/frobi parent replaced contents path buffer longer entry name since path buffer shared children children lost text contributed behavior fine children done get discarded fine children still referenced treewalk still iterated
child iterator shares path buffer parent treewalk dives child tree named src asks parent iterator find .gitattributes parent clobbers path component child leads srctblah checked instead src/blah
correct slow incrementally load contents tree pull entire contents contiguous byte one step storage layer parse byte incrementally raw contains complete listing unfortunately format searched binary search believe 've tried mixed text/binary format makes ambiguous thus impossible linearly scan find anything scanning files treewalk look ahead behind need 2nd canonicaltreeparser go entries
ironically shows crazily tuned canonicaltreeparser measuring laptop 39,000 entries canonicaltreeparser avg 35.9063 ms rawtreeiterator avg 37.8125 ms really hard beat canonicaltreeparser consistently measuring throughput 54 path entires per millisecond faster rawtreeiterator faster treewalk rawtreeiterator lightweight recursive invocation usage canonicaltreeparser read .gitattributes still adequate recursive bulk usage must something subtle path construction efficient jit canonicaltreeparser rawtreeiterator approach concat
everything sorted correctly tree objects added first tree know everything following sorts thus append list correct location beforeadd sets boolean ordering violated sort later first item wrong 'll sort later first item still correctly sorted next items
well root tree still tree
done
confusing read localfile would prefer importing temporarybuffer using temporarybuffer.localfile
easier read line breaks e.g inputstream breaking hard read
switch try-with-resources
consider putting block helper method would reduce indentation shorten case statement
needs call destroy clean temporary file one made filter result overflowed memory buffer
done without try done anything yet needs undone finally write instead string path getentrypathstring try assigning p null first assigning real value entryattributesnode see dislike assignment inside conditional
similar easier read assignment done inside statement tend revwalk/objectwalk.next methods producing value loop read inputstream producing byte count loop elsewhere tend break assignment conditional
hard read assignment wedged conditional line wrapped way test null pull assignment onto line line wrap sanely conditional easier read
use repository fs
able heap buffer filter spewing mibs information stderr
use repo fs
note idbufferblob also needs clean filter applied ensure status racily clean produces correct result maybe rework clean filter code fit existing framework fix framework flexibly handle clean filter executed autocrlf cleanup basically clean filter built-in jgit
ack see point expensive wanting avoid unless really attribtues named require
hmm would bad touch rm -rf *' git add rm -rf *' putting clean filter f name insert rm -rf shell line escaping shell exactly told c git uses quotedstring.bourne semantics handle f
probably helpful put braces around body conditional
adding novel feature created bottleneck rather critical code allocating new byte array using random default platform encoding every time consider tree entry https //git.eclipse.org/r/61512 help
usually commit eclipse .project files jgit adding file
java 9 released going fall back java7 behavior java 7 minimum version better test equals 1.7 startswith 1.7 assume java7 otherwise assume java 8 onward
crypto nerd bad idea may better breaking compatibility jets3
iirc spelled jets3t mixed case see http //www.jets3t.org/
going require cq get permission use library testing
please remove trailing space blank lines lf
ignored file added anyway
think fit one line /** property names */
override eclipse formatted skip blank lines fields noisy seeing extra whitespace dense definition constants
yes considered wrote comment think always binary copying avoid whole eol canonicalization really think anyone relying \n \r\n windows platforms \n going tty windows usually right thing still jump next line even though \r missing true since like windows 2000. past 15 years
feels wrong even bother binary flag copier threads alloc 4 kib buffer perform single read call get data write result stream repeating block trying create record boundaries lf 4 kib chunks
consider adding sort metric dfsgarbagecollector followup cl
ick think client send shallow depth good catch
break version npes fixed
yes much bigger change
wat
done
done
done
done
done
looks fine drop rfc
time push ref file grows length delta compress time point blob may become large compressing/decompressing bottleneck delta compression stop running altogether file exceeds limit default 50m jgit packer replacing file push using history file get certs downside obviously history ref history repo
sharding mess lets would prefer replace file another advantage replacing file per push push cert single blob touches several refs refs tree use blob pointer less duplication cert information agree get ref list best interface iterable type iterableish thing produce results incrementally rather produce entire thing right away gives us options storage
considered putting cert commit message bit harder search git log -- grep=refs/heads/foo refs/push-certs git log refs/push-certs -- refs/heads/foo tree structure starts form bit index filter certs grep commit message fast filter benefit tree structure sort side indexes like per file bitmaps accelerate lookup history per file suddenly also translates per-ref cert lookup
nit formatting consistent
lets hope never record refs/changes/ namespace
right talking dircache costly build large number refs fine may issue later lets kick road internal implementation detail class affect storage
given know c git refs/foo names want still use
formatting seems
test wrong tree entry gitlink non-zero fall read commit exist though blob safer test rawmode type_file type_file
r_refs + meta/push-certs
spaces used style prefers tabs
spaces used style prefers tabs
missing leading space 3 5 lines
also rw null
test wrong tree entry gitlink non-zero fall read commit exist though blob safer test rawmode type_file type_file
specify character encoding rely platform default push cert basically us-ascii probably use iso-8859-1 utf-8
add remark timestamp used sort certs yet getpending rely first match caller add reverse order wants use getpending save caller add multiple certs affecting ref call save first bit unclear api implementation want maybe teach getpending find highest dated personident returning instead first match
see rationale reason sort time zone offset
return long.signum c
interesting never prune deleted refs tree stick around forever makes sense commit least maybe periodic garbage collection commit isolation cert store loops refs tree current cert delete ref delete tree entry
etoomanytabs
refs/meta/push-certs
think argument gitolite ok replace refs/foo tree refs/foo/bar still history refs/push-certs telling refs/foo existed file contents back existed refs/foo/bar came along certs suffix entirely required trust history pointed ref
refs/meta/push-certs
bad rebase think rawline scope
disappointing removes one replay protections rely nonce verification alone broken clients used server
ugh underlying stream bufferedreader wo efficient bufferedreader able mark read char scan \n copy stringbuilder range scanned reset skip bufferedreader whatever advance probably overkill bufferedreader depends used frequency calling suspect single character read fine long bufferedreader
want keep reading case hit eof yet n 0. maybe underlying stream 1024 chars ready 250 ready gave calling would block become ready find lf next batch maybe made mistake suggesting would simpler document caller pass bufferedreader reader bufferedinputstream minimize cost single character io verify callers
default need assign
addcommand see
addcommand caller runs push cert enabled client send push cert
throw ioexception seems like would prefer line 1480 setreflogmessage addcommand
deprecated comes param
deprecated since
never pass null
screw would break mark exceptions api exception file thing would first time
add sort whitelist entry org.eclipse.jgit/.settings/.api_filters tells eclipse ok fucked api
nonce
example others want push er aka pusher example.com perfectly happy example
changed readstring strips lf
consider paranoid prefix line.length 0
final necessary new code would call new code
pointless cmd variable return join return new
create
directory
throw
mean param timestamp current time milliseconds
nit use final interface method
nit final
think seed supplied constructor per-invocation
pass specific character encoding probably iso-8859-1
seed
nit assign null mac leave variable unset declaration
key.getbytes utf-8
return need hexstring variable
nonce needs include seconds hmac
store passed verify method
think iso-8859-1 might better encoding seed/key
allowedslop
need use 0 leave variables unassigned compiler help us prove set try block abort without using garbage value
would want permit allowedslop 0 allowedslop 0 nonce must match exactly precludes http transactions maybe admin wants admin care slop use reasonable default figure e.g 5 minutes slop
allowedslop
allowedslop
dfs part jgit maybe say string path repo instanceof dfsrepository path dfsrepository repo .getrepositoryname else repo.getdirectory null path repo.getdirectory .getpath else throw new illegalstateexception
looks like need pass receivepack instance
long.parselong
put constructor see notes passing seed constructor instead per method
mac object thread safe used would cleaner retain secretkeyspec build mac object method call
mark createnonce synchronized
nit restore blank lines around
consider enum enum noncestatus unsolicitied bad missing ok slop
noncegenerator null initialize lines maybe mean move getadvertisenonce
save nonce sentnonce
quite work need call matches access group matcher versionpattern.matcher pckin.readstringraw m.matches throw new ioexception invalid cert string version m.group 1 one reason bother regex especially simple patterns like easier say private static final string version version string pckin.readstringraw s.startswith version throw string version s.substring version.length
line contain trailing lf need test loop condition
-\n
yes isbidirectionalpipe basereceivepack
hmac sha1 code supplied follow format
think awkward reparse nonce string instead new method inside noncegenerator interface generator pair methods generate verify left generator check ok/bad/slop reasonable slop
git-core implementation detail replicate jgit every operation instead think make certificate available byte something allow callers write object connecting graph
avoid protected fields public types
nit avoid final newer code
instead passing seed slop methods maybe pass receiveconfig noncegenerator constructor store relevant data seed slop fields api becomes less specific seed used calls
readstring would trim lf
readstring version ignore lf
use parsenextline basically pusher pushee nonce
3rd arg computed 2nd need pass
write part custom since want readstringraw check lf everyone else wants skip lf
optional better somehow combine new pack handled packparser inside receivepack would punt writing object commit another commit
commandlist buffer pass method would also punt verify lets leave something caller prereceivehook
return objectid going write
push seed generator noncegenerator cfg.certnonceseed null new hmacsha1noncegenerator cfg.certnonceseed null
noncegenerator null
nit manually line break format less mangled throw new ioexception messageformat.format jgittext.get .errorinvalidpushcert expected + startingwith
fine argument needs listed javadoc
nit lowercase header
drop call let calling application verify write object
odd pass signature method declared accept commandlist maybe drop since punting verify anyway
constants defined maybe enum
comments like fields better public getter methods callers better know expect returned strings
fields probably either private default package access way subclass wo see try extend type muck internal state also means change internal state freely across versions jgit mark fields protected must keep fields exactly unchanged several years difficult compatibility reasons
nit methods never declared intermixed fields
style nit static fields always declared top class
lot fields maybe creating new package visible class called parsedpushcert put fields inside basereceivepack needs one parsedpushcert cert field added prefix every field pushedcert referenced cert.blah
java java.util.concurrent.timeunit translate timeunit.milliseconds.toseconds millis timeunit.seconds.tomillis secs
use null config getstring b form returns null undefined
stateless rpc http done adevertisement created
getdirectory null dfs
always jan 1 1970. want system.currenttimemills something
nonce generation pulled interface put default implementation interface way swap algorithms easily hmacsha1 may ok right uses would like make nonce creation easier experiment
name
return string.format without hexstring variable easier read
remove want 2 arg getstring 3 arg looking receive certnonceseed value valid config
use null
generate nonce
getdirectory null dfs
still seriously obtuse
equals capability splitting left exactly push-cert
consume header \n buffer drop conditional continue read next line pick commands cert exists append command cert parse need conditional look line resembles pgp signature start direct future lines push-cert-end line end cert buffer think wire protocol parser lot simpler get data buffer verify buffer formatting outside wire protocol verifier may useful anyway probably going store push certs somewhere inside git repository may want reread reparse headers really think better making wire protocol code capturing data contiguous buffer deferring actual verification work captured
maybe pass repository noncegenerator pull directory dfs implementations could supply different noncegenerator pull getrepositoryname
nit use db
thought 2 arg form getstring necessary
nit space
lets drop wip part
released lets name version first shipped
nit missing end sentence
think deprecate getref string add findref string replaces makes clear caller looking ref matches input also matches static findref make getref string concrete call findref string mark deprecated offer default implementation findref string see non-breaking api change get us jgit 5
maybe avoid hideous get prefix use exactref string also add map string ref exactref string name lookup multiple exact refs one shot default findref could defined terms taking input building permutations search_path create input array exactref string get results pass static findref return matching result
good default solution nit space around + operator
add exactref
4.1
4.1
differentiate
reformatting edits huge amount noise otherwise small change
another reformatting
oddly line wrapped
unnecessary blank line param since
unnecessary final
could fit one line
pack name case message maybe lowercase p error text
think want remove error prefix given added basereceivepack code
missing since 4.0
think want zero packwriter runs 2 invocations findobjects one another want clearing counter report last correct
s/public// type visible methods visible even declared public cases avoid public make less confusing
diffentry moreover objectloader found object missingobjectexception point race ` git prune ` object longer reachable deleted time caller opened rather unlikely think omit missingobjectexception let ioexception moe unlikely ioexception stage nothing caller either
compute similarity score index another
explain range values returned know returns code maxscore input files empty length iirc returning integer value range 0 maxscore score/maxscore*100 percentage file matches file
/** thrown code create file large */
getcopyfiles
matthias points insufficient documentation url getting
consider iterable instead
nm list.addall accepts collection
unnecessary
get name
getcopyfiles
unnecessary ` `
promote toplevel type called repoproject
promote friends top level types gitrepo package
done
done
would say want filter commits use revfilter
document filter returns false tree recursive children tree considered objectwalk
nit mostly avoid final small methods
obviously go away
probably want add filter objectfilter.include r.gettree pendingobjects.add r.gettree
objectfilter.include idbuffer continue
correct
done
done
yes jgit warnings configured warn autoboxing bitten explicitly manually box ok error paths never traversed like
done
memoryused done
get assert see get method
apparently new style jgit demands braces people confused put
delete line
done
make faster bare repos slower non-bare maybe put conditional code revert working tree iterator added
done
done
done stupid style rule code like
done
short method early return readable shoving everything right one level indentation avoid early return short methods use early return early fail jgit especially allows us avoid level indentation significant portions following code
left code as-is clarified happens capabilities read client
noted probably split two commits written mostly reviewed easier leave one
right believe best java osgi wo let us anything else friend http.server transport
changed receivepack version return useragent capabilities parsed clarified javadoc methods
done
shouldcopythroughcache better name thanks see https //git.eclipse.org/r/46448
really getting property computing value based argument state always follow getfoo computing something
copying entire file copy entire file minus header trailer copying entire pack file header cut caller already inserted header caller header many different header example new objects added repository caller including output file file copied caller header needs adjust object count sum new objects plus number objects file cut trailer reason caller wrote different header content ahead us alters trailer sha-1 caller file trailer go discovered validation stuff even used probably going write change rips may reduce confusion
unnecessary unpin shed memory potentially long running normal path throw caller already finally block already wrapping us much higher stack effect unpin calling close /release dfsreader ctx forget dfsreader eventually become unreachable gc
unclear document class doc property throughout entire dfs package also frankly one reason committer rights repository yet historical baggage underdocumented flat undocumented assumptions tricky ca approve refactoring changes sort behavior yet
historically never done file format code
put file format constants public constants class belong closer storage code hidden internal details storage change storage formats change historically c code wrote many literal constants right code sizes closely coupled aspects file processed hiding length constant help understanding code much may less true java everything far removed machine still important understand file format
subtle ioexception transient want set invalid make file unavailable use later even transient condition clears unfortunately categorize transient vs. permanent ioexception conditions try successful read -1 means hit eof earlier wanted successfully unambiguous problem file transient fixed retrying later time
done
hmm maybe never needed one hesitating adding one config
probably went non-setter position long setter called setposition long
renamed setreadaheadbuffer int
elaborated javadoc
done
done
done
yes
please cuddle back onto line else else
unnecessary string extracted
really leak objectreader created leaking fine fix warnings wrapping whole thing try-with-resources
change
nit something wrong indentation
ignoring fact reset used constructor yes
order awkward think would prefer see estimated limit
wrong arg order
nit jgit prefers omitting curly braces
hah ok thanks pay attention guidelines
understand internal types like dfspackfile packfile objectdatabase refdatabase autocloseable _never_ use scopes would use try-with-resources try packfile pf never would happen retain objects long term block cache held higher level repository object manage close caller
mixed autocloseable maybe correct going warnings gerrit egit like repository opened one scope held long time closed elsewhere
leave sort broken implements autocloseable
git case wrap could set flag inside git instance makes close no-op leaving repo open caller release unfortunately major semantic change anyone currently git git git.wrap repo stuff git.close use higher level api manage repository could add wrapnoclose method something git make close no-op ca think method would called maybe overload wrap public static git wrap repository repo boolean close example try repository repo openrepo git git git.wrap repo false git.somehighlevelapi .call somethingnotexposedbygitapi repo still awkward
ok accept repository autocloseable internal types like refdatabase packfile friends
think warning eclipse leaking fine leaks get gced eventually fine
nope revwalk leaks test
failed
yay
rewrite try-with-resources try objectreader reader db.newobjectreader return forpath reader path trees
nit domain lowercase
iirc coding convention omit initializers false/0/null
iirc coding convention omit initializers false/0/null
put helper accepts depth arg call depth 0 instead repeating code
drop else block save level indentation clause early return need else
javadoc required public methods
batch large command tostring long due 2 sha-1s ref name might make sense format lfs r.append getclass .getsimplename .append commands.isempty return r.append .tostring receivecommand cmd commands r.append non-nls-1 r.append cmd r.append .append cmd.getresult .append \n return r.append .tostring
seems errors also exist ignorerule least code confusing enough seeing appear bugs first reading good sign given issues class also came ignorerule inclined take attribute support try clean in-tree port somehow clean ignorerule
think \t\r regex tabs allowed c implementation oddly enough allows \r attributes
final
final
new attribute
isnameonly
unfortunately modified setup longer original text specifically trailing lost leading may added
relativetarget
match happens setup pattern contain prefix simple target.equals pattern test might expect succeed fails checks
unnecessary parens around target ca test without making temporary string target.startswith pattern target.length pattern.length target.charat pattern.length '/
runtime operation like tree paths matched avoid regex instead use indexof skip string
method longer parses attributes
happen constructor fields final
break line pattern.contains non-nls-1 pattern.contains non-nls-1 pattern.contains non-nls-1
would rather entry class abstract two subclasses textline string attrline attribute declaration way play many instanceof games
given name existence public api would expect set modified method different name perhaps maybe copying set inside method altering copy
config parses string think unreasonable attributes file single string object maybe parse string rather reader
put thought editing attributes might edit api look like ca say proud config api difficult thing edit human written file
fwiw try use split lower-level parsing routines instead prefer loop characters avoids allocation string well internal pattern matcher objects needed perform regex search split
trim unnecessary would prior trim call already removed everything
since === cases happen start line test splitting tokens ca static entry parseentry string line line line.trim line.startswith line.startswith line.startswith ======== line.startswith return null
pattern valid treat entry though comment line throw exception
expression hard read 'd rather break 0 ch ch 9 continue ch ch z continue ch ch z continue return false use table check validity static boolean validchars 128 static char c 0 c 9 c++ validchars c true validchars '- true ch 127 vaildchars ch return false
prefer write obj instanceof attribute attribute attribute obj return false null test type test time also permits us compare subclass according current semantics
think current state art something like int hc key.hashcode hc *= 31 hc += value.hashcode return hc actually attribute many multi-valued using key hashcode hashcode might sufficient
would prefer lot smaller specific test cases chaining large number single common input string hard figure rules care particular assertion input complex lot little tests parsing testparse_emptyinput testparse_trailingwhitespace testparse_multiplelinessamepattern testparse_ignorecomment testparse_ignoreconflictmarkers etc
wonder call equals stringutils equalsignorecase string string almost mirrors string.equalsignorecase string
style-nit parens lhs necessary
header
please include translation text indicating attribute value null
distinction id value
file name patterns followed space tab tab useful like filename contains space
nit space always true trimmed line space ca end space patternend -1 txt.length -1
nit trailing space
return attributes relevant path empty list attributes defined never null
nit think prefer 0 reverse iteration loops
nit drop curly braces
pathutils class maybe convinced rawparseutils rawparseutils typically working byte often providing higher level value e.g int string personident
know javadoc omitted get basic draft uploaded 'd like help understand purpose interface collect behave
nit trailing whitespace
nit trailing whitespace
incorrect want parse excludes file want core.attributesfile
rename variable
rename exclude attrs
code copied existing ignore support copyright assertion correct 2010 red hat according sources came unfortunately jgit seeing copy maybe different copy detection enabled gerrit costly
test difficult read written look ignorenodetest example easier read test case afraid using instance members inside test help manage state required use dsl setup test environment readable way
per http //download.eclipse.org/tools/orbit/downloads/drops/r20140525021250/ easymock 2.4.0 permitted use eclipse want use 2.4.0 need file cq ask reuse 2.4.0. file cq ask 3.2. remove easymock
untrue change jgit wraps requests created regexpipeline path info requests encoded decoded container code overrides container
given hard get cq easymock easier mock
add test context path think servers return root rather
argument order weird consider flipping around contextpath servletpath requesturi tests /c /s /c/s/foo/bar/ much easier read
since call often maybe worth holding private request attribute
also change suffixpipeline use encoded path maybe ok matching decoded path info want use encoded pathinfo inside wrapped request created service
drop jgit style demands written differently anyway basic logic way write
defer computing actually required condition
really necessary special regex character
awkward would suggest early return pattern pathinfo.startswith servletpath return null pathinfo pathinfo.substring servletpath.length pathinfo.isempty servletpath.length 0 return null return pathinfo .length string essentially free see value holding local variable way originally proposed
missing since 3.6 javadoc header
curly braces unnecessary single statement blocks inside jgit code
see chose use early return pattern
nit put since return
unnecessary package methods required public methods
done
done
old checkout code deleted directory overlapped file longer happens assume merging src/foo existing src file src/foo src listed tobedeleted src tobecheckedout running tobedeleted first remove src/foo src successfully tobecheckedout rmdir src order create src file better way handle directory-to-file switch things go wrong switch fail merge abort
done
symbolic
would prefer head null head.issymref adv.addsymref
need use head comes collection something like map string ref refs getadvertisedordefaultrefs addsymrefs adv refs advertised adv.send refs
final necessary arguments short methods
interesting indentation style see consistent keys broken indentation class keys use standard indentation style tab-space continuation lines javadoc
lowercase period =transaction aborted ref status messages lowercase fragment sentence show right branch name status report master transaction aborted v1.0 exists replace
dot
nit blank line declarations
try shove one line simple /** return true commands rejected */
final necessary older code uses frequently slowly removing newer code
think inverse logic makes sense cmd.getresult not_attempted cmd.getresult ok return true return false empty set rejects
iirc static imports go first file
atomic might sufficient description let pull line length possibly avoiding line wrapping
instead duplicating logic force fail atomic anyrejects failpendingcommands private void failpendingcommands receivecommand cmd commands cmd.getresult result.not_attempted cmd.setresult other_reason transaction aborted gracefully fall .onprereceive get empty collection filtercommands finding matches not_attempted since changed failpendingcommands executecommands nothing drop existing reportstatus code unlockpack
think ignoremissingstart relevant name
see part condition needs exist callers packwriter pass ignoremissingseen true seen null building bitmap place safe ignore missing object think part conditional necessary seems write ignoremissingstart continue
import import classes need
yes long.valueof preferred unless absolutely need force allocation
depends server configuration server fsck enabled connectivity checking fail server barf nothing goes wrong server fsck default yay server repository corrupted note old behavior really fixed bug
heh right receive-pack says line 48 long actually 49 long use readstringraw includes undocumented lf
yup fixed later patch set
r n
make consistent windowcache two classes basically api reversed arguments
done
done
yes meant done
done
mean _include.xml
sax parsers multi-threaded use primitive int ++ -- handle increment decrement
think use remotereader implementation instead new includedreader interface know manifest url ref read manifest repo defaultreader know read filesystem uri ref match manifest checked read command
includedepth may better name field
0 default value int field make assignments default values constructors
also acceptable -- xmlinread 0 return
nit final necessary
yea trying avoid changing newmerger method signatures grew setobjectinserter wanted drop final part considering swapping different objectinserter/objectreader recursivemerger tries hard buffer virtual base stuff in-memory without ever leaking repository stored object unclear happens conflict try load higher stages virtual objectids guess would forced write virtual bases repository could least delay top level pass avoid intermediate stages set approach may need finish reader-from-inserter really fix recursivemerger in-memory wrapper virtual base might sufficient
fortunately fairly cheap create either storage backend deferring allocation would eliminate issue makes mess code trying ensure created first
care blaming complicated buffering logic
make another commit ./tools/version.sh -- snapshot=4.0.0
eh next release named 4.0
ok ca break api ca change version number another version public objectreader newreader throw new unsupportedoperationexception instead declaring abstract method tell callers optional method throws unsupportedoperationexception implementor unable implement jgit api alternative fork jgit start new project actually make api changes often every 12 months
annoying signature going live *sigh*
going break api nobody outside jgit implementing objectinserter unless also building storage backend storage backends internal api change time passing argument function useless inserter always sufficient context make reader otherwise ca job properly buried subclasses implementation specific screw api rules adding abstract method means next release _must_ 4.0 appease mythical implementation exist
ironically way implemented data cache output stream know get re-read disk look dfspackparser tries keep track output position uses cache blocks possible reading asks dfsoutputstream data cache block missing wonder refactor code dfspackparser share dfsinserter implement common cache-based read-back
iirc carried new clone reader implementation
import using static import
0xf
also override islarge return true default version islarge calls method traps exception return true slow way say call
given cached block memory shame read back partial segment
db.newreader make clear using db get reader case someone later writes newreader return new reader
iirc fails dfs position aligned block size file still written
basically yes partial block storage well supported dfsblockcache also assume caller going burst inserts followed reads burst inserts may fill block next read load block cache required read happens cache activity occurs dfsoutputstream.read assumed run reasonable latencies 200 ms incurring periodically block size intervals caller transitions insert activity read activity acceptable performance fwiw dfspackparser sort suffers problem delta chain resolution incoming pack larger block cache support implementations really need reasonable response time read think flushing every object instead flushes happen frequently transitions inserting reading
removed
code path triggers inserter closed nulled packout longer use packout read back hedging caller really big object objectinserter ins objectloader ldr ins.newreader ins.insert ins.flush ins.release objectstream data ldr.openstream
done
done
needs reference packout want explicitly add reference enclosing dfsinserter pass packout constructor likely cleaner named class rather anonymous constructing method actually happier hoisted named
2013 correct first version test written published 2013. fact took project year accept code change year came existence
done added testinserterdiscardspack
done
actually configured streamfilethreshold dfspackfile uses determine ok hold entire file contents byte attempt stream since also dfs code configuration parameter used really buf.length len len db.getreaderoptions .getstreamfilethreshold somesuch expression 'll fix upload new version later merger code ca use logic dfs code value shared dfs code core library code might also another wtf something plan fix anytime soon
agreed realized halfway change large may need broken two commits try rebuild two commits one implement early return flow control change another handle in-memory processing
always follow standard formatting settings eclipse stupid things
correct want file written incore conflict ca add file index early return
neither old code replacing either way autocrlf broken merges going fix would prefer follow-up commit
done
done
oh missed back part comment need coffee
yes arraydeque java 6. still targeting java 5
pushing/popping front arraylist n^2 time may lot worse memory impact linkedlist given often run push+pop steps think linkedlist costly may better write little queue type
good catch fixed
test failure add recursion held edit edits recurse held edit comes recursion sorted late edits resulting test failure testedit_duplicateabutcommonuniqueinb
entirely unnecessary create empty index line 558. nothing read .gitmodules nothing delete index proceed write new content index commit update replacing actually pretty damn simple confused need change
writetree works dircache aka index complete list files repository writetree copies commit pass empty dircache writetree get empty repository
paths.isempty
nit try avoid curly braces around simple conditionals
nit unnecessary empty line
code jgit accepted edl epl
retry 0 never try always fail bug think retry unnecessary historically never observed method temporary directory creation failing write method one retry call good enough
pass null form want need conditional
mkdirs overkill parent directory must already exist createtempfile work use tmp.mkdir failed
think null suffix platforms use .git bare repository
clone repository bare open filerepository use objectreader pull contents
inputstream closed delete temporary repository
src might shorter descriptive name result
need close result.stream
fit one line looks like would still shorter line 555 one line
unnecessary
meant part git this.git say this.git write git
iirc release reader
wrap try/finally recursively delete dir
objectloader returned method getbytes int call getbytes integer.max_value get byte array without mess bytearrayoutputstream
unnecessary
think breaks graphical viewer tool may need set true program iirc subclass class
inconsistent whitespace start line compared sibling lines javadoc block
string concat file string new file localdb.getworktree hello preferred join together file paths platform specific directory separator automatically inserted
wrap try/finally ensure streams closed case failure
actually need two levels try/finally input closed fileoutputstream fails create
ever run pgm osgi container
think need matching import org.eclipse.jgit.pgm/meta-inf/manifest.mf
reflect google chris
never mind see value later commit leave as-is
think could used + join string literals together javac use stringbuilder
new file db.getworktree foo/hello.txt would preferred
asserttrue submodule checked hello.exist way test fails bit indication went wrong message
close reader done
assertequals world content
repo project actually named git-repo https //code.google.com/p/git-repo/ repo ambiguous allowed package name suggested gitrepo want api package something expect keep forever jgit looking 2 years code try transition people away git-repo xml files git submodule
yuxuan please fix code build java 5
cause failures delta inflation sz streamfilethreshold data left null throws think need add delta null first conditional force data try decompressing even threshold delta exists
really largeobjectexception.outofmemory
maybe largeobjectexception.exceedsbytearraylimit better
maybe largeobjectexception.outofmemory toobig better
right part test quite wrong entire test method deltastream case deleting may need delete method test put place verify throw largeobjectexception delta going larger 2 gib going require work setup 'll write test case today upload new patch set change includes test
test checks really big delta objects throwing exception handled java byte
documentation incorrect implementation correct change documentation
think right thanks catching simplification
eh yea sort remember last commit repeat per line within span commit commit one region would compute would compute consecutive lines commit
fixed
fixed
fixed
see comment candidate.java
typo
toinsert discarded point regionlist replaces really necessary deepcopy merge method
tie break necessary guess rationale process newly discovered commit first directly reachable previously recent timestamp probably next thing time anything else repository except clock skew clock skew happens ties commit time anything solve clock skew except specific corner case multiple commits happen within second graph somehow ambiguous due merge two paths two children slightly different times one child time ancestor already wtf graph sounds contrived unit test real world even wtf graphs descendant hours older parent side branches present parent likely processed first think sort case trying catch fix uncommon based time equality alone going right often enough iirc git-core jgit try handle sort clock skew slop window commits within sliding window 10 commits popped buffered priority queue ordering violation identified time goes wrong way within slop window 10 commits fixable reinserting repopping 10 commits caller yet seen think slop window trick necessary blame caller getting incremental stream us regions lines caused commit might reconsider parent twice two descendants already necessary correctly compute blame descendants
pretty slow function go back merge base parent child blamegenerator already slow enough breaking ties checking merge base going win us performance awards correctness important speed wonder better graph c- p c p parent relying c.time p.time get desired ordering queue necessarily true malformed segments real world graphs time inverted suspicion restate commit second time find blame onto second path graph iirc exactly incremental topo sort incremental blame work git-core higher level caller might need combine neighboring region instances reported different times commit
simplified loop make even shorter int pidx 0 p idx pcnt pidx++ revpool.parseheaders n.getparent pidx
think understand ascii diagram would make even easier follow
ending comma weird
recent might explicit way state newer time stamp processed first
see note candidate.java
style nit think prefer p line resultstart order result p input region lists see outer class javadoc example deviate style guidelines still try conform existing uses within single source file
deepcopy even necessary see comment blamegenerator looks like two region instances discarded caller deep copy unnecessary
may shorter a.deepcopy b b.deepcopy a.resultstart b.resultstart region b b ok overwriting parameters entering method especially parameter ever used b dead function starts less confusing overwrite reuse names
given google contribute change think wrong change date copyright notice line drop either leave alone fine as-is copyright valid 2011 70 years google dies insert line
style nit use early return avoid need else two statements else case
good question almost used add sourcestart compare think right comparing sourcestart fix upload new version
could wrong commit plist may top strand pearls merge commit back merge commit recursive invocation aborted
done
done
done
done
done
done
exactly defensively coding
done
probably git-core accept tree 0040000
wrapped.openlooseobject fails object file exist disk would expect see unpackedobjects scanloose method likely cause earlier scan done ` git gc ` open attempt fails loose object pruned put pack file openlooseobject called two code paths openobject line 190. method returns null caller look pack files object since checked loose file disk could open place find object pack alternate need retry looking loose object directory probably going succeed caller largepackeddeltaobject stream tries open object loose object first fails returning null goes slower path large delta inflated fly using stream based delta inflater efficient caller prepared returning null form retry like openobject call explained file opened returned enoent exist retry scan wo work
protecting multiple threads calling close objectdirectory concurrently happens repository.close already tries reference counter think little easier follow code saying atomically swap pack list close anything known thread
done
although break sufficient language rules find label slightly improves readability given nested inner loop inner loop uses continue search also happen like bikesheds tan color
done
done
ack sticking break search
yes distinction relevant two filerepository uses alternaterepository check alternate objectdirectory refs associated filerepository advertises objectids receivepack clients avoid pushing branches alternate contains since repository opened want close repository alternates full repositories legal git point alternate random directory ../refs/ tree
eclipse 40+ errors baseline api revision set see missing since tags
ah running juno upgrade
except api baselines plug-in development
right think drop two lines
argh yes correct use bitmaps client shallow going assume client things
iirc depth 0 passed packwriter builds list send using depthwalk instead classical algorithm double check assumptions think need pass shallow commit list
christian wrote function copied code left copyright small doubt way really write method correct say christian code
returning two arrays means push logic computetoppaths method moving goes mean make go away
done
race lock remove last element
done
gah right could cause threads terminate early
think still flawed reason putarchiveentry throws also going cause closearchiveentry throw still lose original exception get get something closearchiveentry instead
another option close raw outputstream discard commons compress object
good bad else good
formatting seems broken jgit standard use tab indent level
moved inside try/finally block try .. loop finally q.release see usage walk.parseany
unused
unused
instead storing enum uploadpack store requestvalidator reference caller invokes setrequestpolicy always immediately switch use validator instance means may need rearrange bit code deals validator enum avoids creating ugly api artifact
think lost selecting default policy configuration
awkward please rephrase
nit extra blank line
specific name wonder thought name good idea *sigh*
http tip work need two different types reachable_commit
awkward drop
nit declare revobject obj immediately loop middle two new sets initialize null
version= 3.0.0,3.1.0
nit blank line unnecessary appeared source delete
need field see
think would simpler allocate bytebuffer constructor iirc new buffer remaining 0
p since len adjusted loop len n. sort bug often modify arguments even though jgit warning policy eclipse whoever enabled warning project settings bit paranoid many functions trying follow actively hurts readability code
think would implement method public int read byte b int int len throws ioexception int cnt 0 0 len buf.hasremaining buf.rewind int nr os.read position buf nr 0 break position += nr buf.flip int n math.min len buf.remaining buf.get b n += n len -= n cnt += n cnt 0 len 0 throw new eofexception return cnt
classical hack implement read like byte b new byte 1 int n read b return n 1 b 0 0xff -1 almost never used form short easy read
please add note closing returned inputstream effect dfsoutputstream
would easier drop static keyword let compiler manage pointer containing class
buf.capacity would also work symmetry constructor make buf.hasremaining false
version= 3.0.0,3.1.0
nit blank line unnecessary appeared source delete
need field see
think would simpler allocate bytebuffer constructor iirc new buffer remaining 0
p since len adjusted loop len n. sort bug often modify arguments even though jgit warning policy eclipse whoever enabled warning project settings bit paranoid many functions trying follow actively hurts readability code
think would implement method public int read byte b int int len throws ioexception int cnt 0 0 len buf.hasremaining buf.rewind int nr os.read position buf nr 0 break position += nr buf.flip int n math.min len buf.remaining buf.get b n += n len -= n cnt += n cnt 0 len 0 throw new eofexception return cnt
classical hack implement read like byte b new byte 1 int n read b return n 1 b 0 0xff -1 almost never used form short easy read
please add note closing returned inputstream effect dfsoutputstream
would easier drop static keyword let compiler manage pointer containing class
buf.capacity would also work symmetry constructor make buf.hasremaining false
need change maven build use 1.4 need file another cq use commons compress 1.4
maybe pull static method pgm.archive invoke without bundlecontext need maintain list two places
maybe use small helper method setup registrations private static final list string myformats collections.synchronizedlist new arraylist string private static final void register string name format fmt myformats.add name archivecommand.registerformat name fmt public void stop bundlecontext context throws exception string name myformats archivecommand.unregisterformat name myformats.clear
comment tgz
awkward read maybe retain tarformat final instance field
eh would put static block left registered life program memory usage trivial
javadoc
format already exists
javadoc
unfortunately still string translate
public goes next line unused
final
returns null caller gives invalid format causes next line throw npe check value format
put first last c-style output side first parameter method like lhs assignment
return null
bad formatting
way get access stream api could send messages
yea upload-pack mostly used side-band
yes looks right user asks no-progress messages would get preuploadhook think reasonable hook sending progress sending sort important message
yes side-band channel always preferred
exactly helped readability method enabled warning fixing everywhere
may myth benchmark change see better worse
yes avoids branch two sides fairly quick compute using avoids branch instruction lets machine combine two sides final conditional branch
use form instead repo.newobjectreader repo.getconfig .get diffconfig.key
looks like added trailing whitespace eclipse always inserts trouble removing
good reason hiding works filerepository backend relied upon as-is need correctly abstract storage backends also self-approved
hardly think edits covered copyright guess keep growing lengthy header since project eclipse
include pgm package name figure deal dependency commons compress
setting null necessary default behavior jvm new object made
nit declare enum static things fields
release treewalk
sure contents file came exiting file jgit created 2012. 2012 source
maven like error /opt/users/hudsonbuild/.hudson/jobs/jgit.gerrit/workspace/org.eclipse.jgit.pgm/src/org/eclipse/jgit/pgm/archive/archivecommand.java 217,14 error unreported exception ioexception must caught declared thrown error /opt/users/hudsonbuild/.hudson/jobs/jgit.gerrit/workspace/org.eclipse.jgit.pgm/src/org/eclipse/jgit/pgm/archive/archivecommand.java 202,20 error unreported exception missingobjectexception must caught declared thrown error /opt/users/hudsonbuild/.hudson/jobs/jgit.gerrit/workspace/org.eclipse.jgit.pgm/src/org/eclipse/jgit/pgm/archive/archivecommand.java 212,41 error unreported exception missingobjectexception must caught declared thrown error /opt/users/hudsonbuild/.hudson/jobs/jgit.gerrit/workspace/org.eclipse.jgit.pgm/src/org/eclipse/jgit/pgm/archive/archivecommand.java 212,17 error unreported exception ioexception must caught declared thrown error /opt/users/hudsonbuild/.hudson/jobs/jgit.gerrit/workspace/org.eclipse.jgit.pgm/src/org/eclipse/jgit/pgm/archive/archivecommand.java 230,12 error unreported exception missingobjectexception must caught declared thrown
need release revwalk instance make sure inflater inside objectreader recycled freed
redundant reader.release
call paranoid resulting pack corrupt object included twice
objects src explicitly excluded yes
done
causes line wrap two lines either way reads cleaner making loop span two lines
done
slightly annoyed grab lock iteration way certain two threads attempt update objecttopack alternative implementation would acquire lock objecttopack storing result might heavier lock end point e.g end point lock might able batches like every object something
iterator usage virtual method dispatch internally iterator considered fancy api make easy use encouraged actually walk care performance internal method dispatch yea bet virtual method faster load branch depends jvm lot specifics going go quicker
fancy introduce new virtual method dispatches main search loop worse use interface methods happens fastest way call code java
really removed caller made sense also delete method
otp.offset initialized 0 packwriter made list objects pack overloaded within small block code store offset source avoid allocating new structure contain source offset output packwriter expects 0 object yet written reset back 0 set non-0 hack reduce memory usage place objecttopack many fields objecttopack 2 3 different values process creating pack
think reading packwriter appears legal omit objects found means packwriter ca reuse existing byte stream instead deflate object onto wire fly moved not-found exception path early search phase much later downstream part delta compression enabled discover connectivity error trying obtain size object delta compression disabled connectivity error show somewhere middle pack stream packer abort break stream object boundary sha-1 trailer
n^2 instead tossing everything commands2 make commands2 empty list list receivecommand commands2 new arraylist receivecommand commands.size add items next case handle delete
point implement remove implement instead addition things handled initial iteration also presize arraylist capacity commands.size arraylist never grow wo need allocate relatively huge linkedlist internal nodes
imho check update update_nonfastforward name collisions name must already exist must old objectid value order execute command check names create
think safe assume existing reference conflict another existing reference
execute create create huge waste time
assert unnecessary
checking prefixes faster treeset sorted list look refdirectory.isnameconflicting walks path input ref see ref already name build large temporary hashsets containing every possible prefix permutation
directory approach interesting think nobody proposed filesystems git runs like rename files across directories rename directories something like afs coda difficult proposal build container file stream pack data pack idx bitmap inside single file rather different files something like zip tar file contents uncompressed easily mmap seekable different fix name file sha1 pack bytes rather sha1 sorted list objects least identical pack means need replace file
actually still less bad process fail rename .idx place least .pack valid human remove .idx run index-pack make new .idx file valid .pack
even succeeds repository corrupt loop finishing successfully unfortunately git experts declared ok naming format file flawed *sigh* slightly better still worrying good solution suggested git rename files based different sha-1 computation going happen anytime soon also suggested streams folded single stream also wo happen anytime soon
please fix typo rebase files renamed gerrit wo able merge
nit curly braces
prefixes empty refs becuase caller invoked addannotatedtags still want add every reference
tip
objectid anyobjectid
objectid
tracking everything double linked list oww hurts
curly braces
objectid
.copy need make sure object mutable someone else revcommit
curly braces
iirc getobjectid allowed return null dangling symbolic reference skip also want skip objects exist instead throwing
curly braces
drop else move final return one level left
ok stringbuilder null npes calling format something null tip formatting string null~5 know valid reference name
use fiforevqueue unfortunately generic use revcommit member type
instead calling c.format null tip value maybe want merge c.tip null test
curly braces
see block pointed change icdb0cdd66ff168917fb9ef17b96093990cc6a98d no-op non-head pack
nit argument field close name please prefix field rename argument
see rule packer ca make bitmap data non-head packs
causes long stalls client bulk latency findobjects 2 lines building wantbitmap touch progressmonitor everything computed virtually free announce count user bitmaps available traversal looking cached pack match updates progressmonitor commit traversed gives user indication working request sitting around idle repository hot memory may lower object throughput parts data read disk
please clean trailing whitespace
race condition cause go corrupt one thread enters method sets r.bitmap xor compressed bitmap valid bitmap return caller type correct thread goes sleep immediately executing test condition another thread enters method also sees bitmapcontainer needs expanded full expansion process stores bitmapcontainer full bitmap first thread wakes calls this.xorbitmap returns null 2nd thread already set bitmapcontainer expanded bitmap first thread breaks loop immediately overwrites good expanded bitmap xor version garbage returns xor version caller packindexve003 replaced new instance e.g due gc falling cache particular bitmap corrupt contain inverted results attempt use bitmap result pack incomplete
nit jgit spells
try avoid importing import need
needs package access ca expose array
bitmap like packfile
would prefer use long.size many people know size number bits long java lot people know long 64 bits java line 64 long think pretty damn clear written using long.size make someone happy avoiding magic number obfuscates trying say
wordmask either mask single bit would name method wordmask mask fine singlebitmask
need file cq get permission add javaewah orbit
25 bytes odd size header think header 4 byte magic 'bitm' 2 byte version '\x01' 2 byte options 4 byte number bitmaps 20 byte pack sha-1 32 byte header
agree put number entries header
nit trailing space
static methods instance members move values array
reference equality given way implementation works drop equals
actually also reference equality could drop use object identity
include bit tostring e.g maybe 1 getposition
say public static synchronized packext jvm handle locking
throw illegalstateexception values.length 32
thought talked making bitset somehow packext keep static int counts many packexts created declared change constructor instead use static factory method automatically registers packext values array assigns unique bit assume permit 32 packexts simple int bit set packexts present
0 also valid bit ever 1 bit set
inline name shorter
list use bit form
use list use bit form
style nit assign 0. let jvm zero field
interesting approach given rebuild bulk wonder ca better still simple switch entry add two additional fields lets know first last position array rebuild approximate array size inqueue/100 + 1 append 100th object array add binary search entry locate log n time point begin insertion bit code like binary search jgit horrible next move first field array items popped queue null index entry garbage collected much lower memory footprint reduce gc pressure perform insertion even faster log n/100 tests rather n/100 tests
low high equal point running binary search iteration exactly one element examine index reassignment q loop breaks pick single element
actually 1 /2 1 extra means right shift without sign extension addition overflows wraps switches back positive value rather negative value later array index throw exception
mid low + high 1
pull local int index mid .commit.committime
break already known committime tie mid incoming c. see breaking tie
wrong update head q head index magic ca use block looking head node anymore wonder testing skewed huge segments list may truncated away entry found index
ties last-in-first-out condition binary search finds point mid time look prior index position head mid=0 start q. prior position also time need keep going backwards index find node time
think rewrite ++sincelastindex rebuild_index_count buildindex inqueue++ move sincelastindex reset buildindex method rewrite little shorter already long method avoids extra compare still get benefit attempt create index added last 1000 items avoid extra branch inqueue
point index first null test initially index null never reach rebuild first points valid non-null entry next runs may advance first first still points valid index provided first last time first pointing non-null entry first last case also ca sure first index.length array sized exactly right last index.length-1 next could advance first one past pops last index bucket array index operation throw exception think want write first last index first .commit.committime modify field initialization clear method set last -1
curly braces statement
style nit would phrase loop int qi 0 ii 0 entry q head q null q q.next ++qi 100 0 index ii++ q shorter two lines combine loop know three iterators think sane use loop entry pointer main loop control variable two iterators qi ii related number iterations loop makes need loop construct
appears bug think arise practice low first -- low loop could decrement low earlier first attempt load index -1 set q null however happen already tested block index first thus never equal low==first wo hit bug
unnecessary delta caused formatter line breaking
unnecessary delta
paths instead aths
p.length ca 0. avoid max==null test perform max p 0 loop starts
hoist pf.getpath local variable code mess otherwise would suggest renaming input array p inputpaths used less often use p pf.getpath inside loop
ouch getpathstring fast good way implement using byte form example imagine compute hash across raw path buffer treewalk time reach '/ hashing stops probes private hash table implementation see pathfilter matches current hash code test ispathprefix subset pathfilter nodes similar implementation avoiding hideously slow byte string conversion required perform 2 hash table lookups split path '/ look level individually hash table lookups
inline cmp point variable
drop boolean use prefixes.isempty prefixes need look deeper root
s/largs/large/
copyright notice required header source files
would deferred allocating dc ready logically treewalk required fill dircache one entry
0 would also acceptable ist possible defaultvalue null 0 ca
assign n. let compiler verify set n branches
use curly braces single statement if-else blocks
maybe better in.startswith -- return false in.substring 2 .replace '- _ return name .equalsignorecase
jgit edl please either use edl header contribute jgit
please format source code unix style line endings
fyi javadoc required submit change
please also add tostring
give motivation change
parsing replace _ match tostring format output convert _ tostring output identity transforms
value.names .equals value.tostring n value.name .tolowercase .replace _ else n value.tostring
change breaks behavior example using lastest master jgit latest master gerrit fails jgit setenum writes different string configuration file gerrit expects read back
couple ways retry change 1 define new interface enums extend like interface configenum string toconfigvalue boolean matchconfigvalue string setenum passed implements configenum downcast call toconfigvalue instead using existing logic getenum passed enum type implements configenum call matchconfigvalue member enum ordinal order select one returned true 2 overload getenum/setenum another version takes map enum string caller sets map define translation enum value config file string setenum trivial lookup enum map store string getenum reverse map lookup string 3 define new algorithm interface like interface configenumformatter string toconfig enumvalue fromconfig string e values overload getenum setenum accept configenumformatter existing implementations call new forms passing default version current logic write new one called option something prefixes values -- _- translation want open change provides option 1 3 trying redo change think 2 good choice least worth mentioning
think even breakages upstream gerrit expected particular change caused gerrit misunderstand every project.config least behavior change real-world impact bump jgit 3.0 since api remained consistent
trying fix https //git.eclipse.org/r/9632
already fixed gerrit want clear change behavior applications may also report problems pick version jgit use enums
change closed wo accept new patch set need make new change witha new change-id please add change reviewer
set table size 5. expect ~4 entries 5 good default size
parens condition
unexpected formatting change please revert
nit try fit one line /** pack file extension */
rely tostring tostring debugging may contain nasty data useful exception use getfile .pack whatever get clean name messages
consistently static import members since imported one import
final
nit use static import avoid long lines
trailing space
consider static import
static import
good catch robin breaks ortreefilter might never threw exception alternative implementation pathfiltergroup create pathfiltergroup exactly 1 entry uses implementation dave tried add pathfilter think revert change dave modify calling code use pathfiltergroup.create single path one argue pathfiltergroup also breaks ortreefilter behavior always throw break ortreefilter always documented
looks like filesource attempt optimizing access working tree think know looking getting specific path workingtreeiterator expensive iterator reset jgit parses path string digs directory tree opendir/readdir/closedir level looking see component exists nearly efficient passing entire path string os via java.io.file api letting os access target working tree course predates attempt autocrlf correctly autocrlf mostly working need information like say attributes feed workingtreeiterator support correct starting important yea looking back 59a262d5 added code pretty clear performance optimization avoid negative effects workingtreesource common case comparing work tree
mean bug number
nit blank line declaration types
need factory factory make things guess java must right
please drop rfc prefix submit series rfc commit message
two r durring
removing else cause buffer length doubly decremented common case ent.index null
wrap onto next line
always want enable shallow support revwalk objectwalk shallow repository
directory null think revwalk built objectreader access repository
unnecessary blank line
ca make callers call parsecommit repository shallow needs hidden within revwalk think always using shallow data unless caller set flag objectreader says use shallow data
necessary
necessary
necessary handled within parseany
needs rewritten init may created revcommit ca create instead say revcommit c initshallow c createcommit id else initshallow c lookupcommit id
would suggest constructor dispose rather commit processed
arrrrrgh right good way get shallow file loaded constructor without risking exception tossed forced runtimeexception robin running similar problem grafts disagree method invocation sites initializeshallowcommits needs probe objects map objects.get inserts commit objects us commit inserts might one trying create particular line necessary init handled parsenew first commit parsed
problem added new method call field load conditional test critical code path used iteration going slow every commit slightly check initialized object certainly done already returning results caller
may need check obj.flags parsed 0 obj instanceof revcommit initshallow initshallow obj.parseheaders catches cases application lookupcommit later calls parseany parseheaders
problem parseheaders
could shorter objectid id reader.getshallowcommits lookupcommit id .parents revcommit.no_parents using static array already tiny amount memory making new instances every shallow commit
mean shallowcommitsalreadyinitialized
cuddle catch closing curly prior line
trailing space added
trailing space added
much simpler way inject logic thanks finding
import
cuddle catch closing curly prior line
test declare test throw ioexception exception expected passing test
bit shorter line reader.readline null ids.add objectid.fromstring line return ids
accessed somewhat often unlike alternates change calls wonder noticeable performance difference reading file every time using snapshot code suspect especially windows repository nfs use snapshots reference handling avoid reading loose reference files updated since last read probably would good idea use
use open file helper method declared class
alternate repository shallow file define alternate shallow file null handle case getshallowcommits shallowfile null means use empty set
repository null built objectreader still repository instance around may shallow data ignore way caller chose build revwalk reuse existing objectreader really need get shallow edge data objectreader hide fact read git_dir/shallow within objectreader implementation
nak try use args4j like particular -- handled specially cmdlineparser pgm.opt line 125. never makes args4j argument index 1
nit tend prefer call idbuf buf java often temporary bytearrayoutputstream stringbuilder idbuf jgit usually mutableobjectid
possible
style check condition throw exception message explaining problem certain classes things assume fail e.g memory allocation throw exceptions already creating new reader class ca happen unless implementation objectdatabase utterly fails meet contract case application level code concerned database crap
hmm wonder memory fuzzy things changed far avoid putting directory git archive include either
iirc recursive mode treewalk actually giv tree entries never hit
need copy id trees skip id copying expensive jgit memcpy c try defer/delay absolutely required
matter convention try avoid hard-coding sha-1 object names tests save sha-1 setup member variable pass parameter
dependent platform default character encoding always safer specify known encoding required supported java e.g utf-8 iso-8859-1
add copyright line ostensibly less 1 line code added class think would longer copyright notice executable code
looks impossible line 105 gzipoutputstream temporarybuffer caller wraps gzipoutputstream currently perform double compression use new block line 90 ca get block startedoutput member flipped definitely double compression
places suppress boxing warnings manually boxing code integer.valueof around expression especially true messageformat.format invocations common error paths think general approach preferred within jgit
closing stream closes underlying stream early wrong close either place
missing copyright notice header
make public make available command type class actually might say put main jar io.util package
test iswindows somewhere depend testing windows string application level code system.getproperty line.separator may accurate printwriter uses default fields declared constructors especially first use
probably would used print string.valueof value touch real writer one place print string
inline save line code print string.format fmt args
printwriter npe passed print null use string.valueof iirc protects null writing null
final
s/occurs/occurred/ also translated string clitext
exit 43 point yea stuck ca report anything try use special exit status users really stuck getting error back echo running bad jgit command get back 43 use anywhere else define mean yea well means jre system.err broken try fixing first
typo s/.s/s./
refs.size less number revflags free revwalk perhaps better assigning flag ref using flag system track reachability single traversal refs revflags free could run batches idea line 144 skipping ref whose tip commit 1 day older target commit may able get executions reduced one batch avoid additional traversals
markstart pointless run resetretain anything else
require commit come revwalk reference equality test equals test
may faster revflag temporarily borrow allocate flag revwalk see using revflags track reachability multiple refs reduce number traversals performed
s/.toobjectid add current list/map
rewrite negation inside accessor method faster test bits differently
missing ~
move name copyright header really derived
garbagecollector repacker
take progressmonitor
allow null repository
takes also pass progressmonitor
go direction instead list loose objects look cachedobjectdirectory constructor build set loose scan packs ask contain object remove loose object fwiw c git progress monitor 256 different loose object directories update per top level directory examined
drop assertion legal jgit create index version 1 filerepository
removed dfs storage system objects packs list packs empty repository empty packing need continue local filesystem may loose objects packed test enough
repo bare index method produce empty set
lock read
diff really useful packwriter tell objects seen already elsewhere method scan dircache process objects
correct want keep repository accessible repack phase readers seeing half-written files renaming old files temp files bad idea know possessed suggest earlier rename new temp files onto real names rename fails filesystem wo let try deleting real name renaming yay windows open files
write directly pack file pack name sha-1 object names repository already full packed repack change compression settings output file name also input file write immediately truncate data destroy repository instead write pack idx file temporary files try perform atomic rename onto real names close possible yes repacking existing pack back onto window time pack would appear corrupt idx pack match could first rename away old files temp name rename new files problem arise dfs system use unique file names nothing contents
pack replaced danger existing packindex object memory date relative current file need make sure remove old packfile packindex objectdatabase implementation add pack
convinced code cleaner everything static methods passing around filerepository
two packfiles size parameter two packs go size limit would say many created
yes long expiremillis also able disable prune aka -- expire=never
unclear need objectstokeep object pack file available repository also keeping loose
translate string
relaxed permit creating version 1 indexes user asked us explicitly configuration default version 2
use parens return statements
think subtle bug tree extension dircache tree sha-1s included result head e.g due user force updating reference without updating index match gc prune objects away dircache corrupt git-core iirc tree extension needs also considered objects index uses
please rely reference equality zeroid objectid.from* create new objectid 0 40 without using singleton zeroid
write temporary files otherwise trash current file object set
final
bother constructor let callers use setter method defined need override default
unnecessary blank line
windows fail jgit pack open 'll need ensure object directory closes pack delete packfile.close right thing think
still time review prune sorry
think git-core adds old new ids id zeroid rationale logging might enabled reference already created old id still kept around mentioned log may wrong
went double checked git-core behavior patch set 14 include new old ids packing make one change ignore newid zeroid somewhat valid reflog entry use zeroid newid position indicate branch deleted *not* delete log file git-core handles case cleanly pushing old id record thing jgit push newid zeroid
yes also use excludeobjects idx dfsgarbagecollector right thing code consider blob q exists graph look gerrit web ui may misformat email -- -o -- -b -- -o -- -o -- master | | | q \ + -- -- -- -- -- -- -- r refs/changes/12/1212/1 | q another commit r non-head also points q current code pack q twice second packwriter see r actually packed considers r. look contents tree b determine q part r set pack excludeobjects created make pack want use 'll need expose packindex packfile
never included collection 3rd arg preparepack allheads argument non-empty packwriter uses topo sort topo sort slower ensures r b came revision queue *before* ensures uninteresting flag carried onto deemed uninteresting appear output pack thinking might able sloppy packwriter order avoid expense topo sorting revwalk related gc feature combined think commit resort feature packwriter around line 1620 allowing us delay addition pack sufficiently ok found r found thus cancel commit resort loop ca say proven theory something occurred looking code short would never included q need
need expose getpackindex packfile
delete old packs may want eject unused objects loose objects
accept gc feature eject unused objects loose format git-core went many years people identified bug required ejection process point new objects written new loose objects thus wo packs thus wo suddenly disappear gc really try close hole soon add gc support want forgotten
dc unnecessary local variable think inline addtree call
would cleaner say pw.getobjectcount 0 return null
think really try support case repacking different compression settings producing packs object set different contents means changing code write pack index temporary files objects/pack directory later renaming final target names actually using temporary names critical preventing readers trying read partially written index screaming index corrupt
mark pack setreadonly use filechannel ensure data synced disk return claim file created already optional feature creating loose objects git-core *always* fsync done creating pack index repacking extra time fsync takes minimal compared time takes make pack
use channels.newoutputstream wrap filechannel outputstream writes go channel means force call works data expected
abbreviate public structure names numberofpackedobjects better name even though longer
s/set's/set/
` git gc -- auto ` number loose objects reasonable wonder may efficient invert way set difference construct set objectid consisting loose objects scanning loose objects directory set empty nothing non-empty try proceed proving need objects repository repacked prunepacked fast reduce set considerably first ensuring run might good idea method start removing objectstokeep set non-empty done repository repacked really cut existence test work considerably keep ref objects used generate packs perform prune comparing current reference references used make packs every reference identical objectid reference created modified interim implement prune looking packindexes loose object packindex older expiredate blindly removed realize prunepacked already taken care removing objects exist packindexes means left loose object directory garbage really look anything delete files sufficiently old enough references move pack creations need run objectwalk difference old reference set new reference set keep loose objects suddenly referenced reflog entries refs changed need look tail reflogs recently repacked think still take similar shortcut run objectwalk back current references find objects pack files everything prior also pack files consider point something pack ref time pack creation current refs run algorithm though repacked working guessed set references
also consider reflogs
pack files .keep file .keep file two different reasons common reason pack recently created ongoing transport operation yet connected references .keep file created protect pack removed gc would ok copy objects put new pack happened reach objectwalk future gc pack would eventually deleted transport operation ends .keep file removed reason .keep file exists really big pack files consider download entire linux kernel repository 480m 2.2m objects put .keep file next downloaded pack local gcs fast git wo copy 480m new pack pack handful new objects since pack git-core packs 480m matter minutes may useful human make .keep file case consider repository 64gb yes least one exists someone told repacking take long times packing placing .keep files alongside pack make future repacks go quickly avoiding copying objects pack .keep flag
also like case include objects appear packs .keep file alongside delete packs consider packs prune repack think handled .keep case gc class
declare gc instances thread-safe simple
inline drop operator initializing pm
extra trailing 1 currently lot 2 weeks
oh l l. prefer l trying force long
li pack loose references packed-refs /li
s/created newly/newly created/
nit extra blank line
new file oldpack.getpackfile .getpath + .keep .exists
minor style nit could declared line 227 right loop
unnecessary blank line
equals better name since return boolean think also declare method static
suggest passing list string refdirectory
could well list packindex set relying reference equality
idiom twice class maybe helper method somewhere would good
make excluded list put front add 0 since contains objects need pack next writepack attempt nonheads
getindexfile checks isbare throws noworktreeexception comment really correct
add revwalk null line save calling dispose finally block still need call finally case exception throws parsetree
really skipping dirty submodules correctly like using zeroid test file mode accurate treewalk.next switch treewalk.getrawmode 0 filemode.type_mask case filemode.type_missing case filemode.type_gitlink continue case filemode.type_tree case filemode.type_file case filemode.type_symlink ret.add objectid continue default throw new ioexception messageformat.format jgittext.get .corruptobjectinvalidmode3 string.format integer.valueof treewalk.getrawmode 0 treewalk.getobjectid 0 .name treewalk.getpathstring repo.getindexfile
prefer using two random file names like objectdirectorypackparser file packdir new file repo.getobjectsdirectory pack tmppack file.createtempfile gc_ .pack_tmp packdir tmpidx new file packdir tmppack.getname .substring 0 tmppack.getname .lastindexof + .idx_tmp
line wrapped badly name idxstream instead
rename fail windows set objects change existing pack still exists file handle still open windows wo permit pack replaced means ca repack repository windows tweak compression settings sure want punt say ca use jgit windows adjust compression settings already packed repository
new files set read rename
fails prior renameto succeeds replace existing pack corrupt repository new index position offset data wrong new pack already place old index point corruption finally runs return tmpidx still exists deleted user corrupt repository pack index disagree ca finish rename new index file anytime panic routine rename fails pack rename ok realidx already exists might ok ensure leave remains behind warn caller things go expected boolean delete true try tmppack.renameto realpack return null delete false tmpidx.renameto realidx file newidx new file realidx.getparentfile realidx.getname + .new tmpidx.renameto newidx newidx tmpidx throw new ioexception panic index file + newidx + must renamed replace + realidx + repository corrupt finally delete tmppack null tmppack.exists tmppack.delete delete tmpidx null tmpidx.exists tmpidx.delete
race condition two different jgit threads gc repository time one thread make temporary pack/index file createnewfile fail see exists delete first thread one creation event fail tries rename pack exist anymore assuming posix filesystem
optional nit rename ext clear supposed extension
implementation match documentation numberofpackedobjects using hashset objectid removing duplicates spending lot time gather data instead use packfile f repo.getobjectdatabase .getpacks ret.numberofpackedobjects += f.getindex .getobjectcount
unnecessary assignment value already 0 new object
optional consider returning setters support chaining configuration
nit none parens necessary
using string feels odd places jgit taking dynamic length input caller use list rather array list easier construct dynamically internally might keep arrays length change frequently might return arrays as-is avoid wrapping overheads think trust caller muck array
necessary lock every reference order pack rely atomic compare-and-swap sort nature loose references avoid needing locks correct algorithm lock packed-refs file read loose reference update new packed-refs in-memory commit packed-refs file lock loose reference delete loose reference exactly matches packed-refs file avoids needing lock could get nasty deadlock conditions callers also trying something similar lock nice order
nit curly braces required
nit extra blank line
would done do/while.compareandset outer loop chances thread competing gc thread update looserefs entire thing one list rebuild fail compareandset means something loose references change reader observed different set content disk start gc means probably loose references ca prune away think unlikely gc thread starved able make progress
packsizelimit handled inside packwriter nontrivial change done independently change
vi apparently get along yesterday squash
poorly formatted comment please correct line wrapping
wrong indentation
broken gerrit code review looks like adding tree mode dircacheentry type accept missing nontree guard modeo flag
sucks log diff show option block wish knew way duplicate still get options supported args4j
first part try block duplicated log would nice case
duplicated lstree share code
duplicated log share code
yes version number support protocol partly intentional servers supposed try work around client bugs clients supposed fail randomly email shawn pearce woes shawn wants stop certain emails arriving inbox every day violate git conventions try test versions http know bad
course problem without git commit graph available hard test sorts versions containing given fix make educated guess say build based 1.7.6.1 exactly 1.7.6.1 1.7.6.2 similar behavior 1.7.6.1.
yes discard -rcn component really fit integer coding scheme think ok
really used twice
done
done
update lines major changes made otherwise header would 3000 lines long listing copyright information 400 lines test code practice copyright 70 years death author thanks us law means code covered copyright bsd well past 2077. updating date 2010 2012 useless noise major changes justify updating date also means using new header line add new author unless already header line advance date forward rarely update date see copyright length adding new author means work large enough actually covered copyright law new contribution usually 250 lines code non-trivial nature might alternative forms idea trying jerk particular contribution want point project style perspective usually advance dates update header lines especially 5 lines test code modified assertequals- asserttrue
update end date copyright line
nit packdigest.update onstorestream two calls still next operate range buf matter goes relative calls
actually buggy data left buffer e.g bavail 17 bytes skip consumed e.g boffset 8175 bytes leaving stream first 17 bytes still buffer slide 17 bytes start buf later read buf 17 bytes create corrupted stream unit test show bug happens subtle split buffer cases object header spans 8192 byte boundary pack stream obj_ref_delta base sha-1 span across 8192 byte boundary difficult input construct need get alignment right header section object span 8k alignment think want skip bavail new mark set
please pull onto prior line
local necessary write try return subrepo.resolve constants.head finally subrepo.close everything work correctly goes hunks file
bad indent
caller fault pass treeid dir dir/.gitmodules exists read incorrectly done passed treeid made path dir/blah instead blah also caller fault pass treeid tree exist etc ca protect caller making mistakes level jgit api assumptions make input roughly valid carry
form updated readmodulesconfig
curly braces required
hmm good point walk effectively done time method returns
actually simplify code way cnt 0 condition running drop variable altogether make assumptions like return cnt instead break change return cnt 156 return 0 change 152 return -1
yea well feel like writing packed-refs version obvious face locking really want another concurrent writer attempt create reference chosen put packed-refs
done
changing code report different error message related batching updates together would rather keep error handling matching current behavior later address errors reported clients separate set changes think happen protect internal server details clients setting result message less revealing string
clarified actually isallownonfastforwards basereceivepack nothing whether force update command set
renamed isallownonfastforwards matching basereceivepack
done
done
ok non-final
done
method deleted
return void
done
done
cmd.execute throw ioexception catches internally sets rejected_other_reason message
close repository done finally otherwise may hold open number file descriptors
release walk done finally otherwise may leak native resources
walk.parsecommit headid starting revwalk use parsecommit rather lookupcommit walker expects already parsed gets added
need iterator revcommit commit walk.next
also need use old snapshot read index git-core pre-smudge entries index write smudge future index reads need smudge entry write dirty clean relative old index timestamp
fix may
trailing whitespace line even existed old source lets fix new file
trailing space
trailing space
trailing space
trailing space
trailing space
trailing space
trailing space
trailing space
trailing space
trailing space
trailing space
trailing space
trailing space
trailing space
trailing space
trailing space
trailing space
breaking much code new base class copyright remain 2008- new base class
may able define terms abstracttreeiterator use getentrypathbuffer getnamelength methods expose new method name offset
testing nul bit low level code able rely ptr end logic
kind doubt copyright class
strongly disagree putting code tree parser use many places connected local filesystem also performance critical concerned running time impact going would instead put stuff dircachecheckout code maybe isinvalid abstracttreeiterator check path buffer invoked dircachecheckout calls per path check path buffer sane hands buffer filesystem check path buffer every time parse record canonical tree
alternative implementation faster would pathsegmentbuffer use instead getentrypathbuffer pathsegmentoffset return pathoffset patchsegmentlength use instead getnamelength pre-computed tree parser advances current entry might want look abstracttreeiterator base class defines path buffer methods access entire path current segment name
probably would prefer windows .equals null return value getproperty os.name npe routine instead assumes windows
true default
wish good answer avoid operations like sha-1 4g data maybe custom subclass worktreeiterator provides single fake huge file returns fake objectid cached thus avoiding need run sha-1 input stream
thrilled adding 40 seconds whatever unit testing time verify truncate long int way git-core would better mock 4g test somewhat asking local system deal 4g temporary file middle small fast unit test
would still prefer mocked version test run 1 second gave us better confidence rounding logic ignoring real file version default ok mock tests bulk logic every test run
method nested pretty deeply would use early return pattern setting canonlen first returning inputstream rather setting filteredis least use else pattern pull else else else levels deeply nested
done
put first two different variations string report first file e.g user pushurl pushurl file report first case variant used last
see reporting first variation rather last
see comment email problem inode may changed open length test resulting buffer sized correctly
lost error condition think want include two places long sz path.length sz max throw byte buf new byte math.min sz int max also array grows buf.length valid buf.length max throw byte nb new byte math.min buf.length 2 max
ca true math.min would return max nsz would maz think really meant write buf.length valid buf.length max throw buf.length valid grow buffer read data file ca grow buffer growing would put buffer larger maximum size caller wants method read return yes small issue whole file might fit seen eof yet read would see eof work around checking eof throwing buf.length valid buf.length max int next in.read next -1 break throw
capped max byte nb new byte math.min buf.length 2 max
missing version tag
missing version tag
want function parse sh style line quoting logic gerrit code review apache license 2.0 i/google would willing relicense edl use jgit since depends jgit quotedpath code handle sh quoting rules anyway
also annoyed least 2nd time seen github product forcing git redefine formats bug misfeature github implementation gets spread widely choice accept jgit still chokes refuses accept trees leading 0 mode github introduced web editor
ugh git-core really accepts repositories repositoryformatversion field thought required property part way safe assume directory really contains git repository make change would like documentation commit message pointing git-core says ok open repository without repositoryformatversion field
using system properties configure jgit configuration come config object
bit late think auto crlf handling low system impact objectinserter objectinserter dealing raw byte sequences supplied either byte inputstream tempbuffer originally meant copying inputstream deflater inserter using strongly favor pulling stuff inserter
service object held stack available garbage collection immediately dofetch scope ended instance member connection held caller stack frame may getting held longer would like try/finally set field null ensures service object lifespan reachable scope dofetch method theory caller also holding connection like fetchconnection fc transport.openfetch try fc.fetch finally fc.close 'd rather worry much buffer space might get retained inside service object fetch fails caller holding onto fetchconnection longer least behavior guess alternative implementation would pass reference smarthttpfetchconnection atomicboolean service use read finalrequest boolean seemed slightly cleaner
good point rewritten comment block
drop final qualifier r fit one line
consider inlining method small
please fix really weird line wrapping
parnaoid synchronize caller responsible using synchronization swapping stuff back forth across threads jgit thread safe special places e.g repository objdatabase refdatabase makes rest thread safe actually ok common usage fancier things starting threads
say get rid buffering entirely suggested making flush available caller could get flush force output buffer wanted
use filteroutputstream implement output public outputstream getsidebandoutputstream return new outputstream public void write int ch msgout null msgout.write ch public void write byte buf int pos int len msgout null msgout.write buf pos len public void flush msgout null msgout.flush done
maybe export outputstream caller ask outputstream getsidebandoutputstream msgout null return nulloutputstream.instance return new filteroutputstream msgout public void close way also control flush behavior force underlying side band flush right think messages get stuck side band buffer head client either full later receivepack forces flush end
yes would help change getadvertisedrefs return null hook called setadvertisedrefs may need audit callers within jgit make sure ok ordering operations suspect ok wtf know
ouch sucks consider write hook wants show refs/heads/ refs/tags/ lets also consider may want support mixed hooks chain hook use getadvertisedrefs look current map pick refs/ heads tags reset map ok really slow prior hook getallrefs pre-populate transport object defeats one notions hook try use lower-level apis scan subspaces needs right clean way know prior hook whether replacing prior results filtering etc
please drop since simplified block
like upload case think null assume refs
null assume empty yes means well behaved hooks use db.getadditionalhaves seed collection document
ack agree needs done hook filter protect clients
sort inclined say hook call setadvertisedrefs method refs advertised means default hook implementation make sure set call made running uploadpack.setadvertisedrefs uploadpack.getrepository .getallrefs
particular refactoring fairly big maybe could done commit making ref advertise hook easier review follow-up commit
unnecessary whitespace change
called hook runs still defaulting refs run hook think hook fire rely db.getallrefs
starting think null refs advertised
check precludes cas comment line 267. older git clients send zeroid old id field deleting branch type create oldid zeroid constructor fails really sure need enforce two checks constructor take type supplied
think method reset caller given acting small utility match call stringutils class either stringutil stringutils remember whatever use pluralization revwalk utility
robin think want clutter class method might open smaller definition long count caller sets start/uninteresting points first calls count run iteration increment counter
bug
curly braces
good point go ahead optimization remove null instance get length final array correct
may worth empty single element list case hooks.size 0 return postreceivehook.null hooks.size 1 return hooks.get 0 return new postreceivehookchain hooks.toarray keep static factory method please fix npe
fails pass hook1 null null hook2 result array hook1 hook2 null null onpostreceive method npe tries invoke 3rd element try cute filter null hook
line-wrap seems pretty long
curly braces
bug
maybe line wrap
curly braces
bug
curly braces
curly braces
curly braces
curly braces
made plotcommit serializable long chain parents could really big stream
also 3 append calls chain buf.append getstartnewline .append .append getnewlinecount cleaner 3 separate lines line wrap
caller break loop reset work default reset implementation nothing means retry attempt inside catch block change anything code stuck loop forever
seek ip approval apache mina sshd also switch main ssh client use mina sshd client probably better written
disconnect no-op connect failed need guard session.isconnected session.disconnect
c git support escaping path ssh git+ssh ssh+git style uriish http style uriish re-escape pass uri remote http server bothering unescape
think c git supports escaped paths scp style uriish thought passed path as-is remote host wrong jgit unescape 20
set reference final
instead error throw runtimeexception encoding supported
would encode 0a always 2 digits
need worry odd corner case http http //host/a/b 2fc/d decodes a/b/c/d may fail remote server b 2fc component meant parsed single directory component /a/ namespace b think pretty unlikely happen may worthwhile least writing test case shows happens uriish documented expected behavior
optional usually prefer see blank line long try/finally block like declares new local variable
instead using bytearrayoutputstream allocate byte bytes.length keep running len counter decode take byte ,0 len decode buffer know exceed bytes.length loop either copies byte-for-byte collapses 3 bytes 1 e.g 2f
+ 2 input 2 really valid hex escape substring + 3 fail
assume utf-8 encoding input string length string utf-16 instead use rawparseutils class parse hex digit byte using hex parser functions style-nit put spaces commas method calls
private
style-nit curly braces necessary paranoid jvm platform encoding specify constants.character_encoding
typo escape esacpereservedchars
suggestion use bytearrayoutputstream really adds little value result longer bytes.length copy result twice right want keep output index counter loop using new-style loop iterator maybe would make sense try use result buffer type hides result buffer pointer heavily relying index direct array access efficient new substring call character position walk string point easier follow code source destination buffers using approach direct pointer array whatever keep bytearrayoutputstream think silly allocate temporary byte array copy temporary byte array real byte array call rawparseutils.decode accepts array starting position ending position thus need temporary array
still assuming length bytes utf-8 matches length chars utf-16 consider case new uriish ssh //user host/氓path 2estring valid input 氓 represented single byte utf-8 two-byte value think loop fail horribly input produce reasonable result think would prefer loop convert bare 氓 url encoded version utf-8 form thus cleaning input going need throw urisyntaxexception refuse input right think method mangle input position byte array position string object try perform parseint non-hex text
may worthwhile use java.net.uri sure much saves us get correct uri handling http https yay esoteric helper protocols http https example two schemes internal google like google some-thing-name use http https style string part current code think escape getpath right converts a/b 2fc/d a/b/c/d may wrong remote system using raw path require callers set raw path url escape utf-8 use setpath method url escape consistently permit corner case a/b 2fc/d
use getrawpath a/b 2fc/d case preserved formatted string
os.write tmp 0 2 alternatively could private static final byte hexchar 0 1 2 3 4 5 6 7 8 9 b c 'd e f os.write os.write hexchar b 4 0xf os.write hexchar b 0xf
rawpath escape n
need ascii version
style-nit used tab every one enums methods use single space
support amend bisect
really quadratic java substring n returns new string object uses underlying character array cost new string object construction quite low cases loop runs given facts readable use shorter two-line version logic use longer version tries avoid creating intermediate string objects case additional unnecessary leading slashes supplied premature optimization evil
javadoc bytearrayoutputstream states initial capacity buffer default 32 bytes probably need messages set default 128 bytes usage double size either jvm heap exhausted message done created
good catch yea care
refs/ getallrefs look everything including head
take 2nd argument pull new temporary byte inflated delta instruction sequence use binarydelta get size result test max object limit result going big abort allocate result apply delta command sequence get visit.data created apply null temporary byte garbage reclaimed
would add check obj_ref_delta delta instruction size sz larger maxobjectsizelimit would abort massive instruction stream want server attempt process unfortunately get sha-1 point time delta inflated max object size limit protecting server repository large garbage sent user abort earlier rather later input
put max object size check start method update objectdigest using sz parameter allow catch object pack file whole representation commit allocating buffer even computing sha-1 downside tell user sha-1 huge object would argue try expensive inflate compute sha-1 something really big rejected server still really want instead type blob case
still really want tell user sha-1 big object type obj_blob 0 maxobjectsizelimit maxobjectsizelimit sz
add 0 maxobjectsizelimit maxobjectsizelimit sz throw new object tempobjectid huge
far late performing check already committed jvm heap memory hold entire object memory really decreases value max size feature
maybe include size parameter exception
going compute sha-1 object header parsed 1 insertion rather 3 whole obj_ofs_delta obj_ref_delta
would argue wrong include object header part size object never included size object talk size object git done correct
known certain highly probable delta instruction sequence larger max size result result object larger max size evil user could create delta instruction sequence produced smaller result delta evil harmful server typical user would use delta sequence smaller result object generally delta chosen delta copy data base object delta needs insert needs represent copy ranges yes delta bigger limit pretty certain result big accept
missing copyright header
least report size user gave us refusing
really always case guess change code find interesting findbugs insistent faster
oh good catch restore took thinking blocklist would default directory 256. argument present blocklist uses smaller directory 1 4 entries
please delete line
style-nit hard read maybe getrepositoryname null return getrepositoryname .hashcode return system.identityhashcode
style-nit curly braces loop necessary
sure comment actually provides value
style-nit prefer descriptive test method names rather javadoc test method
style-nit please trim trailing whitespace
delete necessary created empty .git directory valid git repository setmustexist true repositorybuilder build fail zeroid would returned even though directory exists empty
also assert worktreeiter id zeroid
also assert worktreeiter zeroid
please add test submodule deep path e.g module a/b/c top level
style-nit use instead
style-nit chain call repository git new filerepositorybuilder .setmustexist true .setfs getfs .setgitdir submodulegitdir .build try head git.resolve constants.head finally git.close
use current fs detected one
repository object must closed
called setmustexist true twice least one unnecessary
typo empty
optional would bother around section
third paragraph idea deferring renames one suggestion make easier find places like developer forgot flush would quickly corrupt repository either unit test workstation
true traditional objectdirectoryinserter flush currently nop may always hold one idea junio hamano considered writing objects directly pack files rather loose filesystem considering thing getting bunch smaller objects inserter may want use approach similar dfs code buffered 1 mb buffer ram flushed pack file processed filesystems may faster say 4 objects coming inserter since make pack-*.pack pack-*.idx least expensive 2 objects especially true fsync enabled lot objects written stream objects pack defer fsync calls everything written rather fsync new object gives host os better chance combine writes together fewer disk io operations even ca least data given host fewer interleaved fsync calls giving fewer stalls application long story short objectdirectoryinserter reserves right make flush required correct operation actually considering morning making change odi write temporary files insert store map objectid temporary file name inside odi defer renames flush way local filesystem behaves similar dfs variant must call flush risk object disappear would make easier jgit developers find broken code broken code would likely cause git repository corruption commonly supported storage
yes good point passing inserter reader constructor sure worth api change could also pass setters used
think making inserter merger mistake try share inserter caller wants create commit object way dfs system write single pack new blobs/trees/commits rather 2 packs one blobs/trees merger single commit would also give odi chance consider putting commit pack chose inserts part pack
good idea find time would interested refactoring
really long line line wrapped probably implies use due statement longer one line
style-nit blank line param tag
still style-nit blank line param
style-nit indent first part text spaces used tabs block
still style-nit use spaces instead tabs indent inside javadoc comment
declare depthwalk.objectwalk need downcast
two sort lines pointless depthwalk honor
critical exception something unshallowing continue means simplify code removing try/catch make like simple interestingobjects loop
downcast unnecessary declare walker variable correct type
insane reasons often allow package level visibility sorts fields edit directly rather using getters/setters removes need jit try inline getter/setter logic means perform better even jit ca inline getter cross-classes
keep getter sure endorse setter part public api yet 'd rather keep package level would client need edit depth commit
style-nit always put /** line starting documentation next line
style-nit indent wrapped lines another level
think comment overkill sort implied would use commit type
like think comment useful enough stay
static class
typically expose fields public package know argued expose private really meant package/default access public
javadoc would caller want
style-nit continuation line indented one level
call markstart see comments setup depthgenerator
class public
bother field pending.outputtype fast enough outputtype method
constructor public also style-nit line long/wrapped incorrectly also used depthwalk getters depth comparemode instead taking revwalk take depthwalk get depth comparemode downcast depthwalk revwalk since depthwalk always revwalk given caller inside pendinggenerator invokes
simplify lot setup pending new fiforevqueue pending.outputtype 0 would replace sharefreelist well loop suck current generator fix outputtype might tagged sort_commit_time_desc
would probably implement way around since pending well backing store pending.sharefreelist q mirror intent caller invoking this.sharefreelist q subtle issue discarding potentially large free list bottom stack pushing empty free list top stack weird know least mirror caller intent
would downcast right away final depthwalk.commit c depthwalk.commit pending.next
actually parses right away object already parsed parsing yuck guard c.flags parsed 0 c.parseheaders walk
normally use seen flag prevent commits entering pending twice far tell using depth provides effect took long time think since deviates typical pattern relying flag track processed already please provide short proof need flag prevent duplicates stuff comment future readers expend many brain cells whether works easier verify proof derive one fly
style-nit parens necessary
style-nit bother else continue end loop let occur normally
're right defining term unshallow correctly lead misunderstanding lot implementation 'll re-read entire patch set light new explanation thanks
documentation correct unshallow commits client done transmitting marked uninteresting really first descendant unshallow commit marked uninteresting commit whose parent unshallow uninteresting
allocate flag also part depthwalk reason walk gets reset runs 'd allocate yet another flag enough times walk suddenly stops working free flags explicitly releasing flag hard generator api walk tell generator walk reset easiest thing may allocate time unshallow flag individual walk classes
hmmph almost makes sense commits pass test branch heads client wants depth 0. little concerned may corner case though happens client wants new branch new branch pointing commit unshallow set 'll wind empty pending queue process nothing means client wo get commit asked us 'll crash yet asked unshallow may make test c.flags revwalk.uninteresting 0 work around corner condition however would pushing unshallow commits actually start points bug depthwalk.objectwalk markunshallow method call markstart however also need uninteresting commits iterated client may given us commit common wanted client already uh far harder thought might try poking tomorrow see better distill conditions involved express internally
everything us including us new unshallow something client yet
think logic incorrect still think want proposed patch set 1 comments c.has unshallow p.add unshallow c.has uninteresting p.has unshallow c.add boundary else p.add uninteresting renaming reinteresting flag boundary
think really produce produce c.has uninteresting c.has boundary false
style-nit initialize 0/null/false jvm implicitly
style-nit use unnecessary curly braces
style-nit line long prefer lines 80 characters given tab stop setting 4. also performance reasons please try use objectreader walk member using may caching involved would improve shallow computation yes sorry mean need constructor depthwalk.revwalk class
style-nit avoid local variable shorter loop revcommit want wantcommits depthwalk.markstart depthwalk.parsecommit want
never true reference equality two temporarily allocated strings instead need say c.equals works current master rebase patch pick fix point simplify loop remoteshallowcommits.contains packout.writestring shallow + o.name
style-nit really see good reason throw blank line anywhere would make sense put new advertisecapability option_shallow given big capability set
style-nit space also like use curly braces simple conditionals like one
think easier think using depthwalk.objectwalk need additional state client already told us old shallow boundary know new shallow boundary want color every object aka commonbase uninterestingobjects list including old shallow boundary flag uninteresting add new flag unshallow old shallow boundary depthgenerator loop parents commit something like c.has unshallow p.add unshallow c.has uninteresting p.has unshallow c.add boundary else p.add uninteresting block replaces standard walker.carryflagsimpl logic something specific carry uninteresting edge cut carrying unshallow instead output every uninteresting commit relevant instead produce logic deciding depth cheap something like produce produce c.has uninteresting c.has boundary false basically coloring everything boundary uninteresting normally produce find commit uninteresting parent unshallow commit boundary edge client server client parents excellent point return uninteresting commit packwriter use trees blobs delta bases returned pack carrying logic may seem odd add boundary c looking p right thing tag given commit boundary discover parent edge need 2 extra flags depthwalk.objectwalk allocate using newflag boundary newflag unshallow unfortunately also need unshallow set uploadpack pushed whole thing getting specialized shallow clone case think ok stuff really useful shallow clone logic
iirc shallow protocol still common ancestor negotiation useful limit send still pass commonbase packwriter particular client likely current refs objects reachable changed boundary want resend blobs way avoid pass commonbase part commonbase due standard exchange
c.getdepth
style-nit need around statement
sadly going force us keep bulk revision pool alive longer need instead unshallowcommits.add walk.lookupcommit c way hold onto pointer main pool already retaining long-term maybe better since two collections actually revcommits declare objectid use unshallowcommits.add c.copy shed entire pool overhead
still need suggested earlier shed revision pool memory usage unshallowcommits.add c.copy
style-nit please insert blank line two command test blocks
style-nit please insert blank line new block want test
style-nit space
think would prefer passing shallow stuff new method depth 0 pw.setshallowpack depth unshallowcommits pw.preparepack pm wantall commonbase
christian right add new method accepts set keep collection version auto-convert-to-set logic invoking new set driven version mark collection version deprecated removed 2.0. 'll try rework patch sometime today get updated version uploaded
ah probably right could changed sets many callers inside jgit changing type collection set impact public api break ready go jgit 2.0
add comment explaining walk.setrecursive false must used includetrees true wonder add check misuse includetrees walk.isrecursive throw new illegalargumentexception
instead hashmap operations int 0 entries.length new file dir entries .isdirectory entries += arrays.sort entries fewer object allocations hash operations still use natural comparator arrays.sort scantree routine already need name + directory anyway decide enter scantree scanone using suffix string name entries name.charat name.length 1 '/ scantree prefix + name new file dir name else scanone prefix + name
ohh see saying yes code wrong 'll send replacement patch minute
form public callers always objectreader expecting created/destroyed fly per file seen per-file efficient
*not* change way default update-only-if-existing-on-remote-side logic inside jgit transport code mode matching matching needs happen advertisement received remote side change made push refs/heads/* refs/heads/* would cause jgit also create local branch yet remote different behavior describe push creates new branches agree fixing code use remote configuration good getting default matching rule going take work transport package
really testing checking head pushed nothing else given given wonder set local head name something master verify remote side also not-pushed branch local side observe sent remote
adding refs/heads/* refs/heads/* conditional head symbolic reference
make iterable ref allow caller specify refs want source add method wonder better make slightly generic expense callers needing say .getrefdatabase .getadditionalrefs
given ip process eclipse 're already sort tied anyway
drop test handle filenotfoundexception unlikely unless caller received path readdir result means likely exists return true making exists pointless user application feeds us file path explicitly e.g getref refs/heads/master try open call first somewhat likely reference actually exists need read disk exist exception bit expensive stat think smaller percentage requests getref non-existing names
somehow wrong file may modified time read file io.readsome need capturing lastmodified io.readsome already othersnapshot
wrong need use othersnapshot
think constructors change take filesnapshot instead long mtime
oy similar change assumed cherry-picked mine updated things pushed back realize actually different change apologize assuming based work fwiw change i1556b7e7ea21c31ff76bca930269e0cc7d55cd26 think stupid revert lets make new commit fixes comments made post-submit review
next time take rfc change mine drop rfc commit subject please re-read commit message make sure statements like still body
discards msg argument got jsch maybe class needs new constructor allows us pass msg rather using default text
case old code plain wrong using stringtype password leave original else block first get returns false
chris change ready submitted waiting getting protobuf added part orbit also verify osgi linkage correct
need double check actually orbit
style-nit trailing space commit message
discussed check copyright line correct
quick note state sets class e.g /** initialize formatter compute patch id */
please document methods call super
please use java.security.digestoutputstream instead shave lines class
usually declare fields change final
instead buffering everything byte please create nulloutputstream org.eclipse.jgit/src/org/eclipse/jgit/util/io thought one already maybe created change never applied declare class sure override 3 write methods override public void write int b discard. override public void write byte buf discard. override public void write byte buf int pos int cnt discard.
style-nit unnecessary blank line
style-nit unnecessary blank line
please fill javadoc method format helpers already least partially documented
s/bytearray//
discussed check copyright line correct
delete line
would prefer using 1ff..441 .name instead .tostring
use .name
.name
slightly worried shorten may start come ambiguous branches wo expand shortened name like review refs/notes/review refdatabase consider refs/notes/ namespace one search prefixes different method maybe notemap class
style-nit unnecessary blank line
please add unit test
make public
please elaborate describe strange result instead less strange ok reading bug wish least echoed bug report commit message would saved lot time commenting pgm.diff class hacks used setup test case
style-nit use bug bug also tend put line change-id
please add empty javadoc especially commit whose description gives strange result
make class public
please make public non-final
add empty javadoc
make public
make public
missing copyright header
using diffformatter pgm.diff
use separatorchar
style-nit unnecessary braces
platform specific test mac os x linux test works correctly windows paths please use \\ literally test string
hmm test would fail mac os x linux separatorchar '/ would split correctly '\ point larger test coverage platforms less likely see regression particular platform specific section matter less platform specific sections code better would prefer able also run test mac os x linux correctly test \ splitting behavior means moving selection file.separatorchar inside gethumanishname systemreader class using mocksystemreader set '\ specifically test function perhaps ugly something simple
test pass linux mac os x even gethumanishname broken remove conditional always check function
done
done
done
done
done
done
done
done
done
need keep debugging code would prefer use boolean parse variable support true/false rather set/unset
true could work harder programmer transfer exception object gobbler thread variable shared calling thread calling thread wait completion gobbler thread check exception status actually may want unable read command capturing command stderr stream wrap exception object throw caller rather assuming everything ok printing java stderr
testconflicting
please declare throws exception
please add li conflicted files /li
unit test
would say staged files conflicting files
style-nit use spaces indent
style-nit use spaces indent
suspect need translations lets instead set map easily add entries private static final map string charset encodingaliases static encodingaliases new hashmap string string encodingaliases.put latin-1 charset.forname iso-8859-1 string decoded decode try return charset.forname decoded catch illegalcharsetnameexception badname charset aliased encodingaliases.get stringutils.tolowercase decoded aliased null return aliased throw badname catch unsupportedcharsetexception badname charset aliased encodingaliases.get stringutils.tolowercase decoded aliased null return aliased throw badname
style-nit insert blank line field declaration
style-nit combine static block block follows
alias known jre thus necessary map
given line wrapping lets pull lookup private method private static charset charsetforalias string name return encodingaliases.get stringutils.tolowercase name declare helper method right parseencoding method
style-nit two sections distinct blank line initializing encodingaliases initializing digits10
please import instead import methods used
please assert charset iso-8859-1 charset
know handy wonder catch exception assert message contains xyz
rely jre platform encoding use specific encoding like constants.encodeascii also applies getbytes calls
always true throw null object
style-nit line missing indentation
remark single note operation plural name
flush unnecessary early see commitnotemap
local variable note unnecessary
style-nit trailing space
see comments addnotescommand.commitnotemap code identical
unnecessary
unnecessary
unnecessary
called addnotes adds one note support multiple notes batch rename class addnote
early flush unnecessary see commitnotemap
local variable note unnecessary
please document somewhere object already note existing note *replaced*
use builder.setcommitter builder.getauthor ensure timestamp identical
need inserter.flush
missing notescommit null refupdate.setexpectedoldobjectid notescommit else refupdate.setexpectedoldobjectid objectid.zeroid
pass revwalk call
style-nit trailing space
style-nit trailing space
remark single note operation plural name
unnecessary
unnecessary
local variable note unnecessary
unnecessary
gitcommand class factory methods git like notelist noteshow noteedit matches branch command
settable option
look must use commit map read
inserter flush method called force update setting expected old object id normal fast-forward update
style would prefer list objectid heads head null collections.singletonlist head null also removes need import java.util.arrays
given short method maybe even shorter file file new file getdirectory filename try byte raw io.readfully file return 0 raw.length raw null catch filenotfoundexception notfound return null something tiny really worth trying hoist outside try/catch
like name add perhaps instead call formatwithconflicts since introduced also added mergecommand conflicted merges include conflicts section think today
resulting message end lf think instead want sb.append conflicts \n string conflictingpath conflictingpaths sb.append '\t .append conflictingpath .append '\n
style-nit good reason local variable head
style-nit unnecessary introduction blank line
message end \n
asking state expensive due number file stat calls involved line 133 save result local variable three references reuse computed value may worth using switch statement instead
agree robin change private block directory 0
wonder file argument little bit flexible try guess caller wanted caller passes us working directory .git within use .git/ subdirectory instead failing think simple api users api going try first get annoyed test .git/ subdirectory caller needs precise control find .git/ directory wants scan-up rules use repositorybuilder wrap expert uses api
bit vague lots jgit reads files would rephrase subject support reading first sha-1 large fetch_head files
please fix line say change-id twice
line missing signed-off-by meant put something else
always complete contents contents exceeds limit limit returned
think unnecessary allocate bytearrayoutputstream instead write method fileinputstream new fileinputstream path try byte buf new byte limit int cnt 0 int n in.read buf cnt buf.length cnt n 0 break cnt += n cnt buf.length return buf byte res new byte cnt system.arraycopy buf 0 res 0 cnt return res finally try in.close catch ioexception ignored
file fail delete windows calling thread one touching .lock file causing deletion fail
correct getallrefs still trigger listener fired method exists
necessary anymore refdirectory.refresh trigger event listener one refs detected modified means drop getallrefs call
tried fixing ideally refdatabase would consider refs racily clean modified close last scan scanned similar done racily clean files dircache problem change i1556b7e7ea21c31ff76bca930269e0cc7d55cd26 refdirectory use filesnapshot loose refs still outstanding
much hate idea might need local system case may actually make lot sense dht implementation right dht code caches refs first access never looks backing database expected caller would close re-open repository object needing refreshed set references works ok server environment repository needed short time period current request less ideal ide gui application much dislike needing actually pretty inclined +2 introduction method api
yea thinking dropped test
yes think -1 patch robin remark correct use java.lang.system systemreader
typo name overridegitprefix use systemreader.getinstance .getproperty rather system.getproperty
used systemreader used system.getproperty also use systemreader
style-nit unnecessary blank line docs
style-nit fields start f probably also private
please document constructor properly since public api users expected subclass type
even need transport object appear needed used
document exec connect exec called connect make sense behavior
style-nit trailing white space
javadoc
javadoc
javadoc
values note today assume 0 means success non-zero positive failure matches posix exit status values
style-nit instance fields go static methods construtor explicitly initialize null prefix instance fields f
would prefer something bit verbose like /** return new connection remote system */ private usually javadoc private methods
style-nit class private constructor package default access rather public
style-nit trailing whitespace
document parameter null happens
style-nit package private code constructor
style-nit remove added final keywords
style-nit remove added final keyword undo reflow
style-nit remove added final keywords
style-nit remove added final keyword
style-nit remove added final keyword
style-nit remove added final keyword
style-nit remove added final keyword
style-nit remove added final keyword
style-nit please revert reflow javadoc
style-nit try pulling back onto prior line block closely matches old version
style-nit please revert reflow javadoc
style-nit please revert reflow javadoc
style-nit please revert reflow method declaration
style-nit reason add final
style-nit please revert reflow javadoc
style-nit reason add final
style-nit reason add final
style-nit reason add final
would prefer newconnection method name since new object created
jsch session protected access thus visible unless subclass transportssh sure passing transport constructor helping maybe need wrap session remotesession type put transportssh remotesession remotecommandconnection factory transportsftp case 'll require remotesession instanceof jschremotesession downcast pull jsch session handle
transportgitssh uriish instead decide setup connection given remote host/port going
yes please something continue review discuss thanks
since constructor public class well documented make class public
style-nit trailing space
style-nit trailing space
please reflow comment text badly mangled maybe consider pulling 105 145 method called setupstreams would remove least one level indentation try constructor might make easier deal deeper nesting inside else block timeout setup
style-nit curly braces single statements
guess really better way implement waitfor *sigh* least short timeout
seconds typical timeouts milliseconds pass long timeunit
style-nit revert reflow
style-nit revert reflow
style-nit trailing whitespace
timeout milliseconds api javadoc suggested seconds wanted clarify
strictly speaking -- break options away non-option arguments saying -- path little weird
style-nit trailing space
please document path relative top level repository must either name file directory exactly support regex wildcards etc
assertnull authorname make change breaks everyone else code assumes localconfig.get userconfig.key .getauthorname fill personident returning null set explicitly going break assumption instead continue guess implicitly mark boolean userconfig says guessed author name boolean isauthornameimplicit boolean isauthoremailimplicit etc let application know current value came os assumption rules rather set explicitly
convinced canonical path really correct path construct going resolve symlinks systems may wind nasty internal path pointing nfs server contains home directory rather say home directory
old code uses 1 -1 32 negative high bit set would get negative array index work java 1 clear high bit force value positive faster means making value positive especially know w1 coming sha-1 bits equally good hash code old code used rather think table used use prime number length rather power 2. since changed using power 2 faster yes bits equally good coming w1 newer code 1 fewer instructions remaining instruction faster execute processors
correct avoiding check size power 2 class 250 lines code including copyright notices documentation changing size inittable gets called non-power 2 ca read much code well -\ class strange restrictions like callers class *must* ensure use add *only* contains would return false object otherwise unpredictable happens duplicate mappings objectid
'd prefer use sampledatarepositorytestcase need commit test please create part test method
branch section necessary tracking ref update lets set test
also assert push result status expect branch created
jetty 7.2 dropped setconstraintmapping constraintmapping method signature calling jetty 8 since removed public method
runs twice run run.super also notes involved wonder move part run invoke super.run time within program super.run calls createwalk fairly early
user passed -- objects super.createwalk set argwalk modify also set argwalk objectwalk created returned get npe yes know -- objects compatible usage npe
still pass integer.max_value getbytes needed allow opening note large like 12 mib worth text happen still make good effort displaying note bigger default size passed throw largeobjectexception maybe want trap display warning note big display might well use getcachedbytes avoid copying
using new revwalk new objectreader base class already reuse instead
mean additionalnoterefs.isempty always null last part always true
since getnotemap return null make sense put null notemap notemaps omit entry going put maybe better getnotemap return empty notemap instead null need worry null pointer checks
style-nit atleastoneprinted |= printednode shorter
npes note ref exist getnotemap returned null either change getnotemap return empty notemap put null notemap notemaps collection
using rawtext reason use split lines strings go convert entire file string split manually either use rawtext obtain string lines one time thus rely lf splitting logic pass whole blob rawparseutils.decode string rawparseutils.decode reader .open blobid .getbytes integer.max_value
probably wrong cygwin git-new-workdir info symlink using repository.getfs .resolve repository.getdirectory info/exclude must missed earlier
fwiw getstring requires n search locate relevant key usually work around using sectionparser stuff like coreconfig objects cached inside hashmap reduces lookup cost closer 1 fortunately code ones per workingtreeiterator egit might creating many wtis period several minutes time needs update decorations although probably still pay higher cost read file look key n search might bigger savings caching file contents probably worth creating new sectionparser might ok put existing coreconfig one
using excludesfile repository.getfs .resolve repository.getfs .userhome p.substring 2 cygwin user might pointed us ~/.my-ignores symlink someplace else
might also want use repository.getfs .resolve
instead null test no_refs empty array constant initialize refs constructor need worry null getref
dircache.newincore might better
nice test cases thanks
would say return code true path length filter matches length current path supplied treewalk
would rather generate copy path right test length expose method treewalk exports path length
paths like /foo/bar //foo//bar handed function callers expect treewalk handle foo//bar foo/bar foo//bar bar within subdirectory name within foo likewise leading slashes
propose replacing existing method new one occurred wrote comment might able replace method smaller variant using pathfilter code existing pathfilter mostly thing add treewalk setrecursive false tw.issubtree true pathfilter done enter subtree path filter done part new would need add pathfilter class let see treewalk current length equal pathfilter path length lengths know target treewalk current path shorter know need dive subtree may much cleaner solution less code going mess parsing path
entire method pretty complex think rebase onto current master take advantage changes made abstracttreeiterator recently private static int nextslash byte pathbuf int ptr int end ptr end pathbuf ptr '/ ptr++ return ptr public static treewalk forpath final objectreader reader final string path final anyobjectid trees throws missingobjectexception incorrectobjecttypeexception corruptobjectexception ioexception byte pathbuf constants.encode path treewalk tw new treewalk reader tw.reset trees int ptr 0 int end nextslash pathbuf ptr pathbuf.length int mode end path.length filemode.tree.getbits -1 tw.next int cmp tw.currenthead.pathcompare pathbuf ptr end mode cmp 0 continue cmp 0 return null end path.length return tw ptr end + 1 end nextslash pathbuf ptr pathbuf.length mode mode end pathbuf.length filemode.tree.getbits -1 tw.entersubtree return null 'll need make tiny change abstracttreeiterator.pathcompare line 353 mode entries considered insert bmode -1 return 0 return lastpathchar mode lastpathchar bmode basically lets fix forpath instead adding new special method
java 6 method stick java 5 api jgit
style-nit two lines block wrap curly braces
case occurs path null path.length 0. anything else next token rework logic path null path.length 0 return tree.toobjectid treewalk tw new treewalk tw.addtree tree
style-nit unnecessary blank line
style-nit unnecessary blank line
style-nit unnecessary blank line
style-nit unnecessary blank line
loop condition tw.next f.isdone tw return tw tw.issubtree tw.entersubtree return null
style-nit space
options exclusive one given error maybe instead write resettype mode null soft mode selectmode mode resettype.soft hard mode selectmode mode resettype.hard private static resettype selectmode resettype mode resettype want mode null throw die return want
think implies ref null point might correct wonder drop ref null test code reading like risking npe pretty sure symbolic.get wo return null resolve also wo return null thus ref null test wrong
think returns null symbolic reference requires many traversals resolve start suspect loop common happen
adding iterator state object worthwhile state object shared across levels directory structure iterator changes enter/exit subdirectory thus holding onto per-directory iterator within shared state useful besides state.walk.gettree state.dircachetree actually expensive aside field references jit pretty easily since package visible fields gettree method array access two field accesses reference compare expensive
think philipp right problem method called ismodified content compare needed file entry stat dirty recursing back ismodified via getentryobjectid quick scan code suggests may infinite loop blow stack due many levels recursion even address issue avoiding infinite recursion kind know need scan working tree file avoid dircacheentry
style-nits public static static methods go class constructor clonerepository clone
necessary inherited configuration
also somehow set upstream branch clone works looking advertised remote branch whose sha-1 advertised remote head branch first branch sha-1 used name local branch rather assuming default master branches exist remote yes assume master otherwise based head also named
string uriish
name remote default origin could something else like eclipse gerrit
fail throwing file already exists think based comment line 384 create/overwrite might files already exist resulting ioexception old code ignored failure new code would crash needs continue
caught first review method added api package general convention always returning setter method added void set method first place glad fixed
moved httpconfig object part cached httpconfig obtain repository config file changes made file
think disablesslverify better name method
style-nit make class static need hold onto transporthttp instance
style-nit prefer import names use short class name instead
yes already incoming data fully loaded byte two reasons existing data wo also fit byte jvm heap full get outofmemoryerror allocation turns largeobjectexception receive aborts incoming object match lengths way shorter either get largeobjectexception getcachedbytes arrays.equals would fail fast array lengths worried object-not-fitting case actually packparser handle objects deltas fit memory large whole objects different code path streams sides checking collisions rely compressed data validation determine yes exact compressed stream content local copy might loose compressed content differs local copy might compressed different compression level receiving even different version libz may generated slight difference local copy delta something else compressed content different think would often see compressed validation fail inflated validation pass makes compressed validation somewhat worthless entire lets check already rule exists readers prefer existing content dht storage implementation making explicit content copy came another copy makes simple reader prefer already existing content thus need compare contents reader would automatically ignore new copy prefer older one already later garbage collection remove newer copy
robin means need test filter include ran final atomicboolean filterran new atomicboolean revfilter testfilter assertnotnull cmit.getrawbuffer filterran.set true filterran.set false walk asserttrue filter ran filterran.get way test fails include get invoked also think need dispose commit first loop otherwise test still pass without bug fix
s/parsing/parse/
would reword revfilter.include documentation promises revcommit's body parsed include invoked always true commit parsed body discarded revwalk reset started new traversal
blargh revfilter docs say body parsed yes reset might gone unit test breakage regress
thoughts exactly chris lets drop get time replace getnote delta may actually smaller duplicating method bodies
lets leave get however part public notemap api callers may prefer variant
style-nit please capitalize beginning short summary
read code right not_equal never occurs due modification timestamp probably mention wonder call differ_by_metadata match differ_by_timestamp
illegalstateexception sort runtimeexception new value added enum fail rather returning true
condition always true set worked total subtract 100 times 1000 files dircache end iteration worked still 900
this.filter pathfilter usually type non-null wo iterate entire repository instead 'll skip large chunks based pathfilter says relevant ok cases progress monitor inaccurate ugly might able better peeking dircacheiterator state index tells us far dircache currently exactly progress this.filter pathfilter skip entire subdirectory relevant dircacheiterator state reflects number paths skipped thus would give us accurate progress update requires poking dircacheiterator api sure want expose internal state like
issue egit treewalk stops without visting every node seem remember problem eclipse progressmonitor stuff ending current task without working 100 units within task confused mistaken worked around egit wrapper adapts eclipse progressmonitor jgit progressmonitor
note mean trying keep people using method rather lockfile class
ok. given method exists agree leaving note place since echoed system javadoc love differences summary though javadoc starts saying atomic later implies might actually atomic since made work reliably cute
threads still running test ends shutdown pool wait terminate leaving test method
done
hate fact load 140 lines code long read single screen without scrolling ca find clean way break search loop away delta application loop also avoiding unnecessary objectloader allocation base found 'd rather take slightly longer method additional object allocation
unfortunate initialize type code flow ensure value overwritten ever read
realized long pushed prior version simplify conditions around whole objects reduce unnecessary compares move whole object case applying delta chain produce result hence patch set 4
eclipse 3.6.1 jdt thinks delta null even though impossible clearly code flow simplest faster prior iterations
done
robin said decompress returns null caught outofmemoryerror means allocation array failed need another allocation hopefully smaller create large delta object loader data base object however allocated held local variable java standard define happens implementation may leave data variable live delta.large call returns value means gc ca reclaim space dead explicitly nulling helps ensure really dead compiler deduce variable dead discard local live set also able deduce assignment null unnecessary drop instruction hurt smart compiler helps simpler one
want use binarydelta.apply data cmds want oom caused failed allocation illegalargumentexception inside binarydelta.apply trapped treated oom caused trying allocate byte array large current heap catching oom usually considered bad heap really memory whole vm fall java applications know true eclipse thus 've careful trap oom small number byte array allocations size array might larger maximum heap trigger oom really outofmemoryerror still plenty heap go around e.g consider case streamfilethreshold set 2047m object 640m size max heap 256m even 200m free heap allocate 640m object byte array resulting oom alloc really oom heap still fine oom throw illegalargumentexception well really bad perform allocation exception want throw stack 're toast heap already space way 're going able recover trapping exception
done
dislike approach delta cases insanely common objects deltas need perform two compares determine type delta duplicating code branches meant yea duplicated instructions least one branch carry instead two
like entire delta chain *and* root base object held entire chain applied way clear variables entire chain applied delta chain frames big fact discarded deltas applied probably big deal root base probably large able discard soon patched delta onto assurance runtime discard delta data method frame non-live applydeltas method invoked need assume runtime simple thing keeping live applydeltas returns case root base still live need clear dead way think keep one method like patch set 4. allocate new little helper object holds variables gets passed applydeltas reference variables heap rather stack 'd like avoid allocation somewhat common case delta gets hit base deltabasecache means longer load method like patch set 4
style-nit point assigning argument going return result
style-nit trailing whitespace
catching oom incurred trying allocate illegalargumentexception base match command stream really serious error want caught see comments patch set 4
class notemerger really use reader inserter please try harder make sure identical objects reason reader may need know inserter created something
wrap method body try finally try current code finally reader.release inserter.release way caller release resources via another method call
know need call anymore understand code works temporary fanout bucket needed tree anywhere write
make mergestrategy configurable defaulting mergestrategy.resolve
think want release drop try/finally block
since dropped writetree call probably need local variable anymore instead return result split
sure want setting source inmemorybucket either side result modification made caller result notemap also impact input map vice-versa later modification ours/theirs impacts result add removing writetree asfanout leafbucket split broke tests wrong earlier would need writetree reusing bucket maybe instead like child null return child instanceof inmemorynotebucket b.setbucket cell inmemorynotebucket child .writetree inserter else b.setbucket cell child.gettreeid
probably could make method non-static change ins field inserter drop 2nd parameter
done
junit 4
junit 4
probably go earlier commit along new unit test verify iterator works expected rely verify result merge merge unit tests
style-nit unnecessary blank line
inner type necessary ca method root null return root.iterator new mutableobjectid reader else return collections. note emptylist .iterator
itr null return false else next throws npe
use method think left-over one prior iterations
style-nit fit one line /** return root note bucket */
public type returns public
s/than/that/
need also modify note class make public allow implementations interface outside package
right use inheritdoc anywhere lets start
might well make public developers explicitly use want
style-nit curly braces unnecessary
notemapmerger using reader/inserter pair need flush flush notemapmerger allows level buffering objectinserter implementation
names must notes value think need 4 strings getname first non-null base/ours/theirs name object note getdata .getname non-null base name blob content note something like private static string noteon note base note note base null return base.name null return ours.name return theirs.name private static string notedata note n n null return n.getdata .name return public notesmergeconflictexception note base note note super messageformat.format jgittext.get .mergeconflictonnotes noteon base notedata base notedata notedata
probably want use name field nonnoteentry rather rely tostring
base could null nonnoteentry exist causing conflict npe need something similar noteon private static string name nonnoteentry e return e null e.name
probably go ahead make constructor public
also need make public otherwise client iterator note see blob attached note
line-wrapping ugly 'd prefer assuming change scanpath return file file gitexe scanpath gitexe null gitexe gitexe.getabsolutefile file bin gitexe.getparentfile discard git.exe return bin.getparentfile discard bin
would prefer systemconfig field name
would prefer systemconfiginvalid translation text name
check systemconfig.isoutdated well
scanpath need run shell order find use scanpath
fallback makes sense necessary mac os x. special case w null ismacosx
preferred making abstract putting bash executions fs implementation might actually use
needs override annotation
really think try first base class rather running whence
s/instaled/installed/ two l
s/^bug /bug missing
please use around return statement since multiple lines inner class overriding load routine
also need override save prevent npe invalid call save made
throws clauses necessary since body nothing
wrapping ugly maybe resolve file first resolve gitconfig way symlinked /etc/gitconfig correctly followed came cygwin file etc new file fs.resolve prefix etc file config new file fs.resolve etc config return new filebasedconfig parent config fs
fs.resolve null /etc/gitconfig fallback system config found fallback works posix systems git installed os distribution theory found config correctly via fs_posix class anyway
typo systemgitconfig
style-nit method indentation wrong entire body needs shifted right one level indentation gerrit correctly see shift right display change correctly intraline difference enabled
instead stack uses synchronized would prefer use arraylist deltavisit stack.remove stack.size -1 pop operation way jit need work optimize locking fwiw though simple usage would make stack avoid extra work arraylist stack/vector impose operation private void resolvedeltas deltavisit visit visit null visit.data visit.nextchild firstchildof oe visit nextvisit visit private static deltavisit nextvisit deltavisit visit parent children discard visit.parent null visit.parent.nextchild null visit.parent visit.parent.parent unresolveddelta childid visit.nextchild childid null visit.nextchild childid.next return new deltavisit childid visit visit visit.parent visit null private static class deltavisit final unresolveddelta id deltavisit parent byte data unresolveddelta nextchild like solution still fairly short saves lot overhead also give us nice tail-recursion case discard object soon last child inflated reducing memory usage long delta chains 1 object level
since initialdelta used prime stack would instead call argument dv reassign loop way one type deltavisit active object scope less likely 'll use wrong one sometimes assigning argument evil sometimes good think sort algorithm one times good reuse argument variable
style-nit spaces around
instead allocating new chain objects could sort two lists single linked list return unresolveddelta start something like null return b b null return unresolveddelta first null unresolveddelta last null null b null unresolveddelta n b null null a.position b.position n a.next else n b b b.next last null last.next n last n else first n last n n.next null return first gives us smaller deltavisit object simplifies code elsewhere probably needing b chains packs 're using ofs_delta format days delta chains b variant take fast path anyway see ref_delta thin packs fixthinpack wo ofs_delta dependencies wo typically b variant use fast path anyway basically rather rare chains slow path rebuild single linked list common
bother type use unresolveddelta base case bootstraps resolvedeltas method using type inside unresolveddelta increases memory usage scanning pack least 12 bytes 32 bit jvms per object scanning 1 million deltas costs us 12 mb memory 64 bit jvm could looking 24 mb think trivial change ok deltavisit type transient need stack management ok make massive increase relatively persistant unresolved delta chains
think class necessary within single resolvedeltas invocation one type make type local variable resolvedeltas assigned part switch 4 base types obj_commit obj_tree obj_blob obj_tag pass anyone needs type digestusing routine put back inline resolvedeltas routine drops 1 object allocation per object processed resolvedeltas help memory usage decrease gc activity significant enough code probably actually shorter way think makes sense drop type
since bootstrap resolvedeltas data position make non-final assign base case type also discovered stored local variable
list rebuild like suggest one list unresolveddelta type change field non-final update pop delta think find way leave deltavisit stack loop pop unresolveddelta variable goes null end still non-null another delta process update field leave stack alone also reduce memory allocations gc activity re-creating current deltavisit need remember another delta needs base information
good change making instance member thanks
whoops caught one constructor could private since invoked deltavisit class habit mine typically avoid private modifier private inner class methods/constructors enclosing class still access anyway via synthetic accessor methods inserted compiler
right want pay penalty synthetic accessor method jump enclosing indexpack class deltavisit.next method time called next since deltavisit already private method effectively private enough indexpack need protected
static dir final command encoding
also need p.geterrorstream .close think original version forgot
return java.io.file think searchpath probably common name method searching path one lookfor arguments
style-nit 'd prefer dropping curly braces 'll submit as-is
ok think finally understand want getabsolutefile use file parameter exec child process cd new location run executable executable name absolute path execution would fail later makes sense part searchpath make less likely 'll run error
would put getabsolutepath part since want string
really think file right type use list paths conflict relative root working tree ui want show user ui needs java.io.file simple matter joining string root working tree returning java.io.file technically return path object one might even prefixed working tree root still within consider working tree root actually resolved via symlink might return canonical path logical path *sigh* sort-of need nio2 path object maybe implementing something like working tree paths instead relying string file
probably think file right type working tree paths easily cast absolute canonical path might longer part working tree 've trouble egit funny methods convert file string given repositorymapping since looked code might remembering exactly want getparentfile sort support probably introduce jgit path type use working tree paths get without string probably fine
whoops fault thanks fixing
done
done
ah right good catch changing 2500 2.5 seconds objectdirectory use 2 minutes dates back pre-eclipse history commit 4c8d63e588212f48e7ebd09580defd9a62c73c61 author shawn o. pearce spearce spearce.org wed aug 12 12:45:23 2009 committer robin rosenberg robin.rosenberg dewire.com wed aug 12 15:24:37 2009 original file org.spearce.jgit/src/org/spearce/jgit/lib/objectdirectory.java fix racy condition repository repacked filesystem clock granularity sufficiently large enough possible repacking program ` git repack ` change directory within modification time jgit scan directory changes clock step never see later edits directory modification time changed instead keep track last time read directory object found disk pack directory last modified time less 2 minutes since last time read directory contents scan looking changes worst case scenario jgit list pack directory requested missing object directory aged least 2 minutes repositories modify directory times week undue burden host real justification 2 minutes fudge number probably safely change 2.5 seconds
efficient filemode.symlink.equals entry.getrawmode issue getfilemode test number filemode constants see one matches called getrawmode get integer value testing integer value filemode.symlink save compares
need int use boolean
would put failure path d.mkdir skipexisting d.isdirectory return throw new ioexception odds caller wants make new directory reasonably assume exist yet 'll fail mkdir check mode directory 're fine fail
ordering change must bug eclipse organize imports command ca see would though fileheader.patchtype always sorting hunkheader *sigh*
oh right ok certainly simplify block
bug quirk way git works thus treewalk works converted folder directory file names considered equal treewalk equal nameconflicttreewalk rules get folder twice non-recursive treewalk file directory get folder/file path within gone directory made treewalk recursive like test would get folder-as-directory result would see appear made treewalk nameconflicttreewalk instead would get folder
originally removed testnonrecursivetreewalk think want use indexdifffilter isrecursive false useful see subtree nodes see put test back work
declared final much clear values cached registers include
think possible valid values dircacheindex workingtreeindex n must least 2
might well hardcode 0
think reach point directory treewalk.isrecursive false trees equal happens 'll npe ismodified tries use null dircacheentry either document class javadoc filter must used recursive treewalk return true filemode.tree.equals wm subtree considered caller aggressive much complex approach would recursively stat validate directory contents dircacheiterator valid objectid tree 'tree cache extension files stat clean return false back preventing need dive tree objects repository may save cpu time really frigging hard get right face skipworktreefilter notignoredfilter also filter graph filter graph depending caller wants
need special case dircacheindex workingtreeindex pointing tree always need recurse subtree workingtreeiterator provide objectid bypass subtree equality alone filter invoked recursive flag treewalk considered
think want forcecontentcheck true primarily used indexdiff indexdiff used tools trying create commit user user modifies file reverts content back already committed staged revert last modified time file show file modified indexdiff timestamp wrong force content check ensure case
also diffformatter workingtreeiterator dircacheiterator invovled diff any_diff
need flag
file/folder conflict ever see folder recursive treewalk return folders files foo file dircache directory workingtree workingtree also foo/bar see iteration first result dircacheiterator foo workingtreeiterator null second result dircacheiterator null workingtreeiterator foo/bar changed type treewalk nameconflicttreewalk may change little recursive nameconflicttreewalk may well wind tree also file think change safe never seeing tree type iterators recursive treewalk wo return
heck using 7.0.1 osgi land 7.1 maven land 'd like close version possible less surprises tests get run
yes please upgrade version available p2 maven consistent newer release
could singleton constructor private style-nit spaces around
style-nit put closing curly brace line override public void write int throws ioexception no-op
style-nit please make unrelated changes avoid good reason switch math.min min also trying fix code materialize data byte change worthwhile may readability reasons please make separate commit
like math.min please make unrelated changes
style-nit please re-order imports
style-nit never import
style-nit static imports go class imports
ok agree partial fix stll least value us lets fix whole object case non-delta compressed big blobs later work delta chain problem
resolvedeltas part indexpack memory consuming part address use streaming techniques thus far change partial fix problem fwiw harder part fix base object needed entire chain processing
yes need streaming byte-for-byte compare easier change inflate routine provide inputstream caller instead accepting outputstream copies onto
continue existing object check even blobs safety measure prevent sha-1 collision corrupting local repository normally object added repository compute sha-1 check see object exists create new object instead rely upon existing content prevents object sha-1 different content entering repository least continues return older content expected however keeping pack file as-is repository means may wind another copy already existing object order ensure continue return content need compare byte-for-byte slow yes safety feature never trip theory one keep
comment longer relevant since argument applied boolean keep removed
comment longer relevant since argument applied boolean keep removed
creates copy data means copying data twice since code part inner loop indexpack would like avoid copying properly allocating output buffer writing directly might mean variant bytearrayoutputstream written put jgit.util.io
think things easier inflate defined private inputstream inflate final source src final long inflatedsize returns inputstream caller read get inflated data performance reasons try use single inputstream object like use single inflater reset along inflater method invoked way inflateandreturn use io.readfully read inputstream directly byte allocated return caller reduces number allocations copies involved
style-nit use tabs indentation spaces
need compute number bytes inflate 3rd argument maximum number bytes outbuffer receive simplify code int r inf.inflate outbuffer 0 outbuffer.length
style-nit put spaces arguments
unnecessary conversion tabs spaces
unnecessary conversion tabs spaces
done
ok understand point even non-empty repository large percentage blob objects received new streaming would efficient need access data twice however blob already exists already disk io load existing blob another disk io load back part pack bad 're already suffering disk io load existing blob maybe ok always stream blobs take double io hit anytime blob already exists
think special case empty local repository useful add blob deferredcheckblobs blob already exists local repository repository empty check really fast searching empty hash map constant time returns false never put blob deferredcheckblobs
done called dodeferredcheckblobs
done
fileutils.delete asserttrue junit tests
might ok missing file fail delete depends repository constructed test whether pack contain object removed
document thrown code f exist method called therefore cause ioexceptions race conditions multiple concurrent threads try delete file caller care need careful using method
method pass silently exist delete f fails
think document exact number times public javadoc saying retried several times giving throwing exception sufficient
deleterepeated sounds like keep deleting file ensure really removed deleteorretry seems better
wonder ca single implementation whole class public static final int none 0 public static final int recursive 1 public static final int retry 2 public static void delete file f delete f none public static void delete file f int options options recursive 0 f.isdirectory final file items f.listfiles items null file c items delete c options f.delete options retry 0 f.exists int 1 10 i++ try thread.sleep 100 catch interruptedexception e throw new interruptedioexception f.delete return throw new ioexception
instead hard-coding 8 take objectreader use abbreviate method get short string case need 8 digits disambiguate object course requires disk io might good idea within event thread
npe unless user passed -- git-dir command line us means fails mkdir foo cd foo jgit init need instead git git command.call out.println git.getrepository .getdirectory .getabsolutepath
style-nit static methods appear start class instance members
style-nit public static declared *before* constructor class middle instance methods
far know almost nobody reinitializes repository ancient arcane concept
imho created static part git class git public static initcommand init return new initcommand usage something like git git git.init .setdirectory /path/to/dir .call clone would similar
instead returning repository maybe return git way git object ready used caller
bare false wonder append +constants.dot_git
directory null might want use git_dir rather maybe instead builder.readenvironment directory null file new file directory bare new file constants.dot_git builder.setgitdir else builder.getgitdir null file new file bare new file constants.dot_git builder.setgitdir
still need repository.create bare create repository disk
imho setdirectory setdirectoryname
think still use callable class initcommand implements callable git
running findgitdir explicitly set
directory string java.io.file
agree matthias empty_text also gerrit code review defines empty_text constant maybe put rawtext public static final constant drop one gerrit point applications probably also need empty text way need standard constant export
style-nit parens necessary around conditional
style-nit constants declared instance members public constants private constants first declaration class
would prefer reformat html list harder read source reason formatting right invalid html change list proper list type javadoc formatter right thing ul li added files /li li changed files /li li removed files /li /ul
style-nit would insert blank line line
none methods export hashset exporting set string instead case change internal representation something else e.g treeset custom set implementation uses smaller storage easier construct given fact iterate names path-order add hashset string immediately follow change fixes methods return set string please reverse insert new commit fixes existing methods return set string change commit return set string
others declared set string declared hashset string use generic set string field type
set false diff.renames yes diff.renames match c git fortunately getenum almost want honors yes/on aliases true no/off aliases false maybe redefine way add copies renamedetectiontype use rc.getenum diff null renames renamedetectiontype.values translate copies always copy
use stringutils.equalsignorecase
reject null would instead write renameboolean null throw new illegalargumentexception else renameboolean renamedetectiontype renamedetectiontype.true else renamedetectiontype renamedetectiontype.false
nak strips everything first line want trim trailing lf use int end content.length 0 end content end 1 '\n end -- return rawparseutils.decode content 0 end
comment longer matches code
using histogramdiff default algorithm faster source code files produces pretty decent results also simpler easier follow said 'll probably rewrite myersdiff implementation shorter easier understand need find time
also honor variable diffformatter
need instance method static methods faster dispatch need pushed onto stack
would use histogramdiff default days
final
nak public mutable singleton change enum public enum supportedalgorithm myers histogram public static diffalgorithm getalgorithm supportedalgorithm alg switch alg case myers return myersdiff.instance case histogram return new histogramdiff
horrible n insertion slide array time instead use either linkedlist append array use collections.reverse flip around walk complete
using rebase-apply dumping patch files back pretty ugly think instead targeting rebase interactive style temporary data churn work directly inside jvm without writing temporary state hit conflict need stop resolution removes performance disadvantage rebase interactive temporary format actually format faster dumping diff commit disk reading back _really_ want test happens apply series patches another branch rebase know junio c hamano argues use rebase practice nobody uses like rebase keep result successful rebase interactive script better way
necessary new fileoutputstream file create file exist yet
fwiw prefer style fileoutputstream fos new fileoutputstream file try fos.write content.getbytes utf-8 finally fos.close
maybe instead use rawparseutils.decode io.readfully new file directory filename
know read head line 391 parsecommit call head update occurs 're screwed someone else updated head behind backs add refupdate.setexpectedoldobjectid head also revwalk hand pass forceupdate need allocate revision pool
checking ok codes using default errors case refupdate starts return different failure code future assume successful update
would never multiple actions make enum selects operation mode e.g enum operation begin continue skip abort individual set methods assign enum field accordingly
style-nit overload setupstream next variant setupstream
use revwalk allocated constructor
bit magic style works statement actually pulled constructor super repo called thus repo super class already defined funny read like would prefer inside constructor similar revwalk allocated inside constructor
add todo later want avoid cherrypick first parent committopick current head instead fast-forward committopick branch modified c git avoid unnecessary object rewriting really useful using gerrit code review upstream review system accidentally ` git rebase -i head~toofarback ` long none commits modified keep sha-1 gerrit know rebased
assume encoding platform encoding instead use utf-8 explicitly like also commit list change steps unless modify ideally would keep list instance member flush git-rebase-todo file call complete rebase *not* successful way updating file commit instead updating returning control caller
open writer top file reading writer may truncated file making impossible read later sections file one reason use lockfile lot code writes temporary file alongside original rename commit
try avoid stringtokenizer would parse line hand even actually need decode string data parse simple enough load entire todo-list memory byte use rawparseutils scan byte process in-memory representation static enum operation pick later add squash edit etc. static class step operation operation objectid commit byte shortmessage list step todo list step loadsteps byte buf io.readfully new file rebasedir git-rebase-todo int ptr 0 arraylist step r new arraylist step ptr buf.length return r
unfortunately fail head detached head detached method returns 40 digit hex sha-1 c git case puts detached head head-name file also return null npe later fill head-name file think safe thing ref head repo.getref constants.head head null head.getobjectid null throw new refnotfoundexception string headname head.issymbolic headname head.gettarget .getname else headname detached head objectid headid head.getobjectid perhaps longer gives direct access various states involved
hmm always true commit reachable headcommit found included result logcommand thus always merged headcommit thus expression always true always falling cherrypicklist empty
commented
use filewriter encoding platform-specific instead use fileouputstream enforce use utf-8 wrapping outputstreamwriter sb.tostring .getbytes utf-8
reader needs released alternatively use reader current walk reader walk.getobjectreader
missing lf getshortmessage iirc include lf
recall listfiles return null ca read directory stat determine directory e.g x r bit thus prefer something like file children fileorfolder.listfiles children null file child children deleterecursive child since listfiles returns null fileorfolder directory also skip isdirectory test
fwiw .getid calls unnecessary able pass revtree returned gettree directly dircachecheckout constructor
value walk.release finally block call also monitor.endtask temporary resources used revwalk internal objectreader generally pretty light-weight might well stick around duration call
replacing method need initialize parent copy fields iteratorstate object shared parent subiterators created initialize copy parent thus code simpler may bit slower flat trees may bit faster deeper trees java trees deep likely processed jgit due embedding eclipse fact may bit faster deeper trees due less copying recursing setup digest buffer means simpler code probably better anyway
getid necessary revtree objectid
classic way write loop int removed.size 1 0 -- string r removed.get way save subtraction operation iteration form c programmers use go backwards want save subtraction people reading backwards loop expect see form never seen took process loop condition conclude correct
expression changed file.delete file.exists file delete exist fall else case issameprefix removeemptyparents file deletion failed already gone parent might empty might able remove
ok 'll try write unit tests today upload new patch set
done unit tests added code correct written unit tests say
added coreconfig object jgit instead repository.getconfig .get coreconfig.key .getfilemode use cached coreconfig instance cached value core.filemode allows cached value evicted rebuilt property configuration file changes underlying config file disk modified makes egit responsive updates also boolean.valueof exproftypeprimitiveboolean .booleanvalue kind pointless casting boolean boolean casting back uh wtf
think solution know code works directory name i.getdircacheentry null would execute else case call keep null also npe npe late downstream new index contains empty slot think better question looking subtree code path
iirc yes still needed stupid historical reasons treewalk starts empty tree iterator first slot want throw away reset call keep meaning change treewalk remove initial empty tree chance yet initial empty tree help objectwalk turns objectwalk longer uses treewalk uses canonicaltreeparser directly performance reasons initial empty tree *never* useful everyone reset discard drop initial object
would prefer private use getter
style-nit unnecessary blank line
initialize null let compiler require us ensure values initialized every branch
agree downcast ugly clean solution provider callback ask data c credentialsprovider.getcredentials uri username password username c.get 0 passsword c.get 1 something like idea protocol provides prompts provider letting know needs provider returns data credentials object safe probably want pass username/password strings instead prompt type object abstract two concrete instances username password standard singletons likewise could passphrase standard singleton decrypt ssh key
style-nit trailing whitespace
style-nit trailing whitespace
interface limit us prompting twice input caller knows needs username password think http basic auth ask provider twice provider open dialog ask username close dialog return value open another ask password ick interface instead public abstract map credentialtype object getcredentials uriish uri credentialtype types ask either one value multiple values one time still completely flexible ca use interface ask ssh key passphrase example extend credentialtype enumeration new value different alternative idea 'll try uploading replacement patch set comments
c git also takes uriish pull include url given command line performing merge merging remote tracking branch wonder also infer url configuration file iirc git gui generates merge using local tracking branch
style-nit use around statements one statement nested would also put blank line else make code readable ref.getname .startswith constants.r_heads branches.add else ref.getname .startswith constants.r_remotes remotebranches.add
ref.getname commit sha-1 want abbreviate instead putting full 40 digits since summary line full 40 digits available parent pointer anyway might make message cleaner read abbreviate 7 digits abbreviation require pass current objectreader constructor formatter
instead testing short name master would test full name target.getname .equals constants.r_heads + constants.master way accidentally use merge master format someone manages make us merge branch called refs/mynames/master
bad idea might worth moving join collection string string
yup repository.shortenrefname unfortunately static even though use local state might want consider refactoring method static first reuse actually inclined say move ref hard ref interface abstract class static instance member public static string shortenrefname string refname public string getshortname return shortenrefname getname
lets make repository.shortenrefname static use instead getshortname
style-nit insert blank line right
style-nit insert blank line right
dircacheeditor might easier dircacheeditor edit dirc.editor edit.add new dircacheeditor.deletepath path edit.commit
past worked around findbugs instead defining code new stringbuilder str.length .append str .tostring whatever needs end result 1 allocation temporary stringbuilder stack allocated cases modern java 6 runtimes probably would preferred changing code defining exception findbugs configuration file
style-nit trailing whitespace
style-nit put around single statement
stupid code analyzer wrong variables required initialized 0 jre initialize
done
comment fixed
done
style-nit add bug 328551 footer change-id line
commit ca find jgit project
style-nit would put blank line separate two paragraphs issue fix
please declare closer first initialized
call identical one line 164. means pointless call returned null get null think meant test different key tested config_key_merge
comment wrong
fwiw fetchcommand always produce fetchresult unless network error prevented communication occurring even objects obtained still advertised refs ref found error stop immediately fall back stale tracking branch guessed naming convention
since need twice maybe final boolean isremote remote.equals
useful 'll get progress updates tasks terminate going happen per core server 2 cores 'll get update done saying 50 almost immediately another update saying 100 may taken hour reach point threads worked need increment counter set signal makes main thread wake update progress monitor based increments made counter since last time observed counter
well normally progressmonitor *not* thread-safe callers need one responsible ensuring true egit supplies thread-safe progressmonitor invoking jgit worker thread wants updates visible ui thread egit responsible supplying thread-safe progressmonitor jgit calls jgit however within jgit assume progressmonitor owned thread given thread spawns helper threads spawn site responsible making supplied progressmonitor thread-safe wrap threadsafeprogressmonitor unfortunately seems compatible pipeoutputstream need arrange different use threadsafeprogressmonitor would prefer rewriting threadsafeprogressmonitor use different api definition behavior rewrite pipe stream code ca ensure callers wo give us stock j2se pipe stream types would bug reporting currently 1 caller jgit packwriter threaded delta search maybe instead threadsafeprogressmonitor remembers thread allocated pushes updates underlying progressmonitor made allocation thread made different thread updates pushed update queue allocation thread must spin-out new public method 'd change logic packwriter spin update queue threadsafeprogressmonitor tasks running background threads gets somewhat ugly ca easily determine stop spinning queue threads completed one way would also associate worker count-down threadsafeprogressmonitor use two new apis tell worker starts worker ends packwriter tell many tasks start task use finally block tell threadsafeprogressmonitor task terminating spin-out method would stop spinning update queue active task count drops 0
done
like said deltatask code late want progress updates occur tasks complete work units user knows working far object set
makes sense mean ca cache better infinite loop
bug eclipse formatter insists putting space end blank javadoc line formatter runs remove trailing space blank line save coax removing space deleting manually saving file undo right away yes crap time energy debug part eclipse patch
andtreefilter take list also ca make temporary list put three default items one conditional user filter user filter path filter probably faster first list paths cheap evaluate rule project files
ok would call implicit perhaps refdatabase /** get additional reference-like entities repository result list includes non-ref items merge_head fetch_result cast refs */ list ref getadditionalrefs
ok good answer repo.getref fetch_head works repo.getallrefs .containskey fetch_head return false try justify saying fetch_head really ref thus returned getallrefs getref takes input relative git_dir tries treat thing named ref smells enough like ref read ref even really ref justification getref behavior needed compatible c git case someone something like echo somesha1 .git/my_name jgit log my_name also try justify position saying c git implementation ` git for-each-ref ` report orig_head fetch_head merge_head jgit getallrefs method internal api equivalent ` git for-each-ref ` want behave way repository state report names sounds like disagree current behavior rooted around mirroring c git behavior around concepts going try say c git correct though sure ask sort stuff c git list get whole bunch people trying justify way real reason really evolved years design stuff got patched patched patched uh way far adding orig_head goes deal ` git for-each-ref ` recognize orig_head getallrefs either least orig_head like proper ref like fetch_head merge_head carry additional data though proposed add data onto end file use rebase bisect
repository.readmergeheads return content merge_head null file present one item resulting list ui probably notion offer user way deal 2nd 3rd etc items ui wart c git accepts merge_head always assumes 1st item reader fetch_head true implement one fetch_head may multiple results ui might want smarter uses information contained fetch_head say cherry-pick fetch_head might want option include url branch cherry-picked similar way ` git pull ` works even better say merge fetch_head offered default merge message similar way pull would done needs url branch data fetch_head data would normally available ref object since two data objects fetch_head merge_head contain different information beyond simple ref think reasonable say *not* treated ref returned default ref collections application access want data inquire repository already one accessors implemented need fetch_head re-create fetchresult object prior fetch call would created in-memory anyway application care tm always map string ref repo.getallrefs ref r repo.getref merge_head r null r.put merge_head r r repo.getref fetch_head r null r.put fetch_head r argument applications want support two names way sophisticated simply taking users-specified revision string passing repository.resolve string using apis provide full richness data accessing rather trying shoe-horn data rather limited ref interface
nak must show protocol advertisements etc application needs read besides files *not* standard ref format contain one ref fetch_head case also url data branch data fact work like ref bug c git implementation looks first 40 bytes ref like file see sha-1 hindsight might never permitted files ref like stricter ref file parser
sure eat exceptions
throw ioexception like getrefs throw things like permission denied read file see exists
iirc nc needs 0 padded 8 digits trying 8.8x
typo meant dircachecheckout
final commit returned multiple commits right maybe instead say new head returned happens one succeeds another fails whole command stop head partially updated
initialize null revwalk revwalk new revwalk repo try finally revwalk.release
faster revwalk.parseheaders srccommit.getparent 0
ugh something improve name setworkingtreeit maybe call setworkingtreeiterator know heard fancy editor java called eclipse use ctrl-space ask complete alengthymethodnamethatistoolongtotypebutisverydescriptiveofitspurpose means using abbreviations necessary
loop stopped continue looking next commit commits collection
style-nit constructors appear instance methods
lookupcommit assumes thing commit true someone may manually done something repository make head non-commit use parsecommit take parsing hit order ensure new parent actually commit otherwise might create corrupt object parent points something commit head mangled externally
fwiw use case cherry-picking commits one parent called reverting replaying merge cases caller needs tell us parent compare input argument know implement revert keep mind want come back optionally support different parent 1 parents involved
missed changing revwalk.parseheaders srccommit.getparent 0
thanks fixing better
think best class name meaning error maybe call mulitpleparentsnotsupportedexception
unrelated change take refs/heads/foo instead foo expected command take foo prefix r_heads unless setremote true case would prefix r_remotes
done
done
done
done
done
yes min/max n running time 'll rename fields clarify
want wonder bad corner case condition technically impossible happen patiencediff never recursive step empty region issue ignore empty block used throw ise happen implementation works correctly histogramdiff thing perfectly happy input data throw ise empty never throws ise tells patiencediff potentially broken way needs break statement
typo set-upstream
maybe set_upstream
taking string use repo.resolve string convert objectid guess work repeating logic poorly fails things like abbreviations ok special case see remote branch probably something like ref ref repo.getref r_remotes + startpoint objectid id ref null remote tracking branch setup tracking id ref.getobjectid else anything else tracked automatically id repo.resolve startpoint
would prefer trim length r_remotes first split way need split twice get remote name branch name odd constant
method command object type
hideous branchlist branchcreate branchrename branchdelete methods git create different command objects operation think callers handle typing branchcreate vs. branch .setcreate
please rebase one change top exception properly defined used either place
sure ca use branch configuration instead caller must give us options like remote name uri optionally remote branch well override configuration defaults
instead reading branch name twice head read getfullbranch trim starts r_heads
instead loop want ref r fetchres.getadvertisedref remotebranchname r null r fetchres.getadvertisedref r_heads + remotebranchname use r.getobjectid tell object
wo quite create correct merge message pull want know uri remote remote branch name local tracking branch name
kind fence changes packfile make sense run memory complete allocation still try limp along process object stream increasing default 50 mib seems high jvm heap default 64 mib system really wish better method handling random access delta base pack file format allow us random access whole object neither loose object format tried setting compression 0 stream delta back loose object cache zlib still inserts headers every 64k denote stored literal block since headers appear length depends buffer size deflater defined inside c code visible java hard random access within file even compression disabled could implement object cache disk deflate file individual small segments random access inflate near target write cache management area disk native git wo know clean ` git gc ` tough problem good solution yet *sigh* change probably better right
cherry-pick implemented using merge lets say want cherry-pick commit c whose parent b want apply top q -- -- b -- -- c \ -- -- -- q set side q set side c. fix merge base c^1 b. b-c difference shows edit made applied merge side edit b-q difference shows edit made us shows side edit providing edits conflicting merge complete cleanly
please also include standard line copyright owners documented project ip log always update copyright headers edit made file added repository foundation requires us line alert readers copyright notices might sufficient fully document current owners file
code complex enough shared resolvemerger somehow
style-nit trailing space end line
yup agree fully 'll work diffalgorithm abstraction predecessor change post review soon
diff method recursive recurse left right halves halves required produce least one edit result rather editlist r new editlist r.addall diff half r.addall diff half return r nasty continuous recopying data one result list another pop back call stack insert edits in-place diff instance way list copied recursive invocation ca say 've optimized code well yet trying avoid memory allocations excessive copying inside main loop
yes many tests produce identical results myersdiff take diff abstraction idea abstract implementations common base test suite provides tests use two subclasses drive implementation especially testedit_nouniquemiddlesidea b variants specific current implementation patiencediff fallback myersdiff results neither would patiencediff actual fallback degenerate case represent
good point thanks 'll rename
ok document
point trying lazily compute hash code element way diff function works need examine hash code element least function complete therefore need code least therefore faster *not* lazy lazy requires checking see code computed yet per element expensive look patiencediffindex code loops every element region sequences gets hash code sense lazily computing avoid hash computation common header/footers looking common header/footer elements skipping works start end sequence easily defined 0 size -1 work assumption common header footer change least one element either direction due file copyright headers often unchanged due edits appearing middle file rather exact end still leaves us entire mid section compute everything
would require patiencediff perform translation every edit creates translate hashedsequence wrapping subsequence space original space using original element indexes meant translation edit maybe right maybe translation edit end edit list shorter element list deferring translation means save operations translating hash call probably clear 'll rework thanks
done
s/revtag/fetchresult/ s/tag/fetch/
style-nit trailing whitespace fwiw caused setting eclipse format automatically save formatter seems run sometimes remove trailing whitespace stuff causes two fight line formatted driving crazy since configured eclipse format modified lines save
missing checkcallable
missing checkcallable
missing checkcallable
missing checkcallable
missing checkcallable
missing checkcallable also variant takes collection
style-nit trailing whitespace
assertnotnull proper commit tag objects well threw away tag assert values read db equal values created db2 covers not-null did-it-create also copy expected tests one statement
use asserttrue equals use assertequals like junit wants works fixed .equals revobject
think drop test method test006_readcaseinsensitive testconfig already thing require os specific test value asserted
would prefer say oid null oid a.getobjectid using operator
every ref points commit example jgit repository ref refs/tags/spearce-gpg-pub points blob wrapped try/catch catch incorrectobjecttypeexception ignore error
testlinear
parsecommit lookupcommit better way dangerous use createcommit directly might create two different revcommits objectid within walker pool confuse flags later traversal algorithm
3 args-per-commit syntax obtuse would prefer bit declarative within test expense slightly framework implement test either inline assertions c b test setup something lets describe values e.g private testlist expected expected.row c .lane 0 .parent b expected.row b .lane 0 .parent expected.row .lane 0 assertcommitlist pcl
bug markstart commits tagged seen flag prevent added back pending queue encountered parent commit popped pending working certainly bug inside walker
typo name reservedlane
incomplete sentence
sure understand child yet lane allocate one immediately recycle lane make free lane terminates right describe comment
understand point reservedlane concept better describe either comment commit message trying
gopher seriously http
style-nit put + start line end
want promote pattern seems allow http //example.com/../foo nonsense url wonder need different url pattern altogether similar scp_uri special case maybe new pattern test scp_uri full_uri looks like path_uri a-za-z optional drive-letter + |\.|\.\. optional relative path indicator + /.+ top head distracted things going room around hold correct pattern anything think possible recognize local file path like url trying full_uri variant without allowing http //example.com/../foo
interfaces slower perform virtual dispatch classes virtual function tables complicated layout yes jvms gotten better still pay penalties exist abstract base class rationale want add default behavior class later like patience diff patch add reducecommonstartend default implementation based upon equals later replaced rawtextcomparator something tightly tied representation making comparator abstract class means later shift logic class support diff algorithms comparator implementors choice using naive equals based approaches something even faster sequence models support
'll agree size seems misplaced probably bring back sequence put size hash part equivalence function hash computed ignore trailing whitespace different hash computed default ignore-nothing two items sequence equal equals function hashes must also equal putting hash model starts make much harder ensure remains true also want enforce requirement hash pre-computed sequence model instead wanted allow equivalence function handle hash caches hashes model like rawtext great think case patience diff might able get hash line means implementor might able avoid keeping hashes perhaps importantly avoid computing long common header/footers often exist files think move hash
currently use hashes collection rawtextcomparator implementations reach inside read directly see point think removing going bit work 'd like squash refactoring change 'd like actually defer patiencediff optimizations 'd like avoid computing hashes ranges care basically common header/footer elimination aka step 1 patience diff
yes diff implementation knows hashes needs actually planning removing hashes collection altogether rawtext object making diff implementation cache rawtextcomparator hash method stops looking inside rawtext.hashes instead computes hash fly patiencediff means 'll hash lines 've narrowed file skipping common headers footers 'll keep hash arrays throughout execution diff myersdiff think thing right probably common header/footer elimination longer term might changing patiencediff actually construct hashes table assigning unique int unique line hashing b single hashtable first occurrence element assign new unique value way later compares recursive steps int equality bypass diffcomparator altogether
good point 'll drop last sentence
right isempty declared final able inlined complier later jit without larger analysis work required since expression trivial really good candidate inlining 4 loads 2 compares bordering cost method call enter/exit really inline reality thinking much performance selected expression refactor extract method eclipse moved gettype method fast begin coded readability speed think may redundant compares occurring code paths cared lot performance function would probably redo compares occur extraction method planning using isempty inside patience diff later concluded foolish place wanted part critical path patience diff proved point code isempty always false therefore call unnecessary backed forgot undo refactoring
may myers paper uses distance got like christian wording better 'll amend comment
hate configconstants none constants use
google owns me^hmy work jgit
also tostring printing filter graph semi-useful override public string tostring return skipworktree + treeidx + today wished notignoredfilter writing change add tostring right
still think belongs iterators think belongs treefilter callers using dircache walk dropping skip filter want see currently skipped paths really thinking cases like addcommand merge need see path matter may need un-skip entry index working tree actually location least error meanwhile cases like status actually want skip paths even status happen create foo/bar.txt foo/bar.txt marked skipped index highlight case user blindly skipping path one iterator tagged skipped seem quite right caller really want ignore record easily provide treefilter perform skipping job add filter graph like job add treefilter.any_diff want difference across trees
instead mucking treewalk api treefilter class skipworktreefilter private final int treeidx skipworktreefilter int treeidx this.treeidx treeidx boolean include treewalk walker dircacheiterator walker.gettree treeidx null return true dircacheentry e i.getdircacheentry return e null e.isskipworktree callers want work tree skipping filter filters running treewalk
would rename variable part change reference new code bad name might see compelling motivation change lines part commit really try avoid editing lines actually using parameter isskipcurrententry might willing accept rename part commit since need make sense
say find line amusing least class deprecated die
also really apply skipping ignored logic any_diff way look paths supposed even care
s/1/index/
style-nit trailing space
typo invalid inavlid
unfortunately tests class called repositoryconfigtest historical reasons would support idea renaming test class configtest adding new method
look atrepositorytestcase flat assert specific formatting entire file would say string exp testsection \ testsubsection\ \n\ttestname=testvalue\n assertequals exp config.totext
unit test verify works correctly especially concerned regressions future would nice test case shows proper quoting
new unit test version 3 formatted index files would also nice
assume 'll drop new variant add write support
actually file name gitgit.index.v3.skipworktree
style-nit fits one line
actually count 7
last 3 files index
typically use assertequals arrays.equals expectedbytes indexbytes
style-nit line long
assume flag wo final version patch writing support
style-nit please try avoid reformatting lines modified
style-nit unnecessary reformatting
style-nit unnecessary reformatting
please use mutableinteger class instead
whole line still shorter without local temporary variable even need curly brackets basically uh use older layout line code
style-nit unnecessary reformatting
performance optimization categorized one reason want completely break every existing git implementation able read newer style index claim understand saying standards say extension named 4 capitals optional extension safely skipped extensions must rejected without processing 'reuc former category
ok ignore extension whose name fully upper-case still holds true version 3 ok ignore ext_resolve_undo entry add support later
style-nit unnecessary reformatting
style-nit unnecessary reformatting
style-nit unnecessary reformatting
style-nit unnecessary reformatting
style-nit unnecessary reformatting
style-nit curly braces necessary
style-nit curly braces necessary
collides update_needed flag far tel sit bit slot perhaps change one correct definition update_needed would good idea
sure end-of-line comments provide us anything value
style-nit unnecessary reformatting line used indent tabs using spaces
seems use would easier isextended aside oh guy came format taken back shot conditionally adding 2 bytes index record based bit buried deep inside record stupid records *still* padded 8 byte alignment padding wastes 2 bytes would many records 'd bet could fit 2 additional bytes padding *sigh*
faster compare 0 jvm opcodes specifically comparing constant value like 0x40000000 requires using additional instructions load large integer constant pool onto stack compare integer turn around jit bytecode processors perform compare-to-zero-and-conditional-jump pretty efficiently common idiom comparing larger value like 0x40000000 still requires pushing value register instruction stream compare assuming everything jits nicely comparing 0 still full clock cycle faster course assuming compiler smart enough realize mask involved preceding operator contains single bit set therefore result operation either going 0 0 therefore optimize equality test compare zero instead compare constant may compiler and-or-jit smart enough figure case rule pointless fwiw checked sun javac ca optimization even compiling -o anyway even ignoring coding style comparing single bit use 0 constant second time use constant mask contains one bit need test specific bit pattern remains e.g way test filemode
bit either set 0 faster test
bit either set 0 faster test
sure expose public member yet doubt callers really need lets start package private
please similar assume_valid update_needed checking specific byte flag appears avoiding decode uint16
would prefer isextended return nb.decodeuint16 info infooffset + p_flags2 16 else return 0
style-nit cuddle else onto line closing
style-nit curly braces necessary going cherry-pick directly onto master simple bug fix want held dirc version 3 code
style-nit missing copyright header
style-nit use author tags even one useful rest world
think resolve fits better strategy names
missing copyright header
necessary need inserter call getobjectinserter super class manages allocation release
customizable caller interestingly 'd love use gerrit code review also implement recursive variant multiple merge bases latter two uses require *do not* working tree merge also lockdircache instead create new in-core dircache
given robin reverted hide maven output changes still want filteredresources block
trailing space
tab space
trailing space lines
return revtag tag
document concurrentrefupdateexception
style-nit subsequent lines get indented another level iirc really throw unmergedpathexception wrongrepositorystateexception
also need setauthor objectinserter formatting code npe author null tag
objid within tag always null cause tag code always npe ca open object specified null objectid need use head caller set id need setter allow caller set id choose tag something head
bother setting id use tagid instead newtag.gettagid
style-nit put braces around case block unless case block allocating local variables
falling
empty message ok
please leave todo avoid
actually would reverse setsigned boolean
fail id null
args right message recording refname instead constants.head newtag.tostring right thing embed 1 message sure know exactly message text says also think supposed concurrentrefupdateexception
explain message signed supported
really validate expression constants.r_tags + name pass repository.isvalidrefname fail-fast either setname processoptions pretty sure updateref blindly whatever tell relying callers check name reasonable
use instead actually necessary tagbuilder correctly accept null message
s/author/tagger/
line long please line-wrap
iirc resolve return null setobjectid wo check 'll later crash hard check result resolve null use noheadexception point probably remove getref resolve head^ commit fails reason throw noheadexception
compile need pass revobject know object type since caller gave objectid may need open get type objectloader
inserter.insert newtag newer short form
necessary format inserter.insert newtag indirectly
pass revwalk update reuse revision pool already
signed enough try compare boolean variables boolean constants
getters author objectid forceupdate signed getters everything nothing commitcommand tends getters field though missing setall
s/parameter -a/parameter -s/
extra blank line
s/author/tagger/
hate nit use either tagid newtag.gettagid consistently use one form right form 3 lines setnewobjectid would nice used tagid
really internal exception caller gave us tag name wo accept reference name rather different us encountering form repository corruption recover easily caller needs correct input thinking egit ui case ui passes tag name entered user runs call need throw something tells ui backup let user correct input got valid tag name crash something goes wrong deep inside objectinserter totally different kind error egit ui present human
nope still wrong docs /** set true tag command creates signed tag corresponds -s parameter command line
please also add test use setid tag something head
insanely long lines eclipse code style formatter knows line length please apply file know coding jgit netbeans
disagree correct thing compare commit graphs left-right mode directly supported jgit thing called left-right mode configure application level create two revflag instances revwalk call local remote parsecommit current branch add local flag markstart commit parsecommit matching remote branch add remote flag markstart commit step revwalk get back commit contains local remote common merge base importantly stepped looking point built list commits store commits two lists based flags local ones go outgoing list remote ones go incoming list get accurate representation sync finding matching remote branch typically comes repository configuration get config find variables branch. currentbranchname .remote branch. currentbranchname .merge first tells remote configuration block need examine second tells branch name remote 'll need examine remote. remotename .fetch refspecs find one matches branch.merge value map local reference name local reference name need resolve order parse remote branch commit
uh pointless merge base commit parents going one parents actually trying
parsing zeroid always throw exception
rely platform encoding please specify utf-8 something
fwiw never intended dircacheentry class responsible sort status check code meant go new class running treewalk sort filetreeiterator dircacheiterator example filetreeiterator already ability compute objectid file fly derived workingtreeiterator base class sort stuff workingtreeiterator use eclipse iresource apis access files inside egit rather relying java.io.file means could rely eclipse stat cache rather always hitting stat filesystem could make use iresource apis modify files workbench would properly notified edits make relying workingtreeiterator might also simplify logic around mode test already converted filesystem mode raw mode format use index making direct compares easier
getlastmodified returning milliseconds dividing 1000000l going produce wrong unit
also looking racy git case mightberacilyclean returns true need content check matter forcecontentcheck says avoid case index written timestamp file making file timestamp somewhat doubt modified clean
please print stack traces system.err
print system.err
happen user racing us removes file 've checked existing instead silently treat though length ==0 exists false means return true document ok simply return true return true
light ifc4278078b298781d55cf5421e9647a21fa5db24 merged first probably using repository fs means might need passing
like status method never meant dircacheentry code instead meant class interacting treewalk workingtreeiterator way write iresource apis properly notify workbench edit
returns null object exist repository could happen case repository corruption disk least give better error message nullpointerexception object present like throwing back missingobjectexception hindsight mess open family repository throwing missingobjectexception never return null every single caller wants object throws really need fix api fix callers callers responsible checking *sigh*
using getcachedbytes faster make copy promise wo modify array
think dangerous delete file rewrite place safer write temporary file target directory rename temporary file real name rename fails e.g due windows stupidity try deleting target renaming iirc c git takes approach file writing almost always writes temporary file directory tries rename target way crash writing user left half-written file might somehow taken edit instead left file updated
writing channel write file stream
needs try/finally ensure file closed
pretty sure setlastmodified takes milliseconds
document caller expected lock dircache pass
already passed arguments constructor pass method
sorry lagging replies 've code review requests know sum projects working stuff slips cracks unfortunately lost time think right compares require 4th working tree iterator handful probably better keep 4th working tree iterator running parallel compares cheaper unfortunately may wind stat path determine file directory stat wasted later need look particular path name however would rather code correct easy follow really 4-way join fast obtuse always try improve working tree performance later workdircheckout predates workingtreeiterator class could use however still hit filesystem figure going 4th join anyway let try reply 2 context rather
think going faster add workingtreeiterator walk using existence workingtreeiterator current path name tell file exists strategy based directory listing testing set contents memory rather stat call test name present also lets avoid relatively expensive getentrypathstring call
probably apply removed first foo/bar turning foo need safely delete file bar safely delete directory foo safely create file called foo also try apply order starting bottom tree way avoid removeemptyparents last name scheduled removal directory removed hard since removed list string built name traversal already sorted properly keep track directory prefix walk names string last string r removed sameprefix r last removeemptyparents last delete r last r removeemptyparents last private boolean issameprefix string string b int a.lastindexof '/ int bs b.lastindexof '/ return a.substring 0 + 1 .equals bs.substring 0 bs + 1
like 2-tree form processentry think want actually 4th tree workingtreeiterator yea ugly trying merge across 4 things head index working directory target tree rules working directory needs match index and/or head order edit target applied
clever
tabs spaces next lines makes harder read
tabs spaces next lines makes harder read
're trying get rid tree class need tree type thing use revtree
empty tree like thing use new emptytreeiterator instead later ask slot canonicaltreeparser type get back null pointer treewalk internally creates emptytreeiterator dives non-existent subdirectories
really report failures windows application file open e.g microsoft word document file open try delete delete fails returning false working directory finished switching untracked file left laying around external application outside control bad things us imho checkout failure ca remove file want remove since committed point finishing checkout keep going report failure end everything updated ideally make list left-behind files available calling application help user handle messed working tree offering retry deleting files closed application using
already set checkoutentry likewise length suggest set checkout entry
style-nit method static
would willing bet beer next time meet person parentfile.delete break faster system call read directory contents operating system forbidden letting us remove directory long least one file/directory within accomplish tasks one system call trying delete aborting soon work
ick maybe make treewalk field tw.getpathstring instead
test far cheaper cost get path string *or* get objectids yet happens untracked files properly git ignored us happens lot pull test start method fail much rapidly occurs
private
nameconflicttreewalk dived working tree told conflicts tree wants put blob foo working directory foo/bar.c foo/other.c foo directory get path foo index blob working directory tree path foo/bar.c index none working directory file path foo/other.c index none working directory file means need implement recursion logic need keep track d/f conflicts storing prefix path subsequent step walker check see path covered one prefix paths inside d/f conflict working tree conflicting blob record actually something nameconflicttreewalk able tell add isdirectoryfileconflict method nameconflicttreewalk export keeps track current state basic logic might combinedf store treematch iterator new dfconflict field inside treematch null condition near end method set field currently null implement isdirectoryfileconflict return true dfconflict null modify popentriesequal clear dfconflict dfconflict current iterators popping
correct cleanup safe paths registered ignore list
oddly git takes attitude file ignore list ok git destroy probably build artifact something else generated though maybe applies ignores came .gitignore tracked pretty sure though c git happily delete conflicting ignored file
setup whole new tree walk ca use existing walk state check
ok thanks explaining brute force approach used inside ismodified fine
given already done caller also need repeat
also set length
style-nit public api return map set list concrete implementation type sorry missed earlier review iterations
walk.isdirectoryfileconflict point basically ca rely tree anymore dead going away able thing treewalk/nameconflicttreewalk ca try address problem apis rather making new code rely deprecated code
yes always conflict sure sanely resolve case otherwise
actually *might* id tree right really rare though jgit involved
style-nit file.createtempfile sufficient since already import java.io.file prefer spaces around operators like + finally use ._ instead prefix way temporary file hidden view user ` ls ` time checkout occurring
good least spelled spelling correctly
thanks fixing javadoc line 681 returning null line totally contradicted documentation
need trim whatever taken as-is email example malformed commit email contains leading trailing whitespace near needs discarded even exists 'd almost still tempted say proper text address preserve text parsing
parsing commit example array raw contains entire message tail array end message nothing author committer line trying parse right use emaile try find termination point within current line nextlf returns position either '\n whichever occurs first try look range nameb emaile
style-nit private constructor static utility class always last move lastindexoftrim
style-nit use curly braces around simple loops
emaile 1 emaile must according condition line 693 raw.length nextlf return raw.length pass raw.length think need subtract 1. actually think maybe say instead int timebegin emaile int e nextlf raw timebegin e raw.length raw e 1 timebegin e else break true way scan string going forwards rather scanning end backwards leave old time parsing code alone update starting point timebegin
would call legal case maybe move new testparsepersonident_fuzzycases
since nameb unused maybe drop clarify code everyone passing 0 anyway probably hard-coded begin
constructor taken back put misery wonder instead write personident self rawparseutils.parsepersonident constants.encode author + 7 copy fields self way single routine parse canonical formatting constructor infrequently used dropping utf-8 byte upconverting back string major performance hit exchange one implementation test maintain
would prefer link rawparseutils parsepersonident string actual html documentation provides jump replacement method documentation
commit class longer exists master
style-nit try present-tense commit message fix parsing multiple authors personident perhaps
agree tests personident also need tests rawparseutils.parsepersonident constructor used revcommit getauthor method probably display tools relying reasonably certain testing multiple author case even work
realized duplication commit revcommit silly commit parsing code removed class renamed commitbuilder please rebase onto current master drop particular edit need anymore
ca promise parsing body another revwalk revcommit new revwalk continue work future need ensure buffer parsed passing around revwalk created revcommit passed around call parsebody parsebody knows whether buffer loaded essentially no-op buffer already loaded therefore need rc.getrawbuffer conditional check around know promise getrawbuffer implies things accessible getrawbuffer returns non-null imply getfullmessage getauthorident work parsebody promises
use config need load/store methods
comment coreconfig
please document stream may fully read left unknown position consuming unknown number bytes caller needs close done stream easily reset back beginning caller know need document public constant amount stream needs mark calling us want reset
return short read use loop try get full buffer length eof enter isbinary logic
write shorter int size math.min raw.length first_few_bytes
doubt google copyright
maybe shorter way write inputs byte input asbytes 1\n\r2\n\r3 private static byte asbytes string return in.getbytes utf-8
doubt google wrote 2009.
style-nit instance members lowercase
style-nit avoid if/for/while/etc one statement body
easier way implement method usually public int read throws ioexception byte b new byte 1 int r read b return r 1 b 0 0xff -1 callers days bulk io thorugh read byte int int bypass single byte read thus method usually never used jvms days pretty good cleaning locally allocated short-term garbage like single byte byte array end world allocate read
comment pointless true universally across board almost every part jgit uses read byte int int variant whenever possible often times even tries avoid inputstream work object complete byte e.g objectloader getcachedbytes method
instead reading amount fit caller buffer fill entire local buffer worst need 1 byte lookahead worst find '\r local buffer empty need slide '\r beginning local buffer fill rest continue scan think makes main loop read look something like private final byte buf new byte 8192 private final inputstream private int cnt private int ptr public int read byte bs int int len throws ioexception len 0 return 0 final int startoff final int end + len end ptr cnt cnt in.read buf 0 buf.length cnt 1 break ptr 0 byte b buf ptr++ b '\r bs off++ b continue ptr cnt cnt in.read buf 1 buf.length 1 cnt 0 bs off++ '\r break buf 0 '\r ptr 1 buf ptr '\n bs off++ '\n ptr++ else bs off++ '\r return startoff -1 startoff
need call super.close inputstream no-op method instead need is.close
need return single 0 0xff result unsigned
default instance
bet sizehint mostly accurate lets use avoid copying fall back copying behavior wrong byte new byte sizehint int pos 0 pos out.length int read in.read pos out.length pos read 0 byte res new byte pos system.arraycopy 0 res 0 pos return res pos += read int last in.read last 0 return temporarybuffer.heap tmp new temporarybuffer.heap integer.max_value tmp.write tmp.write last tmp.copy return tmp.tobytearray
style-nit would prefer isautocrlf isautocrlf isautocrlf looks funny
're going need whole lot options autocrlf flag eventually would also need complete clean filter configuration run clean filters computing objectid work tree probably create worktreeoptions class package make boolean final package level member workingtreeiterator reach inspect later add things like clean filters worktreeoptions easily carry child iterators
style-nit cuddle else onto line closing
'd prefer negate used true side mean eol conversion consistent thing
ouch scanning eol conversion files 3x per computation going source code files typically small texts 64 kib probably allocate byte buffer slurp entire file buffer work buffer instead reading file 3x jvm actually probably worth special case smaller text files
style-nit one line /** options used process working tree */
rawtext.isbinary bytes faster
style-nit use shorter name avoid line wrapping
style-nit think drop final keyword fit one line would value final declaration short method
style-nit obtuse anywhere even though shorter way read code think would prefer int r is.read contentreadbuffer r 0 break length += r
yup right lost cancellation check move packoutputstream write method check every 128 kib output way actually cancel even middle massive object reused as-is underlying store
imho mess application parse high-level api lot easier work ton code application developers would appreciate something cleaner map int arrays int arrays saying painful fileconflictinfo object value map map string /* path */ fileconflictinfo fileconflictinfo list conflicthunk describe hunks conflicting conflicthunk provide detail range conflicting parent put
style-nit unnecessary blank line
right listener stays registered even hang onto listenerhandle need handle want later remove listener point ever need worry removing listener filerepository always wants know config changes keep listener registered long exists jvm danger cycle anything gc correctly release everything
imho pointless remove resource leakage resulting removing forwarding handle config listener list drop field worry deregistering
please use listenerlist instead
subclasses supposed override maybe method whose default implementation returns true better subclass override false want 're declaring field
better named fireconfigchangedevent
existing configchangedlistener
missing edl copyright header
s/testchangeeventsonlyonsave/testfilerepository_changeeventsonlyonsave/
style-nit would put blank line various sections test make easier visually see oh setup run verify next setup run verify
nak needs tag.gettagger null w.write tagger w.write tag.gettagger .toexternalstring w.write '\n produce tagger header line identity appear never create empty header line 'll fix cherry-pick
fwiw see reason add copyright header negative delta whatever sort tiny negative change trailing line copyright owners trivial edits new copyright lines eventually result 100 lines worth copyright headers surviving code due small bug fixes etc years yuck
safe also need inserter.flush inserter.release think going cherry-pick onto master fix
agree chris please move treewalk.filter package top-level class 'll need add int argument constructor caller pass index workdir tree filter also better name might notignoredfilter since selects entries ignored
style-nit would prefer return workingtreeiterator.isentryignored
style-nit usually put else end block fall return workingtreeiterator null return true
false true dive subtree order properly evaluate ignored status given entry
filter immutable created clone simply return
done
done
done
headset object boolean java 6 api need define cutoff super.getentrylastmodified 1 instead
please declare variables within scope needed like inside loop
message index/file opposite string actually
style-nit remove commented code
deleteonexit create file trash directory test cleaned automatically test ends also delete function returns
please use platform encoding tests
would flip order release inflater first basically fail super.close could still throw sort exception 'll cherry-pick make change
need path string d/f conflict true entire time recursed path walker knows pop level ca faster boolean variable null test thought prior iteration feature used abstracttreeiterator field tell inside d/f conflict
public see nobody needs part change
need introduce equals part change anytime introduce equals also implement hashcode object used hashmap hashset
use .equals
use .equals
style-nit use tab javadoc
breaks apart diffentry two entries one delete one add
s/diffentrys/entries/
still hate diffentrys bad english diffentries strange class called diffentrie hence generic term entries proposed text also missing sort word like thing two things makes sense thing two things
appear score 0 100
style-nit prefer 0 score score 100 easier see score bounds
would call breakscore
horribly slow entries arraylist shift every later cell split worse splitting everything particular case make newentries add items going break way modify shift existing entries array
comment entries shifting arrays slow
really worth new method used exactly might well inline call site
yes save similarity score deleted node broke pair recombine modify set score score deleted side diffformatter updated add dissimilarity line header shows inverse score modify score non-zero score 15 displayed 85
non-modify entries added back onto newentries
use remove faster remove-and-get one step get later remove key
please drop reformatting hunk
please drop reformatting hunk
test write functionality actually reading file making sure format expect rather relying read code path
please spell '\n '\n
always writing lf id also ids know copy better id.copyto fos id.write '\n tiny writes fileoutputstream bufferedoutputstream write everything single system call rather two syscalls per object merged
hmm must missed earlier probably bit forgiving use rawparseutils.decode possible commit message already utf-8 local encoding rawparseutils fall back local decoding utf-8
really use ioexception current root exception type hierarchy elsewhere jgit export
style-nit braces necessary
would rather interruptedexception abort loop entirely return false instead organize try int 0 10 i++ catch interruptedexception e return false way worker thread stuck waiting second lock file release user hits cancel ui thread interrupted abort right away rather keep busy-waiting entire period
final
alex sure talking bufferedreader filling make sense context class output stream assuming meant bufferedoutputstream working important stream flushed method run reachedincorelimit care underlying stream gets flush need start spooling stuff memory explode heap method calls switchtooverflow invoking flush worth could cause partial block left last buffer written underlying stream may wasted system call could easily aggregated subsequent writes stream doflush switch overflow stream flush bufferedoutputstream gets flushed underlying outputstream created subclass also flushed yes subclass implement overflow return bufferedoutputstream means might double-buffer however worth checking see stream bufferedoutputstream special case around bufferedoutputstream stacks well long wrapping bos uses buffer size buffer size inner bos inner bos become no-op simply pass wrapper byte array underlying stream default buffer size sun jdk 8192 bytes size block size however intent subclass overflow method raw stream without buffering supply buffering since class called temporarybuffer example file subclass directly returns fileoutputstream gets complex uploadpackservlet overflow stream servletoutputstream buffering undefined certainly extend bufferedoutputstream servlet containers buffer 1 mib chunks buffer hard say happen
later series remove tofile want bother dealing editing remove later pretty sure way series non-optimal yea case like something changed commit gone 3 commits whatever *sigh* get experimental refactoring hacking winding 65 commit series
could wrap unmodifiableset care enough bother caller finds change set later start caching bet 'll use unmodifiableset crash api breakage told modifiable
variable declaration assignment fit one line put one expression eclipse line wrapping getrepository part next line found harder read get
try remove getdirectory basically working tree related code explodes matters getdirectory used tell meta stuff like index config merge_head merge_msg fetch_head repositories working tree think would expect files .git/ thus expect meta directory hold right care getting bare repository run without local filesystem means meta directory null ok would never check meta directory really workspace-in-the-cloud idea need also split meta stuff away local file io going bigger task splitting object/ref storage based looking series open pushing refactoring would prefer get basic storage stuff done first still need get indexpack done example still requires local filesystem storage dumb transport fetch client also still mostly assumes local filesystem destination least get basic storage stuff done start something slick like bound-thin-client egit working directory local filesystem repository branches objects remote smart git-aware object server recently accessed objects local really slick thin-checkouts eclipse.org example without needing suck everything still behave like envisioning something bit smarter shallow clone
tried get rid concept directory repository proved nearly impossible instead define getdirectory able return null
yes path runs multiple times release multiple times objectinserter objectreader required support using object release following completely legal objectinserter oi oi.insert oi.release oi.insert oi.release oi.release oi.insert oi.release even back-to-back release without use valid minor cpu time waste
good point could moved lookup inside try variable failed notice going rewrite series fix minor issue think worth time writing new commit fix either maybe next time someone 'll realize stupid mistake correct
yes release objectinserter lot code change plan move tests in-memory repository wo compression/decompression data thus would need worry leaking inflater handle test also tests run jvm pretty quickly right leaking inflaters waiting gc fix things finalizer big deal fact gc might even bother run finalizers much garbage created tests needs finalization jvm might terminate cleaned long story short worth given leak amount code needs change current tests newer tests however release stuff yes keep programming style consistent
good point constructor pointless bad habit developed years ago stop
want check alternates packs first local filesystem basically looking pack files faster filesystem system calls likely hit packs bulk objects intentionally examine pack files examine loose objects code nasty examine pack files recursively alternates *then* examine loose objects directory recursively go alternates particular rule hard-won c git side based experiences across lots platforms including windows mac os x filesystem system calls horribly slow compared two three binary search steps in-memory table held inside jvm heap
crap typo introduced whitespace arrrrgh thanks catching really sloppy
see attempt clean http //egit.eclipse.org/r/1047
thanks also fixed 1046
eh style seems include p anyway might habit dark days javadoc \n meant space p required get proper paragraph break
baserepositorybuilder type parameterized type repository creates type builder implement chaining methods two type parameters horrible thing use application level code class exists define type parameters sane defaults prevent application code needing care filerepositorybuilder wants different values type parameters still wants roughly logic throw baserepositorybuilder
thanks fixed http //egit.eclipse.org/r/1046
know produce cache key cache key repository stored memory cloud know factory method repository class give us one guess change would instead add getrepositorycachekey method repository allow implementation override key repository register close key object
reason produce fetch_head compatible c git reason c git produces fetch_head carry data ` git fetch ` ` git merge ` ` git pull ` also act handy reference last thing got really value jgit writing file last part last thing got 'll never need carry data fetch merge code local file nuts think perfectly ok stop writing file less-conventional repositories last thing got proves really useful could try update standard ref called fetch_head via updateref lot predates idea remote tracking branches updated fetch
please see rewrite code http //egit.eclipse.org/r/1035 think already concern fixed
think see problem data truncated inf.inflate return 0 0 0 loop break method return caller packfile caller checks inf.finished marks object corrupt returned false
experience short list single bit errors middle pack stream one object whole file damaged truncated course single bit error wrong object ruin entire tree things depend delta base
fixed killing http //egit.eclipse.org/r/1045 streaming stuff fully implemented code unreachable
caller supposed try/finally packwriter calling packwriter release call reader.release release early soon writing done try kick memory need create index file tossing try/finally writepack probably pointless fail 're heading caller finally block anyway
final change object life style tends initialize constructor inline declaration non-final fields anyway pulled -1 constant better declare intent value
renamed inflate setinput ie93a5bae0e9e637b5e822d56993ce6b562c6ad15
stuff part fs class maybe declare /** file system problems atomic renames return true caller retry failed rename lock file */ public abstract boolean retryfailedlockfilecommit
put retry logic lockfile dircache uses could either keep code better convert class use lockfile rather custom logic lockfile stuff robust anyway
also delete rule iirc reason ensure already smudged entries stayed smudged change smudge logic length based longer makes sense actually source bugs always selecting modified files potentially racily clean
style-nit javadoc like git commit message short single line sentence first line paragraph break usually p html element rest method description
document needs exactly two tree iterators involved since 0 1 accessed loop
error messages need externalized strings jgittext class jgittext properties file
abbreviate create full objectid really mutableobjectid idbuf new mutableobjectid walk.next diffentry entry new diffentry tw.getobjectid idbuf 0 entry.oldid abbreviatedobjectid.fromobjectid idbuf tw.getobjectid idbuf 1 entry.newid abbreviatedobjectid.fromobjectid idbuf keeps object allocation minimum using locally allocated mutable object id buffer
test objectid use filemode filemode.missing side exist
think findexactrenames descriptive name method since exact case
hmm abbreviatedobjectid immutable hashable instead copying objectid lets hash abbreviatedobjectid key
ca arrays.aslist result constant length means 3rd item key 'll throw exception add arraylist set size 2 arraylist diffentry tmp new arraylist diffentry 2 tmp.add old tmp.add del map.put id tmp next addition 3rd item array list double capacity 4 elements 8 16 etc
make 100 constant lets call something specific like exact_rename various reasons think might want exact rename score bigger possible similarity score easier tweak special constant assigned
remove returns diffentry eliminates need get line
put list back empty
make easier extend similarity based matching code would added tempadded getentries set done would something like entries.addall added entries.addall deleted added null deleted null done true collections.sort entries plug similarity pass invoking new similarity pass method findexactrenames method run
style-nit pointless javadoc blocks removed made non-pointless
use entry.oldmode entry.newmode cheaper access calling walk.getfilemode quite bit work actually
please avoid reformatting code changing
please also document converted id complete thus recast back objectid loss
accept anyobjectid since copying field values
reformatting
please move line around constructor essential patch
style-nit tostring style looks like diffentry add newname diffentry copy oldname newname score diffentry delete oldname etc please match course bit easier buf.append type get type part duplicate name case label string text
style-nit static method
style-nit put around return
also test happens ask compute return b c unmodified since exact renames
know talked 90/10 wonder still good decision test scores dropped good amount git content mostly king wonder weakened content signal much making 90 checked c git source code think using 1 name similarity score maybe compute 99 /1 contentscore 99 + namescore 1 100 means actually lot rounding error since scores currently 0,100 range maybe boost 0,10000 range combined still wo overflow int carry precision final score computation near tie content level broken strong name similarity would modify similarityindex.score method take base parameter many steps score range occupy 0 base pass 10000 make clear score 10000 rather 100 content
style-nit break next line
short-circuit loop entirely dirsim dirmax loop happens rename file rename within directory case set dirscoreltr dirscorertl 100
style-nit break next line
style-nit break next line
style-nit create local variable return expression return
please update commit message reflect actually
find awkward way phrase condition elsewhere talk common 100 max min 100 max renamescore
good catch thanks fixing
modify score 0
also something like assertequals 0 fh.getstartoffset assertequals fh.getbuffer .length fh.getendoffset
score 0 modify
score
resulting fileheader patchtype.binary setting case
new method unit test
s/it it/it is/
thrown
instead utf-8 use constants.charset
initialize increases chances would forget set return value myersdiff instead declare variable final initialize arms conditional statements 2 locations compiler prove set different conditions
think comment incomplete ioexception reasons read one blobs order generate edit list typically document adding corruptobjectexception missingobjectexception throws clauses javadoc missed original formatting code moved *sigh*
oooh printstream yuck actually need printstream everyone handling encoding write buf directly
flush necessary no-op bytearrayoutputstream
style-nit unnecessary blank lines
ever fully skip file mode check long story short want confuse symlink file workingtreeiterator subclass actually detect symlinks hope future basis checkfilemode flag ignore difference executable bit file type difference must honored different even checkfilemode false
think logic wrong forcecontentcheck filelastmodified cachelastmodified return false time check content else return getentryobjectid .equals entry.getobjectid else content check forced assume dirty stat differs return filelastmodified cachelastmodified basically meaning forcecontentcheck want refresh index aka update stat information path match working directory file contents fix racily clean problem fix paths user touched file actually made changes contents racily clean handled differently also force content check handle racily clean would check racily clean condition side forcecontentcheck block testing file modification times content check right code content checks files unchanged proven unchanged stat information hurts big repository
expression entirely redundant remove still get behavior forcecontentcheck false fall else compares values returns true
call filepattern addcommand call filepath actually treat relative root working directory similar merge think add factory provides command arguments set command addfile addpattern different behaviors setup add request add multiple things one call dircache needs locked written rather per file specified user interface
lock dircache simply reading unlocking sort waste time use read need look question block file exist working tree yet told add nothing ` rm foo git add foo ` stage deletion probably want either
also tw.setfilter pathfilter.create filepath need anything loop execute tw.next already positioned file want touch dircachebuilderiterator knows manage rest entries outside space pathfilter matches ensure stay unaffected resulting dircache
think work well filepatterns empty throw illegalstateexception call filepatterns.isempty true
understand test necessary dircachebuilder giving 3 records file merge conflict something else going necessary would appreciate comment help explain condition make sense
faster way implement ask treewalk entry exists tree 1. already know memory whether file exists need stat tw.getrawmode 1 0
think always returning true due nanosecond bug found fixed
imho length lastmodified captured *before* write object object database way change occurs file saving database index entry appear dirty also length lastmodified filemode available filetreeiterator file exists means actually kill getrawmode 1 test suggested rely cached stat information pulled treewalk traversal filetreeiterator f tw.gettree 1 filetreeiterator.class f null file exists entry.setlength f.getentrylength entry.setlastmodified f.getentrylastmodified entry.setfilemode f.getentryfilemode entry.setobjectid ow.writeblob file
probably mistake dircacheentry api overload setlength accept long application level code type cast likely day git index file format support files 4 gib applications go change code occurs
please keep file sorted key name
please keep class sorted key name
tend include author tags project
style-nit one blank line methods
please use new file basepath .gitignore instead string concat platform specific character
please use repository getdirectory determine .git assuming git directory root .git work repository core.worktree configuration setting
instead taking java.io.file 'd prefer take string path root repository reason processing ignore information time walking trees treewalk parallel walk thing able ignore rules run part tell us current path considered ignored treewalk sorted-name depth-first traversal repository structure cache keep track enter/exit directories apply correct set .gitignore go ignore code given workingtreeiterator ask iterator level whether .gitignore name even exists avoids stat hit level see file even exists usually exist also use workingtreeiterator tell last modified time length file decide worth reading file keeping cached copy might memory nice start quite way hoped could build ignore support
please print stack traces system.err hard discover within eclipse
style-nit unnecessary parents around target
apply
style-nit useless catch/throw declare catch 'll throw caller
bypassing hashing ca hash avoid cost hashes object altogether simply create may mean need *not* extend rawtext need expose method lets override construction hashes table instead returns null fwiw probably still hash collapse multiple spaces single one compute hash value
add test leading whitespace make sure leading whitespace differences still reported
add tests leading whitespace make sure ignored trailing type
add test trailing whitespace differences make sure ignore trailing whitespaces
also test foo f f foo make sure test end condition fall main loop one strings shorter
would include case testequalswithwhitespace test two compares whitespace lines
style-nit author tags
style-nit jgit put curly braces around single line statements
performance-nit pull a.content b.content bs local variables within body loop evaluate array index per position basically compiler ca prove a.content modified two reads 'll read since array bounds checked runtime recheck array length jit _might_ able avoid array bound check pulling local proves compiler cache value safely
think entire logic would simplified could write method static int trimtrailingwhitespace int ptr byte raw use correct ae even start main compare loop compare done need worry checking tailing space end common trailing spaces end lines prefiltering line trim mostly no-op one cr crlf file trivial even break first non-space character compare probably huge hit prefiltered ae start likewise simplify code trimleadingwhitespace method prefilters bs main loop starts know looking non-whitespace character start loop need skip whitespace characters first non-whitespace code share lot similarity trimleadingwhitespace possibly making performance-nit desirable implement
performance-nit nit pull raw ptr local variable evaluated twice
foo b f would breaking early bs first iteration return true even though strings actually equal
move rawcharutil class use subclasses rawtext
given trimmed whitespace loop going redundant think remove trimleadingwhitespace 84/85 let loops inside main loop handle
well ideally ae 0 bs 0 way know checked every character thing expression odd way say return ae bs direct way say must evaluated every character ranges
please include standard jgit copyright header new files
style-nit include author tags jgit
still hard time groking end start typical pattern say start end easier visualize think also drop subtraction instruction inner loop bit smarter handle bounds int ptr end 1 start ptr iswhitespace raw ptr ptr -- return ptr + 1
think better name repositorysetupworkdirtest test class repository class test setup work directory
call setup teardown test case automatically run junit
think message assert overkill one assert per test test method name descriptive condition looking test 2 lines get path call assert enough rely test name tell us sort condition failed test fails words would called test testisbare_arbitrarydirectoryisbare one testnotbare_hasdotgitnotbare etc fwiw copying style another test uses test00n_ prefixes old style horrible mistake part started jgit trying mimic style c git test suite bad idea
places bare also assert isbare assert getdirectory getworkdir match expect return values especially since asking repository class guessing based gave
since set bare like 4 5 different times test suite pull utility method setbare gitdir true setbare utility method create temporary repository set flag save config
please catch illegalstateexception expecting anything else gets thrown test failure
method private exists support methods test class
deciding bareness looking core.bare configuration file iirc algorithm something like core.bare set use core.bare else git_dir explicitly given git_work_tree assume bare else getdirectory .getname exactly .git assume bare else assume bare since complex enough code throws exception bare probably introduce public boolean isbare method perform decision making define getworkdir throw isbare true also bare repositories index files getindex getindexfile also throw exception
translated message
please refer comments patch set 1 line think sufficient test
javadoc updated reflect new exception
javadoc updated reflect new exception
see set getconfig .getstring core null bare null later getboolean true maybe put getstring null isset method config make easier test
even core.worktree set configuration file might set caller repository like 8 forms constructor takes various arguments one work tree path could come environment variable
style-nit please nest end-of-line style comment inside method call middle conditional feels wrong 'd prefer comment block part conditional instead
think better approach worktreeconfig null workdir fs.resolve worktreeconfig else getconfig .getstring core null bare null getconfig .getboolean core bare true workdir gitdir.getparentfile else workdir null else constants.dot_git.equals gitdir.getname workdir gitdir.getparentfile else workdir null pretty none setup code git-core sane horrible mess nobody likes touch algorithm completely utterly broken users expect keep working like
logic constructor wonder simplify method public boolean isbare return workdir null
throw ioexception illegalstateexception getindexfile least throw type consistently
nak 'd allow call reasonable application setup repository bare git later point working directory
use assertequals rather asserttrue junit report include expected actual values test rather vague message probably also test full path liable fail use different resolve method test repository used probably head using canonical paths compare rewrite method file exp getfile expected .getcanonicalfile file act repo.getdirectory .getcanonicalfile assertequals exp act
use asserttrue equals use assertequals instead
still think couple helper methods make tests easier read private void setbare file gitdir boolean bare repository repo new repository gitdir null repo.getconfig .setboolean configconstants.config_core_section null configconstants.config_key_bare bare repo.getconfig .save private void setworktree file gitdir file worktree repository repo new repository gitdir null repo.getconfig .setboolean configconstants.config_core_section null configconstants.config_key_worktree worktree.getabsolutepath repo.getconfig .save tests bit declarative setup condition tested
test redundant testnotbare_createrepositoryfromdotgitgitdir
test redundant testnotbare_createrepositoryfromworkdironly
test redundant testnotbare_createrepositoryfromgitdironlywithbareconfigfalse
bleh going turn one ugly constants file start put every configuration key 'd rather pull specialized config related classes start exporting part constants class
think ok assume section null
like hashcode think ok assume section null
like sectionnames think export name lower case caller sees consistent case returned set
style-nit use default constructor supplied compiler visible public class private effectively visible
export lower case section names caller consistent case examine returned set iirc e.section null blank line comment line appear returned set please add e.section null guard around addition
yikes thanks fixing
use repository fs instance case detected cygwin application wants msysgit behavior user home directory amazon s3 property files stored match home directory ssh configuration stored determined fs type
lets say detect cygwin fs type cygpath appeared user path user configured smartgit *not* use cygwin jgit tries use ssh connection going asking user *cygwin* home directory .ssh/config ssh keys makes sense smartgit configured *not* use cygwin using cygwin based settings needs using fs instance repository called using
using repository fs type user .ssh/config come git system using repository one auto-detected
style-nit trailing whitespace error
also pass fs instance objectdirectory
also pass fs instance objectdirectory
yea go ahead make fs parameter constructor gitindex refdirectory
getfs also happy including public api repository actually want start removing filesystem based assumptions class probably choice matter though see application would want available later construct filetreeiterator needs fs instance
using repository fs type user .ssh/known_hosts come git system using repository one auto-detected
using repository fs type user .ssh/id_rsa come git system using repository one auto-detected
actually another option available us default implementation userhomeimpl pretty cheap simply remove method inline userhome avoid userhome instance member altogether threading problems go away fs_win32_cygwin introduce private static inner class static final field containing user home override public file userhome return userhome.home private static class userhome static final file home userhomeimpl let class initialization take care caching memory synchronization us paying volatile read penalty access though point volatile read far cheaper constructing privilegedaction needed pass accesscontroller.doprivileged get user.home system property
safe java memory model thread read userhome member see java.io.file object reference unable see fields assigned within object could seeing garbage prior resident location could seeing nuls allocator clearing region initialization way ensure writes particular point visible thus object question internally consistent perspective reader travel synchronization barrier barriers exist synchronized block writing/reading volatile memory model requires writes carried within thread prior write volatile must visible another thread reads volatile first writes carried releasing monitor object must visible another thread acquires monitor anything else playing fire either delete userhome property compute fly every time requested use volatile given cygwin userhome computed via fork+exec pretty expensive could permit default implementation compute demand every time still cache result cygwin case brings us right back discussion needing mark field volatile
thread-safe prior implementation relying class initialization ensure thread-safe initialization userhome property since 've moved instance member class need modify method use sort thread-safe construct might sufficient mark userhome volatile java.io.file immutable initializing variable relatively inexpensive concurrently multiple threads event one thread needs value time yet prepared issue
s/am/an/
necessarily blob
necessarily blob
spelled gerrit code review
clean necessary jgit required c hook script presented *original* buffer user cleaned commit creation routine need drop lines leading etc within jgit happen higher level ui ui invokes changeidutil class simply need happen
think would prefer treeid come first comes first commit formatting change-id string computation
temporary file necessary
would bother temporary sha1 variable also b.length size number bytes available hashing name contains multi-byte character example utf-8 encoding wo consider everything hash
would prefer running parser revcommit uses parsing footer lines unfortunately code part revcommit would need pull utility class find way construct revcommit buffered message reuse parser even search backwards end string find paragraph break denotes footer insert point 're mostly replicating parsing code particular one rules shell hook try insert change-id line bug line one present lines hard simple regex replaceall like insert item string
return w.computeobjectsha1 might able fit entire method call one line wo need wrap onto next line still long consider raw bin instead bytes encoded form commit text
canonical hook gerrit code review case-insensitive match bug|issue
ca factor ^ start end pattern canonical hook also considers lines starting space footer often continuation lines prior line
case insensitive form honored gerrit code review commit-msg hook comes use case insensitive match
match firstpattern -1. want find *last* bug issue line insert change-id immediately going insert first correct output would bug 42 bug 53 bug 59 change-id signed-off-by shawn two loops canonical hook loop backwards find end footers loop forwards find change-id insertion point given couple indexes walking backwards forwards data inexpensive
code would lot easier follow initialize lastpattern lines.lenght start rather -1
still following commit-msg hook gerrit skip blank lines putting message back together put blank lines commit messages time like paragraphs like message would skip
skipping empty lines user message indexes lines chosen insertion point change-id copied as-is since split \n removed \n characters add back element
meant relicense test cases commit-msg hook test vector data google would prefer consistent set test data used validate conformance worry keeping aplv2 code
ugh relicense gerrit code review commitmsghooktest class aplv2 edl please see reuse test class altering executes hook logic otherwise retain input-output examples test tag copyright google 2009. http //android.git.kernel.org/ p=tools/gerrit.git a=blob f=gerrit-server/src/test/java/com/google/gerrit/server/tools/hooks/commitmsghooktest.java hb=head
updating jvm standard 1.6 unit tests
delta already applied earlier today update working copy
chose include ip log since actually using yet 're still waiting ip team approve use start code
` git commit ` first updates eclipse-iplog program relies committed version file version working directory
pretty sure allow whitespace front first column yea headers blank lines
use redirect use -o option write file also ip team wants see actual project version number log even yet tagged instead want run eclipse-iplog -- version=0.8.0 -o jgit-0.8.0.xml head
fwiw getleaf necessary getobjectid works symbolic references traversing leaf get value
really internal exception easy user cause modify commit file branch fast-forwarding also modified happens often users want know complete list offending files figure next exception mergeresult need export part public api applications alert user working directory contains uncommitted changes conflict merge trying
please also set oldobjectid refupdate read earlier continue update branch modified concurrent process
good point ref class reusable pair string objectid think could use objectidref.loose rather source get everything need might actually preferred 'll want short-form branch names master instead refs/heads/master probably teach ref create stateless function repository somewhat useless thinking enough wrote comments yesterday slapped together source class sorry
true break api compatibility would prefer sane notion front much jgit internal library api sort slapped together goes true lot c command line switches forth better spend minutes try learn experiences
realize basic start since public api 'd like think final api look like bit merges accept sha-1 technically need take anyobjectid input ref nicer might able format better message ` git pull ` takes advantage uriish produce even useful message merges also accept one sha-1 consider octopus strategy maybe want part api public mergecommand include anyobjectid commit return include commit commit.abbrev public mergecommand include ref ref return include ref.getobjectid ref.getname public mergecommand include anyobjectid commit string name sources.add new source commit name return private static class source final objectid commit final string name format merge message try take advantage additional name member describe source merge callers include one commit single merge operation
problem hashmap preserve order caller passed commits us maintain order order 'll attempt octopus merge order write parents commit keep using map string objectid use linkedhashmap ensure insertion order preserved switch list ref
probably also abort commits empty need least one thing merge besides head
really undefined one commit instead look strategy enforce sanity commits member e.g add member mergestrategy help us decide number commits reasonable already-up-to-date fast-forward-only strategies need accept 1 commit reject functioning 1 commit given see trying collapse multiple commits reachable together loop probably pre-processing step beginning function matter strategy configured even octopus merge make sense create 8-way merge really 2-way 6 commits already reachable gerrit code review logic 1 ignore can_merge stuff support code review workflow ensure commit approved bulk sorting logic computing commits merged removing incoming caller asked us merge already reachable 1 https //android.git.kernel.org/ p=tools/gerrit.git a=blob f=gerrit-server/src/main/java/com/google/gerrit/server/git/mergesorter.java hb=head know maybe right enforce commits.size 1 start method maybe also include assert empty simplify code around assertion commits.size 1 useful aspects merge code working come back revisit sort heads determine up-to-date octopus case
needs commit.copy anyobjectid mutableobjectid change after-the-fact copy returns objectid mutated input already immutable objectid copy returns object
unrelated reformatting file looks like revert change
style-nit spaces around operators applies also number spots
style-nit unnecessary parens ever place need parens right assignment one variable another
s/pathes/paths/
inflate tricky done yet need call otherwise may fully populate output buffer verify zlib crc trailer may corrupt data inflated something like int dstoff 0 int n inf.inflate dstbuf dstoff dstbuf.length dstoff dstoff += n inf.finished return dstbuf else inf.needsinput position += inf.setinput bytes position bytes.length position else n 0 throw new dataformatexception
throw dataformatexception runtimeexception
use try-with-resources ensure closed inflater released
ioexception try catch exception
unfortunately line length convention 80 columns revert line edits line wrapping change
use messageformat jgittext
also ptr buf.length buf ptr '\n' arrayindexoutofboundsexception nextlf walks end array malformed enough throwing something like patchapplyexception
jgittext general messages exceptions go constants like jgittext
necessary initialize inflated
please trim trailing whitespace end line lines
nit unnecessary blank line end method
problem sectionparser instance used cache key map invocation going make new entry cache caching probably need hold sectionparser instance repository implement interface equals/hashcode methods producing new cache entry every call
yes cache leaks entry hash table hashentry chain handle child ref node actual byte nulled dead.value null line 405. byte immediately reclaimed java gc previously bother clean hash table chain clock eviction assumed would touch hash table chains soon enough accesses would eventually clean orphaned nodes buckets
ca take regionlock hold clocklock elsewhere take regionlock clocklock eventually lead deadlock
would fail 2nd node bucket entry advanced pointing root bucket need use original value got table.get slot start loop even 5th node chain
removing blocks associated pack bad idea system calls remove dsfpackfile pretty good notion pack file longer part repository memory sitting useless bother optimization cache eviction algorithm eventually kill blocks anyway accessed pressure cache evict at/under target size pressure spend cpu time evict dead pack blocks cache target size memory promised rest system hands part heap
hard-code port instead let assigned os pick port after-the-fact like non-ssl connection
please add note x.509 certificates accepted
huge base64 thinks resource files test suite loaded files source directory rather writing temporary files test needing delete
change combined prior commit handles client side changes
left todo
consider adding windowcache.reconfigure call main within pgm package could add new command line flag main called -- config-file points user configuration file callers set settings ~/.jgitconfig example call ` jgit -- config-file= home/.jgitconfig log ` could also consider standardizing ~/.jgitconfig file loaded main present fwiw reason main support config file way config file also specify memory settings jvm setting large value core.packedgitlimit without also increasing heap may cause performance problems application entirely problem need solve added reconfigure call
style-nit trailing whitespace
would prefer put windowcacheconfig fromconfig method lets also add fromsystemproperties code becomes reconfigure new windowcacheconfig .fromsystemproperties
named system properties org.eclipse.jgit.config.core.streamfilethreshold write conversion code fromsystemproperties config cfg new config loop system properties name starts org.eclipse.jgit.config split remainder first dot set string value fromconfig cfg way user set property using -dorg.eclipse.jgit.config.section.name=value flag syntax fwiw special version config parses json converts config object configure jgit via json works nicely thinking sort idea construct config properties collection
use config approach suggest users say -dorg.eclipse.jgit.config.core.streamfilethreshold=200m rather 200000000. cleaner
queue discard ancestors looks like walks commits queue next method skip commit reachability cardinality start size
better making special subclass revwalk overrides createcommit provide subclass revcommit carries bitset member would use less memory make whole thing slightly less awkward caller work try register commoncommitlimitedrevqueue existing revwalk created mean convert existing graph held existing revwalk perform operation application author would need decide type revwalk create type graph want maintain memory
startcommits could contain commit since list maybe want convert set first ensure unique handle case specially committoreachability map already contains commit use revcommit subclass approach test bitset field non-null refuse reassign instead setting corresponding start bit
time dealing revflag object may worthwhile use normal revflag set methods instead hand-coded bitmasking
set always empty
purpose interface/method bit unclear want
given much file moved opensshconfigfile also copy copyright notice new home
really thread safe caller might see wrong cache instance see partially initialized one either cache must volatile need synchronization around looking cache field running updatecache method replace contents new map used work everything synchronized together inside single refresh method
either mark lastmodified volatile make method synchronized ensure caller sees correct version lastmodified value last read call
3 allow default size 16
git pull weird say ` git pull url foo refs/heads/foo master ` master merged foo stored refs/heads/foo see accounting f'king odd behavior change probably
seems wrong asking local repository reference exists remote side ignoring exist locally
return setrefspecs arrays.aslist specs much shorter
server emitting content-type application/x-git-upload-pack-advertisement charset= server wrong
like idea checking content type startswith still fuzzy check server still wrong mime type take charset character encoding branch names uhm unspecified git c git smart check slurping entire response body buffer reading start buffer changed code thing would comfortable idea dropping content type check altogether ignoring like c git pretty stupid check content type better way check mime type something like string acttype c.getcontenttype acttype null return false int acttype.indexof 0 acttype acttype.substring 0 return exptype.equals acttype
s/an exceptions/an exception/
strictly atomic created test rename gets replaced think name method easy assume always use renames
indexof '/ would sufficient
agree protect evil ref protecting local repository writing evil ref blocking protocol seeing remote sent evil ref wrong place checking ref name valid throwing
common method mean always right place fix common bug risk writing bad name local repository local repository name ref comes lot sources map supplied remote peer could come bad reference specification supplied .git/config command line catching refusing inside reference writing code path relying little setter method make sure data going local disk safe
head servers advertise check x/head valid right always causes head fail convinced right place make change method told remote side gave us nothing nothing less filtering valid apply local repository looking collection parsed wire place barf would parsing wire format parse wire data 2 places abort objectid valid sha-1 hex could also abort reference name strictly valid reference name prefer lenient read remote peer strict apply local repository
would even new interface would define new methods objectdatabase return empty collections default indicating database support grafts replace storage implementors override provide support
grafts alternates processed git-core
map keys anyobjectid would permit mutableobjectid used map key confuses hell map value modified use instead objectidsubclassmap objectreplacement objectreplacement defined something like class objectreplacement extends objectidsubclassmap.entry private final objectid replacementid public objectid replacement return replacementid cost lower single replacement full map.entry closer objectid pair
objectid mapping mutable
nit trailing space javadoc please use rebase -- whitespace=fix avoid enable removing trailing space eclipse
ouch really need burn reserved bit flag something uncommon
variant constructor disable grafts another enables result lot confusion current code code uses constructor reuse existing reader different related objects know problem graft data available context still scary behavior revwalk differs based type object used create javadoc reflect
style-nit put one line /** return grafts file info/grafts */
style-nit trailing whitespace
packwriter disable iirc pack-objects c git honor grafts creates pack file
ps4 better ps7
silly grafts really impact revwalk/objectwalk replace impacts objectreader return since provides different content would add new methods revwalk/objectwalk disable use grafts caller want grafts disable walker begin walking walker grafts enabled could implement grafts quickly loading graft line new revcommit structure parsed flag set defines parent list manually graft file still need fault commit get tree fill revtree line guess small price pay graft general many grafts relatively cheap perform grafts enabled replace flag objectreader whether specific reader instance honors refs/replace would default true callers disable objectreader start operation wants real data rather replaced data replace enabled objectreader would need see requested objectid one things replaced redirect content fast operation objectidsubclassmap
grafts alternates apply
objectid mapping mutable
objectid immutable
grafts volatile use volatile safe pattern static state final filesnapshot snapshot final map grafts private volatile state state state state s.isoutdated loadgrafts state return s.grafts
number grafts low always thought would implement grafts revwalk revwalk graft enable method lookup revcommits named keys graft file assign parents outright looked revcommit parents way traversal incurring hit look see individual commit part grafts file already computed actually part reason parents null test parsecanonical want replace parents already computed us even currently different real content loaded
need perform working tree diff quickly determine new commit empty comparing tree new commit tree ancestor equal new commit merge new commit parents new commit tree matches empty tree sha-1 say empty commit happen
also consider support sslcapath
stupid question need http.sslcert
getting certpassword http.sslkey null user using client certificates also c git suggests user set http.sslcertpasswordprotected key encrypted password set c git prompt later key required password needed way tell key encrypted avoid prompting variable unset key stored encrypted
todo
may true want trust hosts inside company think sane default think c git ties sslverify sslverify false hostname verification performed either sslverify true certificate hostname verification done
style-nit prefer idiom fileinputstream fis new fileinputstream path try finally fis.close
style-nit please preserve original chain exceptions ioexception ioe new ioexception e.getmessage ioe.initcause e throw ioe
style-nit see file handling
style-nit see keeping exception chain
please quantify improvement revwalk critical part jgit used lot important algorithms making change like prefer see a/b performance results workloads matter e.g uploadpack/packwriter log please explain improvement necessary trying boost packwriter performance found helps already bitmap support pending packwriter like 445x faster way simple soft reference based map get sort improvement
soft references always work windowcache uses softreference hold blocks pack files java gc tends kill 50 soft references full heap gc performs may help practice found using strong references like dfsblockcache better caching unfortunately yet back-ported windowcache using strong references steals heap space application jgit embedded big applications like eclipse jgit trying run inside may memory give jgit dedicated slice heap big applications like gerrit git servers using strong references works better soft references somewhat skeptical adding yet another soft reference cache best thing
avoided allocating new objectid every parse operation map support anyobjectid lookup behavior
actually trying avoiding parsing commit headers thread git mailing list actually going productive direction http //thread.gmane.org/gmane.comp.version-control.git/210419/focus=212329
unnecessary objectloader implementation getcachedbytes work anything streamfilethreshold configured objectreader implementation storage.file case derived windowcacheconfig defaults new static default added storage.dfs derived readeroptions defaults new static default added
think drop parameter mib constant entire commit
would prefer deprecate see
really 50 mib different animal stream file threshold caps big file packer attempt perform delta compression git determined certain sizes using delta compression packing significant negative performance impact done default 50 mib rough estimate reasonable delta compress even application sets core.streamfilethreshold 128m 256m packer create deltas objects 50m default hurts readers badly might lower streamfilethresholds make sense
maybe method set binaryfilethreshold match coreconfig associated repository
use classname.foo references within class instead rename parameter conflict member name
access int synchronized ensure threads see change setter invoked
creating process wide config object system config user config repository config inherit work gerrit jgit based code google set process wide config software config objects inherit lets us set process wide default something like core.streamfilethreshold still override user repository level
iirc import static import classes top import list
public methods need javadoc since tags
killing going force next release jgit 4.0
nonadvertised
client
smaller less api breaking change would leave alone add accessor returns capabilities collection caller demand callers keep current code advertise capabilities use new getter copy set back refadvertiser
nonadvertised
block bit problem bidirectionalpipe false smart http capability list built ca verify
oy going confusing semantics get returns getstringlist returns null y=\n config line get wtf-o-meter ca say sane wonder want consider replacing getstringlist never return null inside array elements
also include deprecated
space
problematic large pack file e.g pushing 1.2 gib repository s3 try allocate 1.2 gib single byte array right method tried otherwise avoid using temporarybuffer holds data disk streams network since local disk able read data back using temporarybuffer input stream
headers
3 lines sb.length 0 sb.setlength sb.length 1
space catch
use java 7 return s.getbyte java.nio.charset.standardcharsets.utf_8 wo throw
size counts notes non-notes e.g spurious .gitignore file notes tree still write produce non-empty tree also check nonnotes see null
incorrect insert pack may contain multiple objects essential works performance gerrit running dfs system
insert receive packs dfs slightly violate pack file format setting invalid object count header pack need look dfspackdescription get valid object count out-of-band issue insert store header total number objects known always produce header count 1. issue receive store header know many base objects append make thin-pack non-thin appending copies delta bases support deltas appear pack always store count original count thin-pack sent pushing client dfs actually ignores count read time error anything except packparser fsck tool insert receive packs thus far ever accessed random access supported idx file count pack header relevant normal git gets around cases going back overwriting header dfs assume ca overwrite prior part pack file option dfs normally ignores object count pack header relies object count dfspackdescription google implementation dfspackdescription stores accurate count side area along list packs part repository
dfspackdescription field store objectcount https //eclipse.googlesource.com/jgit/jgit/+/master/org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/dfs/dfspackdescription.java 213 think underdocumented implementation persist metadata somewhere somewhat loath define standard format store list packs metadata using format would require changing internal format example might make properties storage less useful however could define default format jgit one implementors dfs use need
incorrect change idx v1 format offset 32 bit unsigned integer supporting pack files 4 gib size decodeuint32 necessary get correct offset
also incorrect change pack index v2 level one offset 32 bit unsigned integer level two offset 64 bit unsigned
crc used actually treated 32 bit unsigned value storing signed long java e.g use dfspackfile crc1.getvalue expectedcrc crc1 java.util.zip.crc32 getvalue method returns long crc actually unsigned 32 bit value
think little confused problem trying fix client sent service parameter smart-http client supposed accept error message like
/info/refs accessed get never body
use try-finally
fix bug think int v usecnt.intvalue v 0 break else usecnt.compareandset v v 1 v 1 doclose break wo go negative like hits zero going close repository closing someone else better call incrementopen
fairly certain typo actually micro optimization benchmarked better
actually already code interrupttimer timer new interrupttimer fs.readpipe try timeoutinputstream new timeoutinputstream p.getinputstream timer in.settimeout 10000 bufferedreader lineread new bufferedreader encoding finally timer.terminate timeout triggers lineread.readline throw interruptedioexception
style-nit reason hoist outside try block please leave initialized runtime.getruntime .exec invocation
read exception considered looking result string
probably go text properties file
.tostring necessary + call
really local ref name remote ref tracking ref call things refs/remotes/* tracking refs disambiguate bit local refs like refs/heads/foo remote server refs/heads/master
assume refs/remotes/origin thing applies use remoteconfig fetch refspecs contains
assume refs/remotes/origin/ thing applies need translation using remoteconfig fetch refspecs declared within
name confusingly wrong unlikely copying remote refs/heads/master refs/heads/master method called local ref pubsub
yes please move translation file
agree dave false
think want forceupdate
need perform deletes create/update consider case remote deleting refs/heads/foo later creating refs/heads/foo/bar clear gone refs/pubsub/origin/heads/foo first ca create refs/pubsub/origin/foo/bar foo file directory
refdb
somewhat costly given amount refs need better grabbing local references passing map around
think pointless omitted protocol
use new string last pack means space valid restart token instead say resume token last-pack pack keep protocol readable often include lf end strings written writestring think resume restart better command name fast-restart probably made mistake calling fast restart
like abbreviation repo repository
could also call want
stop
mean send ref name server knows ref
ack forgot problem repository android want refs/heads/* want refs/tags/* 01234 refs/heads/master 56789 refs/heads/branch1 flush-pkt repository kernel want refs/heads/master flush-pkt done
sent part earlier block maybe want ref_name sha1\n client already ref want ref_name\n client
reconnect .equals line
maybe token includes server ip port number current server knows terminate sends session data another server cluster wants client get new token names new server sends updated token client client use restarts connection broken server would rather build flexibility protocol assume someone would never ever want change token
maybe instead ack\n would integrate restart token code loop way server rotate token time wants making new token sending wire maybe giving client short grace period use either token old token invalid new one must used resume successfully
flush packet heartbeat continue like changing restart token think server able tell ideal heartbeat window let server decide often send empty heartbeat messages clients clients set timeouts around server current heartbeat period
line.substring update .length
line.substring sequence .length
need flush packet
top loop heartbeat pings still trigger check
use basereceivepack avoid status reporting stuff exists receivepack
call string sequence loop would prefer similar maybe call last-sequence
looks weird starting non-resumed connection 0000 move restart block
restart-token sufficient think need say change- prefix
seems odd start transaction 0000
would prefer done ends repository name also bit odd maybe rewrite .access foo/bar .access foo/thing .access foo/thatotherthing 0000 clear server telling access repositories later let us know authentication needed also ugly flush every stuttering going
err existing convention within git protocols
handled loop server already change token change token token token loop
handled loop think reasonable hoist thus also allow server modify heartbeat-interval
get reconnect err basically get nothing make changes suggest server send one ack reconnect err message explaining failure single message reply request need end packet get one 3. ack fine return true loop starts running receive server reconnect return false retry whole thing err exception obvious
thanks await merge conflict
ack far simplistic case really need fix 'll work try figure pack cruft deciding keep as-is
yes base==otp trip consider two packs repository newest delta b base oldest base b delta arise pack oldest already repository lets say newer object b delta client pushes newest us thin pack ref_delta b. append b complete thin pack reuse search packwriter going schedule cycle a- b- trying use two delta forms save pack space cycle gets broken output graph enumeration says comes first 'll try write delta realize need base b try write b b needs try write point writer realizes cycle writes non-delta form pack however cycle breaking done late writing time need guard fortunately reference equality also means git object equality objects come single objectidownermap keyed sha-1 otp base cycle unfortunately right missed case different cycle b c b traversing chain never terminate
object enters delta window chainlength value longest distance object furthest child/leaf node uses object base directly indirectly object enters delta window switches deltadepth becomes distance object non-delta base used inflate content object delta depth 0. object delta compressed window base depth + 1
may true wanted avoid calling setchainlength unless getchainlength returned 0. think common case objects 0 chain length wanted avoid bit shifting logic inside setchainlength clear field already clear test without calling getchainlength twice also bit shifting means need declare new local variable scope want either lifespan short
think second part conditional otp.getdeltabase null causes corruption delta chain cycle a- b- neither b gets condition neither runs writeobjectanddeltachildren neither appears pack output stream means pack contain number objects declared header causing indexpack abort early eof error index stores bunch objects offset=0 trying read back always fails first byte pack p appears object type code 5 currently invalid code
oy test covering delta base pack yikes yes absolutely need add test
compile error org.eclipse.jgit/src/org/eclipse/jgit/transport/signedpushconfig.java 83,17 find symbol symbol variable required location class org.eclipse.jgit.transport.signedpushconfig
sadly best error reporting client abort refs go code path kind similar falling reporting unpack ok followed rejecting every ref
done
obviously missing javadoc
really hate pure-java case 'll tad slower make file.list result conform api wrapping results however let us avoid number stat calls determine file type within filetreeiterator would really make native library widely deployed
done
document .. omitted returned listing
done
sure potential errno cases covered may translating errors exceptions generic jgit_throwerrno utility function
probably try symlink isposix
tests assume underlying platform actually supports d_type field every filesystem even operating system libc example linux ext2/3/4 support fat resulting type_unknown coming back instead proper types
think extend test like 120 entries directory even power 2 temporary array 120 would exercise array resized correctly loop end large would also help test part jni sure using local reference table correctly suspect native tier would likely crash jvm fail sort exception misusing jni actually enough entries test
done
needs abstracted somehow every c library exports d_type need use dt_unknown code path return 0
've decided leave table as-is document java dirent class values changed since public constants already avoid changing prevent breaking binary compatibility java code using dirent class
could load constants java fields store struct dirent way native code closely coupled dirent class definition result slower machine code returning constants anymore simple function
done
style-nit forgot clean trailing whitespace
malloc ugly would nice could stack allocate average buffer platform avoid malloc/free common cases may turn wasted stack space guess wrong
somewhat hideous double array later contract back exact size necessary makes wonder returning immutable list dirent might better need contract result array back correct size unfortunately walking list dirent would require allocating iterator dirent object allocation either way
c libraries darwin aka mac os x e- d_namlen tell us length without performing strlen faster available everywhere notably missing linux
think missing deletelocalref env e call really know
please make unix file
please make unix file
fix trailing whitespace
might need ifdef around lines every platform nsec available supported need fill 0
probably fine enoent enotdir likely failures failures may wish make obvious java code make easily detectable relying checking translated platform error string
also special case eacces able access part directory path reasonable failure expect happen translate useful error message end user errors like efault eio eloop enametoolong seem like things say never happen tossing generic lstatexception probably fine
api change public api drop support java 6. years away
require cast long casting jint cast 32 bit value truncate upper bits leave low 32. elems 9 jint finfo.st_size
expression wrong want upper 32 bits st_size 4 sizeof finfo.st_size 8 elems 10 jint finfo.st_size 32 else elems 10 0
going suck need test implementations native implementation load abort test failure use system property disable native implementation test developers trying build jgit ca run native implementation platform would need define system property maven command line bypass something like public void test_lstat_native throws exception boolean.valueof org.eclipse.jgit.fs.native return fsaccess native new fsaccessnative somehow assert native native jni loaded do_lstat native public void test_lstat_java throws exception do_lstat new fsaccessjava private void do_lstat fsaccess imp throws exception test method
think true true file created never written e.g creat 2 system call think legal close 2 update mtime file opened writing open call set ctime think rely assumption unit test however able rely mtime ctime
depends operating system win32 probably setting 0 except mode sane concept device inode great way say group user file since use acls access control system however could expose package-only visible native method tells *type* jni support loaded e.g isposix method unit test probe making assertions way win32 assert fact 0
haha love defined text fit particular answer
style-nit unnecessary blank line
long
probably need slap fix 2038 warning update bug jgit 2038 issues see revcommit example warning put dircacheentry probably also needs warning p_mtime slot add later
going overflow computed int also precedence + widely known prefer wrap make order operations clear everyone instead size long rawlstat 9 + long rawlstat 10 32 fwiw given almost everywhere else use big endian ordering weird see high 32 bits size occur later array low 32 bits
drop incubation text
drop incubation text
style-nit trailing whitespace
would reword say soon java 7 minimum supported platform
localize
drop static ctor
package visible
wonder get away getpath instead getabsolutepath application given relative path java.io.file object relative jvm current working directory changed easily passed native layer ca advantage would applications might able avoid vfs traversal root traversal back every file lstat working directory c git actually makes performance difference linux even though vfs linux incredibly fast
localize string
still sure need absolute path go native layer understand jre ca change current working directory ok use relative path returned getpath avoids unnecessary vfs traversals systems whatever optimize later worth least going ensure accurate path passed native code
soon java 7 minimum supported platform
use java.io.file wrapper unpack string getabsolutepath
fwiw stuff go static initializer class also use interface bridge two together nativefsaccess extend abstract fsaccess class implement abstract virtual methods defined way runtime dispatching abstract method rather reflection
store exceptions thrown static member make accessible guis help user resolve native library load failure private static throwable nativeloaderror public static throwable getnativeimplementationloadexception return nativeloaderror resolves problem logging system.out.println load
make abstract member return true fsaccessnative false fsaccessjava
please document lstat returns data symbolic link target link
minor style-nit prefer one line /** instance fsaccess */
style-nit braces necessary
style-nit trailing space
think point would fair replace name
missing copyright header
truncate length lstatnative api needs supply length 64 bit value means may need use int 11 split 64 bit value two segments put back together java make members lstat object package accessible populate directly inside jni code say never written jni code must possible freeze object location memory populate fields via sort set int set long jni operation
behavior different native enoent case file exist fsaccessjava returning apparently valid lstat mode regular_file -1 lastmodified file length fsaccessnative think throwing nosuchfileexception java code needs trap long sz file.length sz 0 throw new nosuchfileexeption file return new lstat file.lastmodified mode sz
drop incubation
soon java 7 minimum supported platform
translate
write object punt make caller
oversight thank catching ok changing default false drop commit altogether series
know found random commit mapreduce tonight insufficient context answer think right handle bad encoding differently
think fix lot subtle findsymrefs added capability symref=head refs/heads/master client see head head packed advertisement means adv.isempty branch irrelevant anyway db.resolve head checks find sha-1 behind head repository might non-empty hiding branches dangling head check fails lose capabilities line clients using option_allow_tip_sha1_in_want repository hiding refs default refs/changes/ still needs see capabilities know option_allow_tip_sha1_in_want possible may need research imho possible git client broken server hiding refs default shrink advertisement wants clients use option_allow_tip_sha1_in_want clients cloning repository also get error message
really want put symlink emulation msysgit fileaccessjava class
drop todo yes think default code git windows treat symlinks text files holding link target hard though index code needs supply mode filesystem scan know symlink -\
drop todo
build takes 1 minute 47 seconds mine takes 1 hour 21 minutes 6 seconds 128 milliseconds
mean delta.getflags iresourcedelta.open 0 understand javadoc getflags correctly would want verify open bit set
given deeply nested wonder better way open method say delta null delta.getkind iresourcedelta.changed delta.getflags iresourcedelta.open 0 return removes two levels indentation though negated logic may seem strange readers
go activator.logerror recorded inside workbench error log view
ok make public think require javadoc public members
dfsrefupdate designed ensure calls made method overriding type necessary maybe better option make dfsrefupdate non-final public
message class one executing command wants say funnyrefname message one correct old version
need keep translation walkpushconnection
jschconfigsessionfactory also throw
trailing space
jschconfigsessionfactory also throw authentication fails
trailing space
service think mean git-upload-pack git-receive-pack argument smart http protocol try explain little
style-nit trailing whitespace
please correct copyright notice
s/seems// default
usually return command type possible chain calls
walk released done use try/finally
author much ` git describe ` c optimal algorithm better approach allocate revflag revwalk loop tag parse tag reference commit commit add revflag start starting point walk backwards history revwalk.next returns commit revflag found candidate mark history behind tag uninteresting keep going revwalk stops multiple candidates found think use one largest distance see may forgetting isoteric rules related picking release tag maint branch master branch -rc tag number commits back version number wise recent think use largest distance commit tag iirc managed entire thing 1 reversion traversal c code commits extra walked finish counting also mention commit message tendency favor annotated tags lightweight ones
print stack traces wrapped thrown caller
print stack traces wrapped thrown caller
count appear tag exactly found
s/revcommit/revcommit/
think need setrevsort revsort.topo get right count graphs
created revwalk call reuse also fwiw release revwalk done
reset necessary unless reusing revwalk
default
default
style-nit put curly braces around single line blocks
return
updating year copyright statement add code wrong
cgit accept refs/heads/foo-* refs/heads/* rename references strip foo- prefix wondering need test endswith /* contains /*/ contains correct
42
think simplify code little using static helper function private static string checkvalidref string ref isvalid ref throw return ref places use replaced field assignment setter use field assignment wrap right hand side checkvalidref
would test length case first fails way startswith endswith correct
use else
line wrapping ugly think shorter variable names might actually make code easier read avoid breaking line
think write method int str.indexof '* 1 return true str.indexof '* + 1 return false str.charat 1 '/ return false str.length 1 return true return str.charat + 1 '/ although version fail check case check either
stream eof point put would work
nak much work necessary underlying inserters know get content wrote local filesystem one loose object code path local filesystem return normal windowcursor handle objectreader everything happy
map knows every object put current pack named packdsc ca look object map present use offset load object pack stream
tricky part return db.writefile support read back file packstream need hold onto dfsoutputstream backend needs also support read-back insert type packs receive type packs trivial fix may duplicate small amount code read back whole object pack either dfspackfile packparser relatively simple code already stored object deflated store whole form see beginobject delta chains worry needing unfold memory wise use less memory duplicating content might cost bit cpu however data needs inflated
mean never see api warnings type
none filetreeiterator implementable workingtreeiterator attributes harder gitignore attributes also need pay attention canonicaltreeparser side house checkout checkout need use gitattributes file repository determine crlf status file create update working tree given maybe implement attribute support using abstracttreeiterator wraps another abstracttreeiterator peek underlying abstracttreeiterator see gitattributes present would setup attributes represent current attributes peeking expensive .gitattributes likely occur early sorted list actually likely exist probably need examine first path wrapped iterator prove .gitattributes thus need attribute support .gitattributes load back 1 undo reasonably cheap checkout client code needs care attributes particular location e.g working tree repository wrap iterator attributeiterator type later query attributes necessary treewalk manages iterators creating new iterator dives tree discards iterator exits need manage stack attribute collections nested subtree automatically fall scope treewalk throws away attributeiterator also opens door potential optimization attributes object attributeiterator might want sort entries path name merge join underlying iterator names next back reducing amount work need perform particular attribute query caller likewise might able told caller care text crlf attributes discard rules relevant
rather large refactoring explained value repository interface like already
nit added trailing whitespace inside javadoc blocks
missing edl header
init work mapbitmap start walking million bits million less compare jump needed done per bitmap
would build entire array likely everything old index mapped new one given prevtonewmapping yet created mapbitmap build entire array allocate walk every object old index find position new one store array actually ca merge two indexes open iterators source index go objects objectid order iterators equal lookup two positions store array think saves log n lookup inside loop reducing complexity mapping bitset one index becomes tight brute force array indexing loop
sort work favor commits already bitmaps especially back history
s/withi/within/
p.now reading clock think intent read clock start entire iteration use single timestamp subdirectories updating clock within subdirectory treewalk recurses updating pop back evaluate another file parent directory somewhat inconsistent timestamp behavior
style-nit line wrapping ugly
set fields null jvm automatically
quote string need 0 way messageformat treats escape preventing variable 0 replaced
s/allows us /allows us
used unless parseablesimpledateformat values fail maybe instead building loop try parse fail build alternatives failed know going throw
parse_simple ca return null anymore useless try return parse_simple datestr f make code shorter
allformats.append .append f.formatstr avoid using else block
ca coreconfig admit read code yet setting path encoding option one location e.g coreconfig everyone try use whenever possible coreconfig heavy contexts always use treeoptions object put .lib package rather treewalk heavy mean hard create one-off configuration connected specific repository
would like see least standardized core section git configuration msysgit use key
stupid question working tree different encoding repository *nix system thinks correct encoding utf-8 repository maintainer chosen use iso-8859-1 set path encoding within repository iso-8859-1 working tree utf-8 jgit perform automatic translation two think works magically *sigh* working tree code use string file objects point working tree java handle encoding/decoding filesystem within jgit need encode/decode string/file in-repository encoding understanding right
instead try cache treeoptions object inside config using sectionparser api see coreconfig example way linear search variables every time try acquire configuration instead trigger linear search variable change cached objects invalidated
nit private constructor
yea use treeoptions please define method release wish could define reasonable default implementation possible class reference back repository objectdatabase
wow really like idea path encoding objectreader would instead prefer exposing repository configuration configuration source may simplify contexts get coreconfig something similar objectreader
usually write asserts
ouch realize going need mock much jgit objects object directory tree iterator finally understand want mock 4g test much code mocked much harder sure test actually testing enough make worth carrying tree
git mime type used character encoding specified server wrong sending charset git protocol documentation states mime type application/x-git-upload-pack-advertisement specify character set references undefined character set
dom't expect fix change worth os x support case sensitive version hfs+ common possible disk image
enabled top level remove individual modules git grep maven-source-plugin see mean
disagree reason change any_diff raw difference two trees even core.filemode true git-core performing ` git diff b ` b commits tree objects compares file modes reports file mode differences any_diff supporting particular usage real working tree differences may need different implementation treefilter support compare logic need
trailing space
typo specific
think actually want deprecate see commit message comments
perhaps reasonable fix whole buffer long method torn
yup agree christian need new tag object lightweight annotated tag data return api package
fyi merge conflict markers stuck
externalize string translation
refdirectoryupdate ref objects imho caller passing string ref need refdirectoryupdate internally implementation detail handle lock packed-refs file
using repository object object whatever refdirectoryupdate might associated
init null move new revwalk call line 626 revwalk rw new revwalk getrepository try finally rw.release way coded right npe finally block revwalk constructor throws exception good
may cleaner avoid nesting using instead ref.issymbolic continue skip pack symbolic references
yes cached ref object needs know storage packed handled correctly future updates
test reference peeled already peeled object id thing tag still tag able say something like f.getstorage .ispacked f.ispeeled return f f.ispeeled f peel f f.getpeeledobjectid null return new objectidref.peeledtag else return new objectidref.peelednontag avoid entire use revwalk
unnecessary change
change going force jgit project bump version 2.0 next release public api signature change ca think way avoid without making much pain project making current receivecommits abstract base class wire protocol information also breaking change may prefer accept change break api force us 2.0 next release much work consumer application adjust linking one change aggregate though might get lot -\
taglist command clearly broken assumes objects refs/tags/ namespace annotated tags orion server repository uses lightweight non-annotated tags cast revtag object taglist command fails taglist command needs rewritten return revtag instead return new tag type supports annotated lightweight tags
want change parser nasty loop switch
almost made change thought better passphrase exactly password different passphrase probably connected key certificate file password connected account username stringtype generic item hold data true argument pass constructor tell ui use masked display handling input field e.g echo display dots instead characters would suggest also add new credentialitem.passphrase type similar password type require checking implementations ensure work new passphrase type reasonable way
update javadoc make clear returned dircache instance cached repository thus *not* thread-safe dircache thread-safe callers need unique copy dircache support concurrent access different threads directed lower level invocation dircache.read repo.getindexfile repo.getfs construct private copy structure
also use cached dircache locking dircache writing
think method warrants bit description return value /** get immutable up-to-date copy dircache p returned dircache cached shared callers used method obtain on-disk file modified since last request instance returned caller on-disk file changed new instance returned contains changes allows callers treat method return value stable snapshot
style-nit next readdircache method class like middle listener methods
field volatile bad read multiple times method instead dircache ro readonlydircache ro null ro.isoutdated ro new unmodifiabledircache getindexfile getfs readonlydircache ro return ro
sure best approach subclassing mutable type overriding mutator methods risky add new mutator method need remember also add subclassed unmodifiable type would prefer objectid created anyobjectid mutableobjectid pull majority code new abstract base class supports read-only operations make existing dircache/dircacheentry types extend define mutation methods define two new unmodifiable types also extend abstract base classes make unmodifiable variant different approach considered talking simply leave dircacheentry mutable make dircache least thread-safe concurrent updates taking majority state tossing new private inner state class held dircache volatile field readers grab state read state safely writers updating entry list via builder editor re-reading disk would create new state perform write volatile field publish mean readers dircache might observe dircacheentry later reading path dircache might get entirely different entry think ok using cached read-only dircache expecting current disk client application absolutely needs stable dircache could offer copy method dircache makes new dircache instance inner state reference future reads would impact new copy oh copy cheap creating new dircache pointing state array trust applications *not* edit dircacheentry obtained shared dircache already objectloaders getcachedbytes maybe dircacheentry high-level api trust applications mutate something
author tags
style-nit prefer public final class round
ca private
-- branch option comment makes sense context use string within project reference project set expected using given comment right
-- origin option comment makes sense context use string within project reference project set expected using given comment right also 're probably ok hardcode origin via default_remote_name constant users likely change imho project set files simplifying getting started project eclipse help also setting basic standard rules like name default remote project set created
think need urrishcomparator uriish implements hashcode equals contract correctly hashmap
projectsinrepository null condition two lines
default_branch branch field projectreference class course could case project set 2 projects repository pointing different branches imho invalid project set egit puglin reject
wonder also including two orbit based dependencies args4j jsch define project set egit/jgit
style-nit prefer single line javadoc possible /** depth commit graph */ int depth
please supply valid javadoc empty placeholders
use static import rather copying field
style-nit blank line fields javadoc try use single line javadoc possible
style-nit javadoc formatted properly lines block use lined column right javadoc use spaces indent description parameter
line still 80 characters please line wrap
style-nit parens around p.has boundary necessary npe boundary allocated depthrevwalk guess assume since depthrevwalk overrides markuninteresting nothing therefore assume uninteresting never set revcommit little skeptical using method determine boundary null
condition redundant ca enter block without true
instead exposing fields protected lets make different variant toobjectwalkwithsameobjects available public objectwalk toobjectwalkwithsameobjects return toobjectwalkwithsameobjects new objectwalk reader protected extends objectwalk toobjectwalkwithsameobjects dst revwalk rw dst rw.objects objects rw.freeflags freeflags return rw way depthrevwalk know copy get see private state fields revwalk
use static import rather copying field
style-nit prefer one-line javadoc possible /** */
style-nit use tabs indentation
style-nit blank line fields javadoc
flags allocated inside walker must part public api
flag part public api
reason override next expose pendingobjects duplicate code r.has boundary test way skip flag test commit
javadoc necessary package method
style-nit prefer write short javadoc one line /** number commits walk */
style-nit please use tabs indent spaces
please wrap lines longer 80 characters possible
still fairly certain want allow caller supply shallow flag public constructor needs built revwalk instance ensure flags allocated right
still fairly certain want allow caller supply shallow flag public constructor needs built revwalk instance ensure flags allocated right
javadoc connected code
style-nit put else line closing curly brace else
style-nit put else line closing curly brace else
really necessary use list line size file change could use line one less object allocation removes metric ton virtual method dispatching access
still incremental building everything one file give caller chance see block sufficient stop processing history
able stop lines covered file even file still history keep track many lines still need blame data update time run merge
hoist block loop executed exactly reason lasttext null test every iteration loop jump block code gets executed sure compiler could really smart still damn confusing human read looking kevin set lasttext null body loop make block reachable first iteration answer
part blobwalk null start loop understand comments patch set 18 files renamed infrequently always looking rename information every commit horrifically slow file suddenly disappears file gone either history file renamed worth rename detection gone
declare fields private leave package access way need synthetic accessor methods use since session class private fields already not-visible
point session object declared final inline fields blamegenerator avoid extra field lookup access
taking patch set starting point upload something soon
doubting need line class overkill memory usage going upload replacement proposal point
actually mean
line null created line object every line b side earlier createlines concluded line question bindex common files since occurs first edit two edits therefore line *must* exist b null
change method return true instead break return false fall loop next use return value updatepath know stop even look path tree
null file blaming empty return empty list mean empty list empty file null file exist
move block blob null updatepath commit blob getblob commit blob null marksessionbound return false
default histogramdiff
default default version
crashes objecttoolargeexception object streaming threshold
really expensive java creating object line revision line way scale blame 100,000 line source file need make code support use case java
still horrifically inadequate compared c implementation blame better nothing
hate idea dig back first version file order display *any* blame data project big enough take several minutes compute buildrevisions forget work need wanted incrementally
need followfilter always current path stored within use getpath obtain path use next commit
point linkedlist commits oldest- newest means digging blame data original file current version ignores point made earlier users ` git blame ` using look recent history need data going back root starting root working forwards head means user wait compute bunch stuff need right
would prefer set defaults constructor
final
replace byte contents loader.getcachedbytes integer.max_value
really correct lines belong commit know came *after* next iteration build execute accurately blame revision need carry earlier would build line objects commit stage commit set means yet know origin line later mergelines assign commit line line appears b range assuming invert diff like suggest
names current previous confusing name b match mean edits one previous corresponds older revision aka side editlist matches newer revision aka b side editlist would nice make obvious reader confused better reuse exact names build loop since called method
find convention using callback function caller tell stop iterating awkward would prefer behave like iterator caller invoke get next revision built returned expose release method caller use clean revwalk implies moving revwalk treewalk instance members api starts work behave like revwalk making consistent
would prefer code inside try/finally case new treewalk throws due outofmemoryerror least clean revwalk release exception pops call stack
understand call next way used confusing newer revision file walking backwards last thing examined think would still named lastrevision lasttext since perspective loop last thing examined even though actually recent revision least find code like easier read everything speaks normally loop e.g last iteration loop need remember loop going graph particular direction backwards
blobwalk null break traversal ca continue dig around history file question disappeared
would invert diff run algorithm diffalgorithm.diff textcomparator currenttext nexttext looking diff normally rather reverse lines added nexttext aka prior loop iteration shown b side difference additions way would see ran ` git log -p ` makes easier reason difference used mergelines
hate exposing rename data revwalk means twice *sigh* cleaner way after-the-fact code something like treewalk blobwalk treewalk.forpath reader currentpath commit.gettree blobwalk null next null break file never existed abort traversal maybe file renamed diff next tree commit.gettree see next path renamed update currentpath break run blame path
actually use rename copy look bottom followfilter tiny method private static boolean isrename diffentry ent return ent.getchangetype changetype.rename ent.getchangetype changetype.copy
please declare final
style-nit unnecessary blank line
looks like final
missing override
missing override
necessary
missing override
style-nit necessary
acceptable line null increment index
necessary
necessary line wraps badly prefer put variable middle rewrite 0 linenumber linenumber lines.length return lines linenumber return null
necessary
expose callers think use get line random caching perform horribly tiny 3 line file *might* acceptable typical source file slow complete
remark
replace byte input loader.getcachedbytes integer.max_value handles reading stream byte array large throws largeobjectexception array allocated object size exceeds array size
jgit uses 3-clause bsd aka edl epl
style-nit put author tags javadoc
please store line content string uses ton memory applications need range trade range string data using rawtext object file
style-nit put see javadoc tags put override method
fwiw called blame git call blame jgit
style-nit initialize defaults rely implicit initialization fields
construct unnecessary please remove
path needs coming revision able change time due rename/copy detection
hang onto objectreader class make caller release release objectreader objectreader used data access treewalk revwalk instances
style-nit prefer bufferedreader reader new bufferedreader try finally reader.close way risk reader staying initialized null something wrong code
ca assume platform encoding
use rawtext instead
used rawtext earlier would need conversion
diffalgorithm configurable default histogramdiff
rawtextcomparator configurable users run blame ignore whitespace differences
users able configure revision start digging
followfilter enabled path change commit walked need storing path revision
take long time rest algorithm better make incremental callers ask data display ask see mean run ` git gui blame ` watch fill file want able thing egit applications using blame sometimes users happy get recent row range results quickly even need wait whole file finish
set line really necessary arraylist line sorted in-place would much smaller
generates lot garbage sure every consumer blame wants would prefer push application want track line data every revision somehow copy output iteration main blame loop yet another reason want blame loop act like iterator application stop inspect scoreboard lines snapshot something want preserve blaming current file showing need tracking lines everything need garbage goes along method
missing override
missing override
missing override
constructor public permit copying line application take snapshot instead support sort copy constructor takes line object cloneline method returns copied line object otherwise think package-private blamegenerator need construct line object
called setcommit
callers need able determine line blamed commit line blamed one ancestors way tell information line object
^ always true lines blamed onto commit point ^ right annotation
null check semi-legal author missing
null check
style-nit unnecessary blank line
s/current complete/current commit/
bound commit.getparentcount 0
aside storing objectid path file file gets renamed move/copy detection want know lines coming
need
please use rely platform encoding
worth enforcing power 2. suggested going bother check
impossible basepath different file system tmp construct tmp temporary file directory file named basepath system know permits single directory file contents spread across different file systems rename within directory would fail sufficient assume files directory part filesystem rename safely unique temporary file name directory stable name within directory fails either stable name already exists made time another thread process perhaps filesystem utter crap ca work former case 'll retry read file made process probably succeed using latter case well filesystem utter crap ca rename file directory ca provide data safety rules git normally provides users get better filesystem
might main data structure horrible entry point make package-private wrap blamewalk class something easier guess upon read almost every class package wondering main driver
true suspect need clearly document owners code ok us relicensing bsd
also support taking starting ending line number callers might need us blame particular region aka -l flag command line know region able reduce space initially pushing queue terminate sooner
know tall order want incremental two public apis /** fully blame file return list sorted lines method blocks lines covered */ list blameentry getblame list blameentry r new arraylist blameentry list blameentry step getnextblame step null break r.addall step collections.sort r new comparator blameentry public int compare blameentry blameentry b return a.range.start b.range.start return r /** compute blame one portion file method returns soon one regions proven responsibility particular origin commit regions part starting file never overlap region previously returned future call */ list blameentry getnextblame way egit implement incremental blame view like git gui users watch fill obviously 'll run getnextblame background worker thread soon block ready forward ui thread painting since queue anyway keep track regions pushed onto parent easily return back getnextblame regions could blame onto parent current commit needs take responsibility
uh yea ok. major problem scoreboard originwalk disconnected originwalk nasty linearization origins leads sort crap horrifically confusing imho originwalk folded outright class code actually get lot simpler stop trying linearize different origins
please call path elsewhere diff package e.g diffentry call likewise treewalk.forpath
needs use treewalk.forpath translating ioexception runtimeexception bad actually set constructor final field appears known anyone constructs origin performance sensitive thing able respond objectid content see originwalk findlastsamecommit
try use getcachedbytes int assuming promise wo edit
instance singleton use rather making callers create instance
use treewalk.forpath
wonder extend edit replace equal sizes either side might much abuse existing class going extend edit smell like getbegina getbeginb rather getastart
score configurable
configurable
cross pools like blamewalk object talking interface definition clearly needs revwalk classes like ensure parents parsed revision pool source commit 've already allocated objects setup pointers parents might well parse in-place keep going rather trying create destroy pools time
better way handle section code treewalk.next switch treewalk.getrawmode 0 filemode.type_mask case type_missing case type_tree case type_gitlink continue also lets avoid issubtree test
going slow snot need use similarityindex diff package public 'll need either use renamedetector make similarityindex public latter might better create similarityindex current origin path treewalk providing create similarityindex score origin similarityindex score threshold common enough consider candidate
ick boxing integers custom list type nak boxing expensive try avoid performance critical sections
instead maybe extend origin class private static inner class additional score field path scores threshold create instance subclass put score push collection want cap number items keep collection think want two highest scoring paths yes use treeset custom comparator knows look score field size set adding new origin larger threshold remove smallest item set usually hate using jre collections classes performance critical code treeset 2-3 items bad
since every origin repository blaming single file hopefully high speed actually using single objectreader things like looking scapegoats think single object represents blamewalk carries repository objectreader around various classes need strategies passing blamewalk origin strategy use blamewalk objectreader perform reading work
obviously dropped 're going keep abstract diff interface diff package blame
please public fields public accessors ok fields package-access though revwalk time
elsewhere jgit often speak ranges terms start end start start + length probably fair amount code change modify semantics wonder anyway edit class example diff package uses start end semantics use rawparseutils pretty much every parse function etc
think use copy follow revwalk iterate exactly provide iterator api provide brain-dead simple use case need multiple traversals buffer results
instead implementing iterator 'd revwalk next returns null end iterator returned iterator buffers one order implement hasnext
ca start revcommit different pool parsed using internal revwalk class reset enqueue start run makes sense near tell walk used parse commits actually used traversal marking starting point setting sorting topo pointless
use treewalk.forpath
get method short-cut try skip chain commits modified file implementation obtuse wonder ca leverage revwalk us rw.markstart origin.commit rw.settreefilter treefilter.any_diff revcommit r rw.next rw.reset return r fast enough skip chain try fix revwalk
need expose
need expose
since owns revwalk needs release method release contained revwalk
*last* line commit message first
true common practice try use first ref fetch_head though normal ref support reading need read first 40 bytes main reason large error fail fast read symbolic reference insane name within name exceeds reasonable length support ref name might truncated fail read correctly limit prevent reading massive binary file accidentally placed refs/ directory sucking jvm byte would painful proposed io.readsome path limit would need additional check issymref buf n true n.length limit need abort refuse process ref potentially truncated symbolic reference
instead dropping 4k limit would rather introduce new io.readsome path limit method allows us read first 4k return either whole file limit reached
mean fetch_head file
.git folder always easiest path give would expect applications want pass something like new file us automatically get repository current working directory starts imply using filerepositorybuilder rather assuming argument exactly git_dir
using git.init .setdirectory .call obtain git instance file awkward best think public static git open file path return git.init .setdirectory path .call public static git wrap repository repo return new git repo class
catch targeted expect transportexception catch let everything else thrown caller type thrown test fail
throwing notsupportedexception probably thing right quite wanted rebuild way api works want introduce transporttype interface implements canhandle uriish fs open repository uriish construct transport instance get rid static list canhandle invocations inside transport instead walk list registered transporttypes egit dialog use list transporttype enumerate connections available rather hard-coding plugins jgit could register transporttype instances allowing us support means transport e.g rsync support today requires use software eclipse foundation wo let us redistribute part core jgit library users supply plugins external sources reason able register work ca think else really critical today might try sketch post change discussion
path actually exists user workstation
message translated using messageformat jgittext
use java.io.tmpdir unit tests focusing trash directory tmpdir gets cleaned unit test framework inherit base class unique name exist file nothere new file trash not-a-git.git trash java.io.file inherited tells us temporary directory everything within within create repository called test _ otherwise trash directory empty never see not-a-git.git present within
want pack closed exception goes call stack read method good returns successfully pack stay open
always true allocated new file new never returns null
empty javadoc get around api documenting pointless require documentation reason implementors know need implement abstraction callers know use
wonder better solution create connectionfactory class within transportgitssh use setconnectionfactory method callers still use transport.open get transport instance ssh type set factory leave alone frees callers needing parse uriish determine protocol jgit use might lines code add factory extra level indirection might useful different approach would start removing jsch information transportgitssh make slightly generic remotecommandconnection extracting transportgitssh.connection new top level class rename transportgitssh transportgitremotecommand hide jsch stuff inside jschremotecommandconnection start free jgit supporting jsch 'd like also support mina sshd client looks solid implementation
expecting 0.11.3 release usually merge 0.11.1 unqualified version master update versions 0.12.0.qualifier need go back changes stable-0.11 would create 0.11.2.qualifier time
key use mentioned commit message like approach similar commit-msg hook gerrit comes install repository always updates commits downside hook fires even want change-id message sure problem think upstream using gerrit code review probably always want change-id automatically inserted commit make repository least use case
drop cq need yet
pom still using 0.1.41. 'd like rev pom time declare dependency maybe defer 0.12 cycle
drop cq need yet
causes us always dive ignored folders ignored folder build output directory may looking millions file paths ignored care anywhere putting check dircache code safely skip ignored directories tracked files within ignored directory file tracked always looked even also ignored
style-nit commit messages longer 70 characters per line otherwise format well traditional git tools like gitk git log etc
sure refactoring really helps us avoid checking blob think massive amount over-engineering simple problem want materialize entire content blob order check reason check blob ca verify anything except compute sha-1 indexpack already order build index file git usually create new object types 5 years still using original 4 object types linus torvalds defined could easily add test indexpack says something like type obj_blob check data much simpler change
style-nit use prefix interfaces
style-nit file headers must contain bsd derived license text
given values 1 4 array might better choice elsewhere e.g packwriter use array
style-nit put spaces method arguments
style-nit try line-wrap lines 80 characters sure terminals wider often view jgit code side-by-side code reviews within ides ton widgets along left right sides code keeping narrow text width makes easier still read everything
style-nit put spaces around operators omit unnecessary curly braces objectchecker null objectchecker.check raw
require javadoc public declarations
sure happy current file neatly organized one string name per line new formatting 3 lines per string ugh undo code formatter save fingers ctrl-s ctrl-z editing file
thanks explanation algorithm absolutely n*d worst case big-o notation means worst case input consists n unique elements difference b b inserts new element element a. means 'll edit list n/2 histogramdiff splits recurses times recursion looking n-2 elements higher level happen often fortunately even contrived difftestdatagenerator see sort input contrived test data number unique elements hashed located efficiently since primitive char fallback match common low-occurrence elements quickly found hashtable practically constant run time test probably behaves like n time think uncertain even test really change myersdiff often testing algorithm correctness sufficient really meddling algorithm running real data sets like linux-2.6.git see performance difference real-world inputs contrived cases diffalgorithm implementations designed run well human written source code designed run worse n inputs latter willing prove theoretically rather rely benchmark former well established periodically running tests real-world corpuses people actually care think 'll try write new test program similar texthashfunctions exercise diffalgorithms instead line-level hash routines
test failing junit.framework.assertionfailederror minimun maximum performance-index t/ n*d differed much measured factor 20.26732580423589 maxfactor=15 perfdata= testhistogram 10000 bytes took 2879800 ns n=20000 d=18 time/ n*d :8e0 time/ n*d^2 :4.44e-1 testhistogram 20000 bytes took 8130200 ns n=40000 d=36 time/ n*d :5.65e0 time/ n*d^2 :1.57e-1 testhistogram 40000 bytes took 18798500 ns n=80000 d=70 time/ n*d :3.36e0 time/ n*d^2 :4.8e-2 testhistogram 80000 bytes took 48076800 ns n=160000 d=143 time/ n*d :2.1e0 time/ n*d^2 :1.47e-2 testhistogram 160000 bytes took 96502500 ns n=320000 d=287 time/ n*d :1.05e0 time/ n*d^2 :3.66e-3 testhistogram 320000 bytes took 257217700 ns n=640000 d=574 time/ n*d :7e-1 time/ n*d^2 :1.22e-3 testhistogram 640000 bytes took 780854428 ns n=1280000 d=1148 time/ n*d :5.31e-1 time/ n*d^2 :4.63e-4 testhistogram 1280000 bytes took 2317911000 ns n=2560000 d=2294 time/ n*d :3.95e-1 time/ n*d^2 :1.72e-4 know christian ideas
rename class diffperformancetest
myers promises run n n sum lengths b size minimum edit script think true current patiencediff implementation particular sorting step recursion thinking correctly patiencediff running time bounded size inputs around log + b log b + =~ n log n + matches variation myers algorithm uses suffix trees _think_ n log n + going faster n n really big log n could easily exceed d.
actually horrible input patiencediff result length edit script always exactly 1 full replace problem stems patiencediff needing locate unique common point within segment generated input segments single characters wind repeating not-unique anymore corner case patiencediff falls consequently myersdiff produces actual edits patiencediff 'll try come better input
ca setting executor always disabling threaded delta computation fix error problem writes delta thread order update progress stream later try write pipe different thread write pack problem correct fix modify packwriter ensure progress messages written main thread rather one background delta threads
make sense care head unless head branch renamed
assign null compiler correctly error refuse compile class try block assign value return
need document oldbranchname null causes current branch renamed really obtuse nobody going know
missing checkcallable
need resolve head delete branch head
yes delete branch head checked right caller instead detached head checkout different branch first probably new top-level exception type us ca think existing error type makes sense use
also need handle types like lock_failure io_failure rejected_current_branch yes even though checked rejected_current_branch case another thread might changed head meantime jgit going check delete invocation need handle
think necessarily error caller asked us remove gone really demand error maybe optional flag set setfaildeleteifnotexisting expose result type caller examine two different results deleted did_not_exist callers happy thing asked remove fact removed care happened
internal exception
internal exception
support remote
need handle lock_failure io_failure rejected
sure suffixed right word inserting prefix
remote true use r_remotes instead
internal exception proper top-level api error callers check expect already one tagcommand throw invalidtagnameexception need invalidbranchnameexception
also internal exception
yes
need handle lot lock_failure io_failure
need lookup ref 've updated created ref cached refupdate stale
missing checkcallable
missing checkcallable
overload public branchcommand setobjectid anyobjectid id checkcallable this.id id.name return
missing checkcallable
wrong need account fact another element within region spanned lcs might unique even though original element caused us create region unique
since 're mucking lets define public enum objecttype commit constants.obj_commit constants.type_commit tree blob tag public int getpacktype return packtype public string gettypestring return typename public static objecttype forpacktype int type public static objecttype fortypestring string type declare part public api add getobjecttype objectloader objectstream revobject application prefer use type-safe enum variant also implement overload forms open objectid int method open objectid objecttype current typing code supported java 5 access enums enums bit cleaner work might well start supporting imho change add catfile use objecttype parameter
use db.open objectid typecode instead
single byte io objectstream implementations perform poorly allocate new byte 4096 new byte 8192 io larger units also size well known outputstream.getsize good paranoid double check total number bytes output matches size stream differ complain loudly die
know item match point contained within another match point going match point recursive step run tried caching edit indexed bof rec recursive steps need redo stretching match determine total length unfortunately proved slower caching like isunique caching think caused input sequence cheap equals method fwiw tried caching hashmap integer edit also sorted list edit sorted startb latter seemed like good idea match list already sorted could merge-join two lists together loop suspect caching slower amount memory allocated track edit instances went removed use edit region index throughout code memory allocations even slower using edit instances apparently pushing 8 ints onto call stack frame activation slower allocating two objects pushing two references onto stack yuck
split function combined sibling splitindexb massive amount complex code duplicated two
right suspect losing badly myersdiff sorting lines n log n myersdiff able run n time switching hashtable trying get n construction time may help things considerably
fwiw tried caching results isunique record know record unique within particular index segment remain unique rest recursive steps contain record step splitting index half even smaller caching worked shifting element position 1 bit or'ing 1 soon found element unique start method became rec 1 0 return true turned slower every system tried suspect artificial due type sequence used performance test equals char based sequence used test insanely fast equals larger line input like rawtext uses lot slower revisit caching concept testing common input
obviously want remove tests temporary make easier understand performance impacts changes made patiencediff
nak. valid name ref git check-ref-format 'refs/heads/foo bar echo 0
conflicts change i3f8af29066cc5a2132dc4a75c9654d97800f2f18
need add emptytreeiterator treewalk slot 0 inside egit comparing initial commit empty tree everything magically falls added inside gerrit code review initial commits means muck around special corner cases like inside jgit
length included string
please see work http //egit.eclipse.org/r/1156 implements isentryignored filetreeiterator
sadly quite mind ignore stuff distracted refactoring work review time got submitted anyway 're ripping checkout directory *twice* find .gitignore files build table needs ignored traverse wanted workingtreeiterator keep ignorenode level within ask tw.gettree 1 workingtreeiterator.class .isignored determine current item ignored keeping ignorenode inside workingtreeiterator already full path root parent pointers fast efficient knowledge whether even .gitignore directory
right never null change seems pointless
sure statuses ever null
squashed prior commit
please careful reformat existing code otherwise changing especially smaller changes like
somehow refactor code db.openblob id .getcachedbytes part copy-and-pasted identically two lines
style-nit space
code complex enough might justify new top level method rather buried within selection listener
todo obviously needs addressed submitting change ideally text would obtained time tag name another field dialog
need check result make sure actually created
please update copyright statement accurate
please put spaces commas line-wrap closer 80 characters
would making date constant reduce complexity tests
following cases example.com
please use explicit character encoding prevent odd platform defaults breaking tests iso-8859-1 utf-8 suitable test given inputs
elaborate bit processing phase hook invoked relative prereceivehook
style-nit drop final keyword two arguments might able avoid breaking line method declaration
unclear ok hook mark receivecommand status order reject operation compare class javadoc javadoc prereceivehook 'll see mean 're bit verbose use interface
style-nit keep order consistent declared field prereceive field declared initialize
style-nit get one line /** return hook invoked validation occurs */
style-nit think use tabs indent javadoc blocks
sure see value hook right harm following loop immediately jumping prereceivehook implementation gerrit code review basically see hook gives us ca already prereceivehook knowing conversations particular feature trying implement gerrit really need able influence map string ref used inside sendadvertisedrefs altering collection needs different prereceivehook fired much earlier prereceivehook also need expose set objectid indexpack inside receivepack generated set needs visible prereceivehook gerrit complain reject everything flat object set jive actually see
always content check horribly expensive normally git application check timestamps indexentry resourceentry fall back content check race condition detected logic roughly indexentry.time resourceentry.time assume dirty modified else indexentry.time indexfile.time assume clean else indexcontent resourcecontent set indexfile.time resourceentry.time save indexfile else set indexfile.time resourceentry.time save indexfile racily clean racy git problem git bit details try looking dircacheentry mightberacilyclean smudgeracilyclean methods decorator code basically work git status command line tools taking advantage strategy checking file modification times falling back content checks race condition correcting cached index timestamp content check future request basically todo deleted trying talk
today submitted change egit least rebase onto current master think
better prior patch squash two together single commit also think avoid using toprivatestring method uriish instead get password data directly uriish reduces chances 'll publish password part error messages things fail
indentation leading whitespace wrong project standard indent tabs class also static use authenticator want publish authenticator instance jre handle back transporthttp could pin entire repository object data files memory indefinite future
indentation wrong use tabs spaces wonder way inject authentication data jre url library 're toast library nobody else install http authenticator using http network connections plain evil
think return void throw arrayindexoutofboundsexception offset + size buffer.length eofexception position + size this.length also bit concerned fact api using entry perform read classical java.io implementation lightweight wrapper around java.io.file means readrandomly must open file perform read close returning pack file data access translates 3 system calls per data block read vs. current situation 1 call per block read able amortize file descriptor open close accessed blocks also opens potential race conditions open pack file posix win32 certain continue read close repository repacked reading may get part object one block need go back get next block repacker may delete pack replace something else entirely even evict object become loose significantly complicate reading code handle file disappearing replaced anytime issue read
units sure mean milliseconds lets specific documentation
would call getlastmodifiedtime since includes time date
io small odd-sized units use 2048 4096 8192 16384 buffer size underlying streams bufferedinputstream bufferedoutputstream 'll bypass buffer avoid unnecessary copying underlying streams disk io streams 'll perform roughly page sized page aligned ios makes filesystem code os kernels rather happy also reason public relevant copy method class
maybe say copying entire stream eof
maybe create better think new implied fact creating given entry directory stream aka file maybe indicate better creates stream directory instead public boolean createdirectory instead mkdirs public boolean createstream
exposing implementation detail
confused javadoc ask lock lock fails acquired already held someone else method exactly
ugh bad enough use extra 16 bytes per file 8 byte object header lockfileentry 2 fields localfile storagesystem need *another* 8 bytes lock file data localfileentries need
lock true truncated file supposed modified new version fully written disk *and* lock released git relies atomic updates filesystem writing new content new temporary file renaming real file name new content completely written method *completely* ignores scheme making incompatible useless jgit
good recursive file lock calling thread already file path open different outputstream crash windows ca two write handles open path name time especially lock entire file region also crash posix system reason
entire set conditions insane simplified return new fileoutputstream getlocalfile overwrite need racily stat file existence trying setup constructor call
style nit given success returns fall-through else occurs work much readable read code written condition1 return result try something else condition2 return result try something else condition3 return result fail read condition1 return result else try something else condition2 return result else condition3 return result else fail
style-nit unnecessary local variable
really want implement something like newcondition specified lock interface even need conform semantics
way abort fail write lock file e.g disk full closing lock file delete abort caller replace main file potentially destroying user repository
use + compiler rewrite use stringbuilder code easier read
flip order use appendmode mainfile.exists pay stat call enable append mode
open lock stream twice append open copy data main file leave open writing operations
ca use reliably lock file must use java.io.file.createnewfile create entry disk posix must use open o_creat flag ensure process created entry parent directory required compatible c git locking protocol posix platforms
ugh rely gc release locks caller leaks lock release lock probably stay held indefinitely caller might fully cleaned another access resource could find inconsistent state also easier identify caller clean entire system grinds halt lock still valid nobody get anymore system sometimes suddenly frees gc ran finalization ran lot harder identify problem
callers easily catch ioexception dealing file io abort recover callers ca easily catch lock failures abort recover
quite unhappy fact lightweight java.io.file wrapper requires finalization every instance finalization really slows gc object ca removed immediately must preserved gc stuck finalizer queue wait finalizer run
smells like over-engineered currently use conditions jgit need able create multiple per file entry
waiting amount time waited internal lock wait time duration whatever left caller maximum wait
race condition multiple instances could constructed
blank line method next declaration
point hashtable protecting map anyway synchronized methods
unnecessary given next two lines perform get test null result
unnecessary assignment 0
final
property storagesystem filesystems might support executable bit others e.g mounting ms-dos partition linux system ext2 directories might support executable bits ms-dos directory method javadoc implies os jre matter could storagesystem
could define 3-way value public static enum executable executable normal_entry unsupported since pretty much caller method *also* consult isexecutablesupported makes 4 states 3 make sense say isexecutablesupported false isexecutable true
moved prior commit fix prior commit bugs later commits especially later commit specifically addressing one issue
moved prior commit fix prior commit bugs later commits especially later commit specifically addressing one issue
ca inside localfilesystem heck could actually two different versions localfilesystem one compiled java5 always fails methods one extends compiled java6 uses direct method call java.io.file executable methods rather relying reflection use reflection actually load class code basically mess 'd rather shift lfs class least extend override jvm specific variant require reflection mess try/catch/throw error
never talk home directory commit message
method entry public entry resolvechild string path like getchild except accept path name may incur expensive stat hit due forking compute symlink systems getchild trying replace fs.resolve really also drag discussion method javadoc like expensive execute used getchild getchild used resolve etc
non final static fields public
able get see remark putting method entry/localfileentry impossible
branches caused *much* prefer existing fs interface 4 subclasses overridden methods ca io package use last caller integrate extremely difficult review reformatted version code ensure logic still equivalent
also declare hashcode equals tostring interface abstract implementor encouraged override implementation
exposing caller needs path rely uri external form
isexists awkward java.io.file eclipse icontainer use exists operation
since re-inventing wheel 've always thought java.io.file screwed equivalent posix struct stat words wonder define api return object obtain information entry also cache information entry pointer location public interface entry /** obtain information entry resulting object may use caches internally reduce calls need up-to-date information obtain new entrystatus */ public entrystatus status /** cached status information entry */ public interface entrystatus public static enum type file directory public long length public boolean exists public type type write java.io.file version interface static class fileentrystatus private final file path private long length -1 public long length length 0 length path.length return length
maybe define filenotfoundexception item exist ioexception failures
think direction java.io.fileoutputstream defines boolean append defaults false often want overwrite file
scheme_file instead
style usually cuddles else prior line closing brace one line inside block often omit braces
author tags
iirc style guide 1 tab indent 2 spaces
would someone pass null expect failure
would someone want register null failure
please use short urls javadoc know long short url service going stay around use complete original url
uri calls getscheme use name
implementers return null passed null throw npe right away
really matter anything java.io.file
missing following methods hashcode equals tostring
final
final
based awkward
allowed change immutable
allowed change immutable
pointless test fileinputstream constructor already stat call throws filenotfoundexception item exist filesystem
pointless catch block
entire method overly complicated written fine public outputstream getoutputstream boolean append throws ioexception return new fileoutputstream getlocalfile append
pointless catch block
hell converting file uri convert back file ca create localfileentry directly right
seems like really expensive way file c new file getlocalfile name c.exists return new localfileentry c getstoragesystem return null
good question lot java code takes style check null throws npe rather iae could omit null check altogether case 'd probably crash equalsignorecase due one arguments null result npe message preference wrote
sure helps nls behavior much really need resource bundle use seed exception error message current locale need unique exception object every error code ui handle different types
fixed
fixed added httpsupport
fixed yes static
sources encoded utf-8
sources encoded utf-8
sources encoded utf-8
mixed spaces-before-tabs indentation prefer tab indentation jgit must use spaces get alignment right tabs still used spaces line
