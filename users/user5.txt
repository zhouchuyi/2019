really expert would nicer stick import-package statements stick require-bundle make import-package statements org.junit obsolete
marked volatile field moved name technically field set access attribute unix nlink throws unsupportedoperationexception based api doc means view unix supported attribute nlink known another currently unhandled exception thrown means think name ok
done
done
done
done
done
done
done
done
done
done
done
done
done
agreed moved reading configuration option fs classes whenever fs class asked supportatomicfilecreation option yet read read system/global config repo config read anymore
could check already isbinary head n whether last read chunk contained null could avoid loading header multiple chunks first chunk already contains null
extracting variable reuse next statement
done
done
could add test multiple processes think required test shows failing without fix even gc started process shows problem test shows run gc different repository instance pointing location filesystem order corrupt original repository/objectdatabase fix write packfile means detect new packfile explicit test whether new bitmap index file used added
done
done
done
duplicating method protected method called inside class add attributes parameter list need two processentry methods one one without attributes
really also sometimes confused allowed minor release asked matthias said allowed change signature protected methods minor release breaks implementors people subclassing methods clients using public api broken minor release think ok simply modify signature protected method add problem filters silence api tooling
would expected statement current entry merge attribute set call contentmerge otherwise call contentmerge sounds strange even call contentmerge know content merge benefits would method contentmerge would need new signature fix would smaller important potentially expensive calls get content base cases know need content binary files similar submodule link files line 688. may could add '|| isbinary line 688 later may support even attributes influencing merge e.g merge attribute set string defining external merge driver think code handling also go based attributes would determine mergealgorithm configure let algorithm content merge
sure whether contentmerge needs know attributes handle processentry
sure whether updateindex needs know attributes handle processentry
could avoid changes class call mergealgorithm merge attribute unset
described semantics method javadoc return true entry -merge merge=binary attribute maybe hasnoorbinarymergeattribute canbecontentmerged dislike *binary* method names fails set -merge attribute non-binary files
method called isbinary checks merge attribute maybe call ismergeable think situation text files content-merged files text know content merge algorithm would create invalid content want force human merge one example mind property files written tools always write lines random order files binary e.g ok cat content console although contain text useless run jgits default mergealgorithm binary also mergeable
assume fs posix test also fail windows machine
expensive inspecting whole repository changed/added files although know interested single path want know whether /path/to/submodule marked dirty asking parent repository least set filter indexdiff concentrate certain path e.g indexdiff.setfilter pathfiltergroup.createfromstrings alternatively could even check manually whether submodule repo dirty submodule repo clean check whether submodules repo head id stored index parent repo also true submodule clean
right makes sense inspect submodule repo head already read documentation 1 look docs regarding on_demand says submodules repos updated superproject retrieves commit updates submodule鈥檚 reference commit isn鈥檛 already local submodule clone different check fetched parent project regarding submodule different parent projects index working tree e.g create commit submodule updated parent projects index point commit afterwards every fetch update submodule documentation shows need deal fetch_head commit parent project ignore parent projects index working tree maybe would aligned native git behaviour much performant solution indexdiff workingtree expensive would submodulewalk tree behind fetch_head submodulewalk index every submodule call getobjectid check object exists local submodule repo 1 https //git-scm.com/docs/git-fetch git-fetch -- -recurse-submodulesyeson-demandno
force caller specifify config thats expensive forces us check whether three possible config locations new data effort needed submodulerecursemode explicitly specified suggest signature getrecursemode string path repository r expensive r.getconfig need
s/clatify/clarify
yes solved done manual cleanup operations waiting next object folder created purged wait long enough folders deleted
trying delete files inside subfolders /objects could lot subfolders could also remember folders deleted files try delete non recursively folders
happens file named pack-1234idx directory ending well known extension files would deleted
would simply remembered last seen pack file new variable would checked bitmap/index whether correspond packfile orphans would get rid exists filesystem calls listing like path packdir paths.get repo.getobjectsdirectory .getabsolutepath pack non-nls-1 string base null string list packdir.tofile .list file name return name.endswith + packext.pack.getextension name.endswith + packext.bitmap_index.getextension name.endswith + packext.index.getextension arrays.sort list int list.length 1 0 -- list .endswith packext.pack.getextension base list .substring 0 list .lastindexof else base null list .startswith base try files.delete new file packdir.tofile list .topath catch ioexception e log.error e.getmessage e
think change works great optimisations would suggest array files hand already information hand detect orphans need expensive filesystem calls .exists calls isorphan method would would use directorystream filter .pack .index .bitmap files matthias suggested would sort stream ensure packs come directly corresponding bitmap/index files easy detect orphan index bitmap files follow directly corresponding .pack file
since tags would nice new methods
eyes comment clarify enough combination expirationdate preserveoldpacks preserveoldpacks true packfile younger expirationdate happen packfile moved preserve directory
theoretically need something similar also delete loose objects chances high problem jgit keep loose objects open packfiles likely always delete additionally many loose repo server side repo managed gerrit
conflict markers need cleaned
nit please remove trailing whitespace
need second non-nls comment second string
ioexception thrown
4.1 shouldn'it 4.7
ah feature aware really delete whole preserved directory old pack anymore thought delete pack files themselve
line gives warnings eclipse implicit boxing false boolean.false used better import import static org.junit.assert.assertfalse use assertfalse repo.getobjectdatabase .getpreserveddirectory .exists
similar would use asserttrue
done
done
done
done
done
done
done
done
done
done
done
done
done
done
done
done
comment change accepted 6 years ago think bug imagine filesnapshot file f. lastmodified lastread t0 time t1 1 modify file 2 update filesnapshot file lastmodified=t1 lastread=t1 3 modify file 4 wait 3 seconds 5 ask filesnapshot whether file dirty answer clean lines without lines filesnapshot report file dirty unless re-read point time t1 read file t1 know modified t1 multiple times would like remove lines objections bug causes gerrit sometimes miss newly created packfiles created external process native git gc see test fix https //git.eclipse.org/r/86738
done
done
done
done
done
done
done
sure whether atomic move needed definitly hurt
previous class wrap repository instances want call gc
since jgit always writes one new single pack file need optionn
method changed behaviour document nearly always creating new packfiles returning method lazy create new packs whenever loose objects mention effect automatic method especially default automatic true
see explanations happens auto==true expecting something like auto==false gc always full garbage collection
explain happens setauto false called
many refs side effect packing loose objects also refs pointing persisted packed-refs file nice effect performance servers lot refs like gerrit
right mention
think jgit -d always delete old packs prune loose objects creating new pack -l option indeed support although support alternate objects stores
50 constant
maybe need special case imagine somebody native git experience configures autopacklimit==1 always one single pack jgit behaves differently gc producing one packfile default one objects reachable branches rest maybe jgit make sense configure autopacklimit==1
constant
mention method supported repo types filerepositories support
maybe autogc could take git instance parameter
ok like void repository autogc proposed solution seems best one +1
thought would void repository autogc different implementations repository could need autogc right
really start import org.eclipse.jgit.api wrapping repositories call gc api command additionally deal returning statistics unneeded thing benefit api garbagecollectcommand instanceof magic instantiate right gc class single factory method producing right gc class repository skip need wrap repository classes
done
done
done
done
done
done
done
done
done
done
also imagine different code paths executed added test custom flag shows bug
still get eclipse warning discouraged access type 'atomicobjectoutputstream api restriction required project 'org.eclipse.jgit.lfs
done
found indeed read data two times least changed comment clarify solution go different commit
done
done
done
done
flag telling found version line renamed variable clarify done
done
done
done
done
done
done
done
done
done
done
done
done
done
done
done
done
done
done
removed todo think write twice since cleanfilter least lfs use case always cleant content small kept memory
done
done
done
done
done
done
done
done
done
done
done
done
done
done
done
done
nice idea tried end fit well lockfile assumes file locked lockfile file paths ends .lock directory important able check easily whether file locked another problem lockfile would already code copies content original file lockfile ca reuse want compute oid content copying original file lockfile
done
thats really purpose configured strange setup clean filter converts real content pointer file content smudge filter replacing e one round clean filter smudge filter end pointer file replaced e resulting versien instead version artificial setup guess end user wants nice stress test bu 'll add comment clarifying done
ca use directly constant contains dash instead add constant computed long_hash_function
done
done
done
sure whether always corruptlongobjectexception mediafile contain unexpected lines big etc maybe use exception
done
done
done
done
done
done
done
done
done
done
done
done
done
done
done
done
done
done
done
done
done
done
done
done
get inlined
done
done
done
done
done
done
done
done
suggest duplicate comments fields constructor parameters 'll suggest
done
done
done
done
done
done
done
done
data specified case filter implementions read either original content clean filter filtered content smudge filter case hooks think specific hook
done
done
done
done
done
renamed everything builtincommand filtercommand done
done
done
done
done
done
done
done
done
done
done
done
done
done
done
done
implementors filtercommand.run forced filtering one call run instead filtering chunks data e.g filtering one line data report consumed data returning -1. allows implements chains filters running huge amount data without big buffers multiple threads
specifying branchrebasemode.none default config getenum test could succeed accidentally would choose different default value e.g null branchrebasemode.rebase
looking code using method e.g pullwizardpage hasdifferentupstreamconfiguration sure whether ok. sure guess users would better return true modes rebase maybe returning getrebasemode branchrebasemode.none would better
would use null default value
would use null default value
would use null default value
would use null default value
s/pre/post/
means output precommithook postcommithook go outputstream imagine postcommithook emits error messages runs error maybe application using jgit react errors retry warning end user solution application chance parse postcommithook output would nice chance seperate outputs e.g adding sethookoutputstream printstream precommit printstream postcommit existing sethookoutputstream hookstdout would continue set outputstream hooks
post-commit
adding code commitcommand tested maybe add least one test precommithook postcommithook uses commitcommand
hmm change public api reporting untracked submodules always getuntracked think change api minor release projects may rely seeing submodules getuntracked gitlinks submodule objects tricky context gitlinks stored index trees always leaves object hierarchy children gitlink objects look index trees looking persistence filesystem see trees therefore would make sense report untracked gitlinks untracked means exist filesystem directories agree since would change behaviour would suggest fix cleancommand getuntracked reports folder check whether gitlink act accordingly
maybe careful git clean command doc says clean folders contain file folder named .git different isgitrepository maybe check existance .git could detection git repos also go cleanpath cleanpath path recurse force infiles could
done
style nit use tabs indention also true lines added/modified
happen recurse==false curfile.isdirectory true would guess specified recurse==false never go folders maybe test would good recurse==true curfile.isdirectory ==false really want add adding slash behind path know folder javadoc explaining semantics method needed
done
need since tag since new method
please remote unneeded import
please remote unneeded import
done
style nit use tabs indention
maybe clarify leaf directory first expecting leaf directory subdirectories mean directories except root dir
hmm mean repo refs/heads/master refs/heads/test/f refs/heads/test/march/g call pack expect effects leaf directory refs/heads/test/march help fix 'll delete folders refs/heads/test/march refs/heads/test
gc specific think problem fix purely inside refdirectory refdirectory.pack inside method aquire lock refs unlock trying delete refs everybody uses jgit call public method refdirectory.pack affected
agree want delete folders 'refs/heads 'refs/tags misuse lock files prevent code folder deletion debugged see ever try delete refs/heads independent lock/unlock refs called ref refs/heads/dir/r depth==1 means entering loop line 1079 deleting refs/heads/dir never try delete refs/heads would still vote removing depth 0 line 1075. tests green even without condition top level ref folders even tried deleted
need depth 0 really want handle refs located directly underneath refs/ differently one directly understand want delete refs/ folder therefore behave differently level 0 levels 0 unlocking refs done levels
create exception throw want see stacktrace log
one implementation ref.getpeeledobjectid one symbolicref seems expensive would make sense cache result ref.getpeeledobjectid local variable know never deal symbolic refs
done
done
right completely get rid risk hallways workingtrees implementing prescantwotrees would lower risk much in-line detection dirty workingtrees 'll upload pathset
done
agree name like suggested concentrated change main use case failonconflict==true failonconflict==false handling follow
done
get block enter authmethod.gettype httpauthmethod.type.none line adding authmethod.gettype mean ignoretypes collection always contain httpauthmethod.type.none
done
done
done
done
done
done
sure whether intended reset hard git typically problems deleting content asked question http //permalink.gmane.org/gmane.comp.version-control.git/279482
done
thought use case refdatabase used client side e.g combination egit getadditionalrefs intruduced a4f7992 able return fetch_head merge_head orig_head iirc compatible cgit wanted refs returned getrefs reftreedatabase supposed expose fetch_head method
wanted try client side repo compiled patchset tried mkdir testrepo cd testrepo/ jgit init initialized empty git repository /tmp/testrepo/.git git config extensions.refsstorage reftree git config core.repositoryformatversion 1 jgit config -l -- local core.filemode=true core.logallrefupdates=true core.repositoryformatversion=1 extensions.refsstorage=reftree touch jgit add jgit commit -m initial fatal branch yet born possible use commandline jgit clientside non-bare repo try new reftreedatabse
done
overlooked 99 case nobody calls setreflogcomment reflogcomment null noreflogcomment false reach else branch noreflogcomment set true somebody explicitly expresses write reflog calling setreflogcomment null 'll propose change flag renamed usedefaultreflogmessage make clearer
unneeded import please remove
missing since tag
missing since tag
missing since tag
missing since tag
missing since tag
need since tag configured api baseline checks described http //wiki.eclipse.org/egit/contributor_guide checking_for_jgit_api_changes_using_api_baseline
missing since tag
eclipse complaining api change minor release filetreeiterator final workingtreeiterator p final file root fs fs anymore changed filetreeiterator final filetreeiterator p final file root fs fs subclasses filetreeiterator projects may broken maybe could leave implementation filetreeiterator final workingtreeiterator p final file root fs fs passes defaultfilemodestrategy.instance
ah know remember line looks familiar chris price change 51483 already talked line uploaded fix
semantics new config constants explained especially would expect mentioned commit message need
could add javadoc methods checks especially two eolstreamtypes relate expectedoutput need explanation stream types result result testcheckout
got idea assumption happen binary data pumped streamtypetext crlf- lf conversion happen right test test streamtypetext touch non-crlf binary data
testing streamtypewithbinarycheck binary data want test streamtypetext also binary data similar question also testcheckout
removed text copyright owners documented project ip log copyright intentionally
workingtreeiterator game would need db workingtree attributes
done
first liked way implemented tests one abstract class two implementing classes change test data working test classes found nice ca eclipse start single test anymore ca rightclick test_configeol_native_xnix say run as- junit test remembered tests want run tests different test-data/flags used junit theories 'll upload version tests using theories like roll back next patchset
comment removed
done
single line dominates performance executing tests know method quite good need sometimes case tests work also without fstick execution time tests drop linux box 130sec 8sec executing tests related class
done
done
places indention nice 'll upload auto-indented version
change needed test running two commits object database checkin checkout eol handling required removed change run new tests still green
change needed
change needed
sure whether really need flags somebody wants checkin/checkout without attribute handling able e.g write tools rewrite history like filter branch want explicitly checkout content exactly object-store ok
sure need functionality atomic updates ref use class expensive able distinguish not-yet-set null
info block tested tests seems tests big 65k binary containing '\0 first 8000 bytes files even change tested sure block works
right copyright new file
'll upload patchset one method generate tests data make patchset smaller
'll upload version speaking names instead file1 file2 file3
'll upload version speaking names instead entry1 entry2 entry3
'll upload version helper method decreases size class
first deleting working tree files hard reset causes problems tests would like add reset leave us workingtree files index-file last-modification time causes index entries smudged lenght set 0 maybe reason fstick code removed fstick createandgetfile help reset -- hard empty working tree always end smudged index one solution 'll upload git add end forces jgit write new index younger modification timestamp files 'll upload version
using walk.getobjectid 1 ok find objectid stored index would like explicit reading indexdata seperate dircache instance 'll upload version
ok little bit surprised although added already lot tests add another complex test see difference jgit native git previously existing tests went fine showed jgit behaves like native git anyhow side looks good let bring
somehow native git expects something different native git checkout content_crlf index content_lf yet know somehow behave differently native git
attribute handling git transports required
change required
incore merger works memory without working tree need attribute handling
tests use worktree attribute files root tests attributes added index differ attributes worktree head tests checkout branch b head contains attributes b vice versa head attributes b attributes
ivan seen comment
add file mixed line endings one line crlf another lf maybe want support core.safecrlf soon
name would expect method writetrashfile would call createandaddfile
would call checkallcontentsattributes
important would also check content made repo currently checks looking filesystem could add index dirccheiterator walk check methods could get parameters expectedindexcontent also check index content
would call checkentrycontentattributes
method resolves refs objectids need attribute handling
commit message tell changed changed many questions besides commit message +1 side
would love get rid parameter
love idea remove attributesnode rebased commit newest master work newest api baseline eclipse complaining remove public method tryout rebase download newest release http //www.eclipse.org/downloads/download.php file=/egit/updates/org.eclipse.egit.repository-4.2.0.201601211800-r.zip configure current baseline
rules stored attributesnode unmutable given attributesnode call parse change rules stored instance therefore checks like globalnode actualglobalnode sufficient imagine globalnode==actualglobalnode true call actualglobalnode.parse newstream afterwards globalnode==actualglobalnode still true although contain entries either make attributesnode unmutable call .equals explain sure enough detect modification
static constant depends static stuff maybe static constant rule constant set default rules
substring 6 macro_prefix constant change better use macro_prefix.length
clear expansions reload refill imagine global attributes contained attribute custom file changed contain attribute custom anymore remove custom expansions field test covers
see
initializing 1. likely one attributes like text would use 5
purpose construct remove duplicates collector would efficient expandmacrorec takes care reuse entry key expandmacrorec promises never create duplicates collector could map beginning would always return collector.values
understand name macrorec
mean native git
like test class eclemma says managed high test coverage macroexpanderimpl
really interface multiple implementations macroexpander class macroexpander code macroexpanderimpl could drop macroexpanderimpl nullmacroexpander could save additional parameter getattributes always use macroexpander maybe use cases mind different macroexpander implementations
really need expose two methods outside merging internally class
great attribute specific code attributes package class name macroexpander lot deals merging attributes provides access attributes find generic name attributehandler something like definitly need javadoc
possible npe treewalk null public constructor leaves treewalk null would suggest get rid constructor savely assume treewalk =null
always call complicated merge-method static infoattributes info attributes change run one treewalk cache result maybe inside mergeinfoattributes could cache data
thought idea merge attributes merge attributenodes whenever enter new directory would merge together relevant nodes one currentattributesnode node could cached every call getattributes specific path could reuse cached currentattributesnode would reduce number merge operations number would tied number folders instead number files
get always rootnodeattr could assume changes happen .gitattributes files one treewalk detected us need attributes first time 'll merge global/info/root-work-tree .gitattributes field one field rootattributesnode search macro definitions traversing tree touch global/info files merge rootattributesnode .gitattributes files find traversing worktree
lot duplicate code getcurrentattributesnode
main concern code located think currently pollute treewalk much seems strange treewalk learns macroexpander treewalk knows different trees participating walk additionaly knows optype checkout checkin know details compute effective set attributes code merge attributenodes epxands macros belongs eyes org.eclipse.jgit.attributes package e.g would constructor macroexpander taking attributesnodeprovider three treeiterators could work attributes package
see comments getcurrenttreenode think need changes
macroexpander knows info global nodes treewalk care call correct order knowledge merge current info global hidden macroexpander
ivan think idea attributesnode know macroexpander attributesnode.getrules returns set expanded rules
rename method old name gettree better getcurrenttreenode know treenodes word current makes make think method checks whether returned tree really matches current head walk line line 700
every macroexpander needs know root attributes node one interested attributes root level use cases need effective merged set attributes getrootattributesnode logic getroottreenode could go constructor macroexpander
instead storing reference root iterator could directly store attributesnode contains merged content global/info/root-worktree .gitattributes
seems unrelated change constants used right
end need differentiate call method user called setallowempty called setonly allowempty=false user called setallowempty called setonly allowempty=true user called setallowempty true allowempty=true user called setallowempty false allowempty=false three relevant states attribute set/true/false use null express attribute set
sorry please forget last comment right skip assigning null attribute fixed
took find would need method
would easier read would blocks like try new sidebandoutputstream -1 max_buf rawout fail accepted -1 channel number catch illegalargumentexception e assertequals channel -1 must range 1 255 e.getmessage
need change +1
sure whether needed harmful get npe oldheadid =null oldheadlog==null look line 724 case anyhow +1
know change already change created merged europes evening/night time let ask questions document javadoc writing new packfile file obvious since refs starting refs/heads still go standard default packfile guess reftrees got additional packfile tests proove new packfile contains right data
naming name confused name let think two independent buffers arbitrary length want check whether prefix first x bytes would expected parameter prefixlen tied buffer check buffers whether least length implementation would expected name like startswith specifiy two buffers first one length want know whether second starts first
could skip checking last entry list options checking i+1 options.size last entry always right position
system property called git_repo -dgit_repo
replacing unnecessary strings also modifying continue adding continue stage 0 think correct want understand better ignoring stage relied fact current path equals previous path changed make code clearer faster something wrong looking pathes happen path.equals lastpath current entry stage==0
old code reached line bee sure entry fresh constructed object therefore length/lastmodified=0 reuse old entry therefore reset length/lastmodified values attributes reused entry like assumevalid updateneeded could reset also
looks good also checked replacing symlink file works
change happen call setstartpoint null rest code handles correctly +1
see comments
really want tests run even fs telling supporting symlinks would propose fs fs fs.detected assume.assumetrue fs.supportssymlinks file file new file trash x try fs.createsymlink file catch ioexception e fail fs claims support symlinks attempt create symlink failed even shorter fs fs fs.detected assume.assumetrue fs.supportssymlinks file file new file trash x fs.createsymlink file
assertion needed anymore
assertion needed anymore
would even test pass work tested ssh //user.name example lima.com gondo lowe grillo example.com:33/some/p ath works great
think also clarify javadoc credentialsprovider get uriish credentialitem currently said p.get return false user canceled request user really canceled request sure whether continuing next provider chain correct implementations different e.g netrccredentialsprovider return false find appropriate entry case continuing next credentialsprovider correct
missing bit code attributes re-visits parents subtree fully processed +2
still get problem last sentence wrong assumption always reference children anymore done subtree agree children corrupted parent resets thats problem still referenced side question manage sharing path buffer entering multiple subtrees level first visit src/main/a fall back src/ visit src/other/b least appending '/b invalidate path entry src/main/a
get processing child could parent iterator reset influence us sentence resetting child look .gitattributes may overwrite path buffer used parent iterator
ok
info took little bit find works tried write test checks .content file really attributes defined .gitattributes thought since .gitattributes parsed .content processed could fail mentioned problem commit message learned 'raw buffer complete tree data structure point parsed far therefore temporary itr treeparser overtake original treeparser look ahead
done
sure eclipse strange ideas formatting code
resource rely assumption inputstream instances autocloseable java 7. java 8 onwards
sorry forget comment 'll propose try-resources block
done
done
done
hmm would like go direction put filter related stuff method addcomand learn little possible attributes filters etc propose something direction
agree would easier read wanted prevent calling getentrypathstring entryattributtesnode path pathes attribute getentrypathstring look soo cheap
done
done
done
changed heap initial size 1k maximum size 1m
done
done calling clean filters done workingtreeiterator similar even addition autocrlf handling still investigating performance effects course want avoid stat'ing gitconfig every workingtree file therefore config also filter commands defined gitattributes cached
done seems help uses jgits quotedstring.bourne added also test
done
done
done
done
done
done
done
done
done
done
done
done
nit trailing space
want add copyright e.g revwalk.java
please look https //wiki.eclipse.org/egit/contributor_guide checking_for_jgit_api_changes_using_api_baseline suggest setup api checks give lot warnings missing since tags etc
replace two lines return getstate key state.set
question
question
yes fault agree
curiosity used info .gitattributes chance get state without info .gitattributes happens line *.txt custom1 src/a/b/.gitattributes file
really done use custom every .gitattributes file say would write unspecified used revert
mention base see git metadata
skip .java
would explain replace map
better good first line commit message lot tools show first line commit message one looks ugly see guidlines https //wiki.eclipse.org/egit/contributor_guide commit_message_guidelines
could changed class returned treewalk.getattributes offers
convenient
nit newline
macroexpander class known yet complete filter block removed
remove comment commit
careful touch lines interested addition newline needed remember reviewers look changed line adding newlines adds noise jgit projects comes formatter settings feed three lines formatter remote newline added
nit newline
good point learned something
makes root tree iterator different lower level tree iterator something special stored root iterator
changes file belong followup request macro-expansion handled
really needed
really needed nothing removing bundle references
sure whether similar problems lot one specific thing code receive ioexception want let bubble instead eat exception continue empty index remember case asked file.exists returned true directly afterwards open inputstream get ioexception strangely filenotfoundexception personal opinion instead assuming rare case two java statements somebody deleted file simply let exception bubble
done
ok got points since transactional issues different change want mix would suggest discuss bug even better jgit mailing list jgit-dev eclipse.org could forward comments list text another forum discuss regarding relevance change noticed change many problems excessive config reads 50.000 files repo whole java process including starting java reading jar files needs 64.000 io calls compute jgit status mainly one stat per working tree file touching config per per working tree file
abstraction already different implementors interface mind
done
done
done
done
done
done
done
done
get workingtreeiterator one responsible read data explicitly workingtree workingtreeiterator one reads attributes support repo workingtreeiterator bare repos even bare repo say git diff b need attributes control diff output determine text/binary jgit even allows try merges bare repos big gerrit use case might need merge drivers defined attributes repository would good candidate accessors read data gitdir global/system-wide files e.g repository.getconfig
think putting treewalk ok. explained calculation effective gitattribues requires looking index workingtree global attribute storages e.g git_dir/info/attributes treewalk seems best place treewalk need reference repository maybe good idea stick abstraction accessor global attribute storage setter accessor treewalk constructor treewalk repository could know repository offers getattributenodeprovider method implemented require caller additionally call setattributenodeprovider instances created treewalk objectreader would require setattributenodeprovider order able read global attributes
please keep
info test testexactrename_unstagedfile succeeds even without change
quite ineffective implementing method explicitly expects fully qualified ref name therefore deal iterating search_path implementation done calling expensive method iterating search_path throw away results see input ref name qualified one maybe internal getref method learn use explicitly given search_path
done
done
done
done
done
done
done
yes convinced especially guess lot hook output transport sent back binary remote host displayed case anyhow know line ending correct 'll propose binary-copy version
also thought longer binary flag changes behavior determines record boundaries runprocess existed change behavior textual line-by-line copy wanted silently change behavior binary copy thing runprocess called hooks filters far see hook scripts really output textual data stdout/stderr copying data textual way changes bytes harmonizing eol hook outputs abc\ndef stdout emit abc\r\ndef copy textual windows platform sure whether need agree want eol harmonization agree binary copies get rid binary flag runprocess called filters textual copy may disastrous filter filters content jpeg file would modify byte sequence 65,10,65 65,13,10,65 want decide change semantics copy binary always would prefer guess also native git
lost close error stream needed
process returns single byte stdout expect null guess null document
chance hide ioexception already closed error stream maybe problems reading stderr want hide even rc=0
would add test path without explicit -- check first path commitid exchanged noticed help page strange always expected -- pathes allowed options -- help page show even program works correctly -- hard comes -- may problem args4j chris vblub14 ~/git/jgit jgit reset -- help jgit reset name val -- path -- hard -- help -h -- mixed -- soft name reset current head specified state -- hard resets index working tree -- help -h display help text -- mixed resets index working tree -- soft resets without touching index file working tree
mean hooktest failing
suggest remove setname master nearly tests whenever want checkout head git.checkout.setstartpoint constants.head sufficient setname redundant needed exception tests want checkout something different head
came patchset 7 anyhow let leave move tests later
propose move test next one change first tests run even without modifications main problem test behavior differs native git native git checkouts would succeed expect exceptions fixed unrelated wanted achieve
strange setting setrecursive true get entries folders chance write tests tests existence empty folder fail empty folder exists unexpectedly suggest enhancement method rebase change upon
think change fixes jgit extend enables git checkout head -- x jgit failing take care delete untracked files git checkout head git normally takes care delete unsaved especially untracked files filesystem native git fail standard checkout branch delete/modify unsaved file content achieve tell git explicitly overwrite/delete certain files git thinks aware loose data would say git checkout -f git checkout head -- x tell git test cases green tests git checkout head -- x case allowed overwrite x thought honest tried contribute test shows concerns could produce one jgit behaved well change thing typically enter checkoutentry really untracked files maybe aware point see native git doesnt delete untracked files unless checkout -f checkout -- path used + git init test initialized empty git repository /tmp/f/test/.git/ + cd test + mkdir + touch d/a + git add d/a + git commit -m 'add d/a' master root-commit d16db8e add d/a 1 file changed 0 insertions + 0 deletions create mode 100644 d/a + git branch side + mkdir d2 + touch d2/b + git add d2/b + git commit -m 'add d2/b' master 34d3eb2 add d2/b 1 file changed 0 insertions + 0 deletions create mode 100644 d2/b + git checkout side switched branch 'side' + mkdir d2 + echo important + git status branch side untracked files use git add file include committed d2/ nothing added commit untracked files present use git add track + git checkout master error following untracked working tree files would overwritten checkout d2/b please move remove switch branches aborting + git checkout master -- d2
one example place see problems inspecting head index merge decide want update path look filesystem check whether name directory call lead call checkoutentry luck stopped conflicts delete files inspected
ca find delete command files checkoutentry regardless whether deleterecursive flag set checkoutentry delete files/folders change methods took care checkoutentry called e.g normal checkout non-path replace file folder file deleted checkoutentry called
extension point also make sense strategies using models need check
imagine logical model support switched jgit already defines default mergestrategy egit hardcode different default mergestrategy happens future jgit implements new default merge strategy forced update egit case currently jgit expose default strategy could fixed easily static method getdefaultstrategy mergecommand
extension point realy usable models active could use extension point implement arbitrary strategies eclipse dependencies
hardcode default mergestrategy
default hardcoded
really add potentially endless loop iterations and/or time spent retrying would expect method gives throws excetion
suggest core.packedrefsretrycount maybe default value 5. could tryout default value helps test cases would say try read packedrefs file 100 times always fails stale file handles ok throw exception course would nice write warning log case
would add new key config_key_packed_refs_stale_retrycount configconstants add getpackedrefsstaleretrycount coreconfig define default value would suggest 1 based experiments access configured value refdirectory use getrepository .getconfig .get coreconfig.key .getpackedrefsstaleretrycount
ok got need waiting times start new round safety net arguments true would harm stop loop 10 retries know nfs implementations good happens platforms persistent stale-file-handle-exception max-retry would safe us endless loop exceptions arise contain stale *file *handle type expect max-retry limit would safer
hit situation would go loop fast possible stale file handle situation corrected know long takes typically stale-file-handle situation resolved expect may take seconds add sleep continue would burn cpu cycles active waiting would allow threads/processes something meaningful
would update javadoc also explicitly says look index bare repo index case maybe best way would look head tree .gitmodules instead examining index
would replace repo working tree
look strange somebody previously calling isignored find whether path ignored guided use method canbeautoignored like new method canbeautoignored imagine future arguments pathes auto-ignoreable fact whether path already ignored resources one argument therefore would like seperate questions isignored canbeautignored suggest update javadoc method saying works existing pathes end think need methods
understand two cases mention left right index inspected play role would mention would simply say method returns false pathes existing files directories
would remove prefix
need since tags new public methods otherwise eclipse projects full warnings please add since 4.1
missing since tag see
yes clearer +1 sure whether see command.setdirectory null call often always simply call setdirectory directory like command.call directory gitdir null default
document branch null anyhow receive nullpointerexception even without change
since nowadays git autocloseable could make use write new tests like try git git2 git.clonerepository .setdirectory ..
get rid try catch block say test expected=nullpointerexception.class test succeed nullpointerexception thrown
document javadoc null allowed
like document null would like modify api settermethods throw explicit nullpointerexception unexpected null given really add extra check without change call clonecommand.seturi null .call receive urisyntaxexception message uri empty null change get generic nullpointerexception also find urisyntaxexception informative
done
done
done
done
done
4.0 yet released go 4.0
trailing whitespace
severe bug thanks good catch
would leave test code like much cherry-pick one line let start making complicated really need wanted understand whether hidden dependency c2 c1 must different timestamps know whether guarantee commits c1 c2 c3 different timestamps testrepository class guarantee control clock real life machine fast enough clock slow enough may timestamp
yes got fine asking little bit unrelated change whether real world test cases testrepository native git commits guaranteed increasing timestamps fast commits timestamp
tick consistent commit requirement see yet
committer cherry-pick default user would consistent native git like commit could use new personident defaultcommitter new date
think really conflict even native git commit wanted cherry-pick deleting lines 2-11 predecessor content additionally modifying line 1 master branch modified line 11. commit cherry-picked commit master touch line 11 conflict git init b initialized empty git repository /tmp/b/.git/ cd b echo -e foo contents\n\n\n\n\n\n\n\n\n\n foo git add foo git commit -m initial master root-commit 23ffd22 initial 1 file changed 11 insertions + create mode 100644 foo git checkout -b side switched new branch 'side' echo -e changed foo contents foo git commit -a -m message cherry-pick side 612dd32 message cherry-pick 1 file changed 1 insertion + 11 deletions git checkout master switched branch 'master' echo -e foo contents\n\n\n\n\n\n\n\n\n\nlast line foo git commit -a -m modify master master 2c24317 modify master 1 file changed 1 insertion + 1 deletion git cherry-pick 612dd32 error could apply 612dd32 message cherry-pick hint resolving conflicts mark corrected paths hint 'git add paths 'git rm paths hint commit result 'git commit' cherry-pick commit would changed foo contents\n\n\n\n\n\n\n\n\n\n everything would ok. cherrypicked commit wants modify line 1 master commit modifies line 11 mergeable
bug jgits merging somehow content merge last line adding newline fixed
would create commit non-default author committer would obvious taking right idents
test 3 lines
commented testrepository class would expected committer name/email also copied
similar problem git repository user testrepository caller testrepository.git clear whether close repo platforms like linux macos care much testcode let gc work windows write tests missing close repository git cleanup phase tests folder hierarchies filesystem deleted fail e.g see commit da595f09 fix would least document whether close get back git convinient add close method
yes true need changed rebased commit
since even index updated also think checkout even reset would fit detached head state otherwise reset would update ref head pointing would call updatehead
done
done
done
done
private revcommit getcommit final reflogentry entry try revwalk walk new revwalk getrepository walk.setretainbody true return walk.parsecommit entry.getnewid catch ioexception ignored return null
following instead complete if-else clause revcommit headcommit null headid null try revwalk rw new revwalk repo headcommit rw.parsecommit headid
done
obsolete description
leave modification revert changes userconfig tests still succeed seems test fails without modification succeeds modification add one
following java classes use message without specififying argument please adapt places also dfsreader line 559 dfsreader line 583 packparser line 1138 protocolerrortest line 165
think loose information file found likely .pack file everything ok. could also .idx file
aware stacktrace contains stack great ok
comment looks strange may call checkoutcommand orphan=true createbranch=false maybe also bug api command check orphan specified nobody explicitly set createbranch false
trailing whitespace
2 3 references repository javadoc link one simple string maybe need one link maybe return class
looks ok line 560-562 buffer filled initial text newline text following stacktrace need \n
whe todo want logging instead writing stderr
gitdir localname set clone repo let repo non-standard layout would simply command.setdirectory localname command.setgitdir gitdir let validation localname null gitdir done clonecommand
would close db
possible npe next line command.getdirectory null cloning bare repo possible specify gitdir
question changed command execution output message purpose maybe wanted use db.getdirectory
targetpath=createtempdirectory target
suggestion testclone
done
correct english sounds strange native git says something similar limit refs/heads something like show refs starting refs/heads would clear
handling timeout anymore
done
thought would overkill clonecommand using initcommand relying exceptions thrown initcommand thrown already tested
done
done
done
done
done
done
done
severe bug wondering unit test found need one
agree 'll disable test removing test tag finally found solution control smudging test enable
jfi assuming cache.getentry string always returns lowest available stage documented like think true ok
clarify checkout really touching file would assert also content file checkout asserttrue read file .startswith head
specific reason change order steps previously first updated files deleted others reversed
would say support dfsrepository garbagecollectcommand know gc
/or/of/
/fail/fall/
changed coding fs.readpipe .. smaller slow
comment test fails windows java7 java.nio.file.filesystemexception c \users\d032780\appdata\local\temp\tmp_7205603528745083091\盲 required privilege held client sun.nio.fs.windowsexception.translatetoioexception unknown source sun.nio.fs.windowsexception.rethrowasioexception unknown source sun.nio.fs.windowsexception.rethrowasioexception unknown source sun.nio.fs.windowsfilesystemprovider.createsymboliclink unknown source java.nio.file.files.createsymboliclink unknown source org.eclipse.jgit.util.fileutil.createsymlink fileutil.java:96 org.eclipse.jgit.util.fs_win32_java7.createsymlink fs_win32_java7.java:152 know touched code
sure whether problem windows boxes clear normal privileges create symlinks even java 7. assume creating links supported ignore tests platforms allow creation symlinks
would fstick f may sometimes wait 2 seconds simply unneeded
fstick call waits long enough next filesystem modification would lead lastmodification timestamp younger modification timestamp f. means makes sure file modified fstick call younger modification timestamp f. needed
introduce later fs_posix_java8 subclassing fs_posix_java7 test would skipped although valid system sh one understand buildin umask command test skipped would org.junit.assume.assumetrue fs instanceof fs_posix_java7 string umask readumask org.junit.assume.assumetrue umask null
done
done
done
done
needed egit wants use indexdiff since change instances indexdiff created higher layers also implicitly indexdiff.diff line 545 implicitly creating instances want give higher layers chance determine kind workingtreeiterator use pure jgit environments e.g gerrit want work filetreeiterators eclipse environments e.g egit want use adaptablefiletreeiterator expect egit instantiates indexdiff instances call setworkingtreeitfactory specifying factory constructing adaptablefiletreeiterator instances
see
done
think make clear get pathes given filemode among files differences found ca use method get symlinks repo get symlinks among dirty files
done
done
done
done
put creation iterator setup method assigned field formatting nicer
named like standard names see http //git-scm.com/docs/git-config
ca fix commit message locally whitespace
done
done
done
done
would mean jgit start handling packbitmapindexes options understood jgit jgit see options understand say jgit simply ignore options understand change ok. say jgit deny working packbitmapindexes unknown options change harmful ca decide
done
agree remarks done
done
minor thing line gives warning eclipse df hiding field would rename local var would go away similar added tests
think misunderstanding maybe first implementation led wrong understanding look javadoc method wait long enough filesystem clock advanced much behind lastmodified time given file lastfile look system clock need compare filesystem system clock deal problems match sketch algorithm f.lastmodified lastfile.lastmodified sleep f.touch comes fault implement f.touch f.setlastmodified system.currenttimemillis intended set lastmodified anything specific wanted touch file instead creating new temp-files run loop would implement touch looked http //stackoverflow.com/a/17840038 touch could implemented opening fileoutputstream full method would look like public static long fstick file lastfile throws interruptedexception ioexception long sleeptime 64 fs fs fs.detected lastfile null fs.exists lastfile throw new filenotfoundexception lastfile.getpath file tmp file.createtempfile filetreeiteratorwithtimecontrol null try long starttime lastfile null fs.lastmodified tmp fs .lastmodified lastfile long acttime fs.lastmodified tmp acttime starttime thread.sleep sleeptime sleeptime *= 2 fileoutputstream fos new fileoutputstream tmp fos.close acttime fs.lastmodified tmp return acttime finally fileutils.delete tmp
forgot .name call line set authorization header read specs also named basic digest
like idea change sure implemented normally getter side effects cheap return either explicitly set setxxx method return something based result last call see checkoutcommand.getresult call nothing expensive happen would suggest implement manner store map determine call field implement getmap getter field would call new lsremotecommand origin .call .getmap
understand restriction need user intervention mean work user intervention required please rephrase
read sentence multiple times think understood maybe replacing disable explicitly explicitly disabling would make easier way disable implicit authentication httpurlconnection
reading commit message expecting much bigger implementation
wondering whether thing could write tests start unit tests git server push/fetch inspect requests server got possible see/test change behaviour introduce look simplehttpserver.java egit pushtest.java
imagine f=null index contains uncommitted subtree change would update overwrite index wo loose uncommited data hand index workingtree differ workingtree null want report error 'll suggest move f==null check inside ismodified
modification covered test remove tests still succeed please add test hand think statement needed mask fdf means files head merge directory index means always directoryfileconflict chance walk.isdirectoryfileconflict false
regarding complaints missing tests right overlooked reverted dircachecheckout modifications run tests maven commandline mvn clean install checkouttest executed skipped know yet anyhow still think need this.how walk.isdirectoryfileconflict true mask fdf need check
argument walk.isdirectoryfileconflict false mask ffd
hmmm current path see files head merge index means three states definitly file/directory conflict also pathes parents prefixes current path see files parent pathes must directories also face file/directory conflict could folder working tree current path parent path walk.isdirectoryfileconflict checking workingtree ffmask ignoring working tree understand better gain change need test
yes
need else block sorrounded previous statement update new statement provide else f =null jump 743 750. blocks meant handle situations nothing head check comments would add explicit else
right go 743 750. whenever entered block sure take decision surrounded decision condition met take decision sure rest method prepared decide explicitly path default action take place remove path index leave working tree wanted
agree change change described javadoc wondering hit test take change replace file dircachecheckout.java previous version new tests still green seems need modification dircachecheckout.java let tests succeed add tests cover modifications file
'replace file file mean took test bugfix commit predecessor change renamed comment modify file
called 'symlinka test create symlinks took test bugfix commit predecessor change changed variable name filea
sense test test something different previous test testcheckoutwithmissingworkingtreefile think delete one
missing since tag see things eclipse follow https //wiki.eclipse.org/egit/contributor_guide checking_for_jgit_api_changes_using_api_baseline please add tag since 3.4
would simplify merge strategy use rebase operation would javadocs setstrategy introduced
missing since tag see things eclipse follow https //wiki.eclipse.org/egit/contributor_guide checking_for_jgit_api_changes_using_api_baseline please add tag since 3.4
missing since tag see things eclipse follow https //wiki.eclipse.org/egit/contributor_guide checking_for_jgit_api_changes_using_api_baseline please add tag since 3.4
think new rebasecommand repo cheaper new git repo .rebase one object instantiation less equivalent would roll back 4 places
added instantiate new git object
question new git instance
need additional git instance
forgot one
missing since tag see things eclipse follow https //wiki.eclipse.org/egit/contributor_guide checking_for_jgit_api_changes_using_api_baseline please add tag since 3.4
maybe upon time somebody thought putting two lanes position hashtable bucket would wise idea anyhow nice get rid implementations hashcode equals +1
bugzilla bug explains remove went int see https //bugs.eclipse.org/bugs/show_bug.cgi id=365460 konrads change need anymore
wonder code think chance color.equals part contributed outcome nice get rid
ca password length 0 even user think would secure credentials invent egit restriction user password must non-empty
although http basic authentication scheme supports user password length 0 empty string see 1 think egit ok insist non-empty values maybe cleanest solution would add checkbox ui named anonymous access need something like differentiate situation user entered credentials wants access server without user password anonymously situation user wants explicitly contact server empty password and/or user adding feature go another change suggest rename method isempty 1 http //www.ietf.org/rfc/rfc2617.txt end page 4
hmm attempt 5 even 4 authattempts false try evaluate authmethod.authorize uri credentialsprovider try last time problem sure intendet authorization tried even authattempts 5. old code said 1 authattempts meant max 2 attempts connect one without credentials one ask credentials provider 4 means try max 5 times
matthias forget comment misread code
would wrong always reset authattempts 2 authorization failed always good reset credentialsprovider given wrong credentials last time imagine attempt 1 without credentials auth fails attempt 2 credentials provider provider got credentials secure store auth fails reset credentials provider let forget data secure store attempt 3 credentials provider provider asks user user enters wrong credentials sets option store secure store authorization fails since attempt 2 reset provider attempt 4 credentials provider provider use credentials failed already last time
test related feature let want understand whether feature influences situation
writing content file call change content crlf.txt maybe updates last-modified time ca sure filesystems long timer-ticks maybe filesystem timer increased since last time wrote file would vote either dropping line adding fstick call wait sure filesystem timer increased like file f writetrashfile crlf.txt some\r\ndata\r\ntoo\r\n line 285 fstick f writetrashfile crlf.txt some\r\ndata\r\ntoo\r\n fstick may lead runtime multiple seconds test linux maybe simply drop line
first glance change looked suspicious change comparing method worktree file change introduce comparing different state compare worktree file index second look look bad cases index would always case change would ok. method called processentry make sure line 404 index matches index missing index missing construct fake dircacheentry assign ourdce fake entry length objectid content created different settings autocrlf expect issues case see change makes things worse definite situations change improves situation +1 change look comment tests
theoretically also reader could null look line 806 deprecated method know may still used could cause end reader==null would add reader null repository null get reader repo objectloader open reader null reader.open entry.getobjectid repository.open entry.getobjectid reader repo null luck
overlooked comment googles gerrit instances think use dfsobjdatabase able make use documented
mention implementations jgit objectdatabase work java.io.file return something different null suggest works fileobjectdatabase dfsobjdatabase see different implementations packparser.parse dfspackparser return always null instead packlock instance objectdirectorypackparser use constructor modified change
done
done
done
done
done simply copied existing test open change 22160 comments apply alot thests
done
done
done original test copied change 22160 javadoc saying replace file file consequently first removing file readding took changed javadoc forgot remove 'git rm maybe hidden value first deleting index readding could find good reason alex robin overlooked something
done
done
sure whether problem exposing raw byte array outside world prevent path modified externally e.g dircacheentry e= .. e.getrawpath 0 a' could really break lot stuff getter methods return immutable objects like string either accept risk use different solutions like returning getrawpath copy array performant solution
s/turs/turns/
also check file still exists successful merge operation tried delete parent folder file make sure file survived fix looks good
java ee kepler service release 1 maybe eclipse old wrong edition
easy solve download http //download.eclipse.org/egit/updates-3.2/org.eclipse.egit.repository-3.2.0.201312181205-r.zip unzip eclipse preferences plug-in development/api baselines add baseline location folder unzipped downloaded file
unrelated change please leave lines untouched
optional took quite time understand check check specify orphan pathes allowed
space '= intended
think algorithm work wondering whether really efficient way block reading parts content 3 times first rawtext.isbinary read first 8 kb reading complete file compute resulting length finally reading third time eolcanonicalization previous step comput sha1 content would inputstream would eolcanonicalization arbitrary length stream could save one round reading file inputstream implementation would throw exception detects file binary could save another round reading content would big performance boost guess could also different change think fix
would also make use cached basecommitid something like replacing previous line revcommit basecommit basecommitid null walk.parsecommit basecommitid getbasecommit sourcecommits 0 sourcecommits 1
looks buggy method may called subclasses merger often want arbitrary commits case result method may intermediate commit merge base used overall merge would rather make getbasecommitid abstract let non-abstract implementations merger incore- resolve- recursivemerger decide found overall merge base
want add a/b
miss something moment index contains file content new hello world workingtree contains checkout branch also contains file exactly content fail
remove trailing blank
remove trailing blank
remove trailing blank
remove trailing blank
discussed since explicitly putting something cache class feel responsible remove repositorycache seems internal cache used jgit server side transportlocal daemon
done
done
done
done
done
correct overlooked
lines contain tabs spaces could stay comment lines even without hash lines start would prefer fix throw exception fulfilled document requirements javadoc
done
done
done
done
done
typo fixed
done
changed spaces tabs
done
yes could done idea propose new proposal change
done
done
done
done
done
done
done
right could move implementation different class keep repository class smaller still would like two methods readrebasetodofile writerebasetodofile repository class whenever read write file .git filesystem hierarchy start searching repository class read/writecommitmsgfile read/writeorighead read/writemergecommitmsg good examples motivate 'll make really non-static obvious related repository currently caller specify java.io.file expect point inside .git directory repository 'll substitute file path string meant relative repos .git folder
done
non-comment line converted comment line generate comment latest proposal hopefully loose much data
done
done
done
done also added test
first thought valid comment think would deal comment lines would check comment lines would fail two lines check line contains commit id would mean current tests bad recognize rebasecommand ca handle comment lines would severe bug tests thing deal comments know already filtered readrebasetodo call specifying want see comments
care comments 'll leave line otherwise get warnings eclipse incomplete switch statements
done
gives warning eclipse settings javadoc protected declaration
'll nee javadoc tag return value parameter thrown exception
'll nee javadoc tag return value thrown exception
text externalized please look checkoutcommand.java throw refnotfoundexception would enter text jgittext.java jgittext.properties
text externalized please look checkoutcommand.java throw refnotfoundexception would enter text jgittext.java jgittext.properties
need store attribute commit make use
really call carry walk commit sure
please add add comment non-nls-1 mark string literal non-translateable
objectid c4 git.merge .include c2 .call .getnewhead skip call head
see comment
could return git.commit call .getid instead calling head
think need method
using low-level api fight lot technical details checking clean working tree finding latest commit touches file underneath path 2-liner may lines error handling look method args 0 =path git repo args 1 =path interested e.g src/abc public static void main string args throws ioexception gitapiexception jgitinternalexception git git git.open new file args 0 git.status .call .isclean throw new illegalstateexception repo state clean revcommit commit git.log .addpath args 1 .setmaxcount 1 .call system.out.println commit touching path +args 1 + repo +git.getrepository + +commit.getid
please keep diff small avoid adding extra newlines guess eclipse adding extra lines right
skip newline
done
describe param tag right important mention also done
done
done
done
done
done
done problem /trashdir/ testrepo/ .git/ symlink /trashdir symlink pointing parent directory cause problems recursive deletion hierarchy want fix change instead changed /trashdir/ repos/ testrepo/ .git/ symlink /trashdir/repos
done
done
done
done
revwalk creation done differently see comment
done actually sure whether important call dispose revwalk instances call parseany guess important typical revwalk walk lot objects revwalk caches objects file found 3 occurences created revwalk one call forgot changed way use one revwalk instace whole class make sure disposed end
good idea done
need set haschanges true anyhow set leave clause
line inside clause like haschanges true working tree empty wtiter always null modifications wtedits therefore haschanges false
good example stackoverflow discussion file x renamed one branch another branch z. merging branches get conflict one conflict three conflicts one x one one z one conflict find kind conflict looking index state see both_deleted combination added_by_us/added_by_them learn kind conflict both_deleted sufficient understand conflict get wrong like both_deleted names would call conflict type
enum represents status index certain path regarding stages stages exist path would rename stagestatus stages something like better name problems conflict type called both_deleted deleted fine reason for/type conflict argument goes added_by_us added_by_them describe situations expect conflict besides like idea publish stagestate
style blanks around would nice
replacing every character lesser '/ '/ ignoring differences path characters '/ characters '\ may path e.g + filter initialized pathes abc/ abc abc work
old max already ended '/ would end new max ends '// right maybe ok sure
sorry robin english good enough understand sentence know mean could rephrase sentence
sure right saves stat call done
sure far see f.delete fileutils.delete f 0 similar besides one returns false throws exception case would like use method returning boolean mean need fileutils.delete f retry agree
yes agree somebody thought files belong together xyz.pack xyz.idx folder xyz/pack xyz/idx maybe atomic renames easier rename single filesystem entity although hope rename mess windows becomes easier deal non-empty folders
still worrying true also much better eyes without fix always ended repo loose objects packfiles rename fails method returned null instead throwing exception means caller packfile written later deleting packfiles outdated deleted existing packfiles except newly written since packfile written rename files packfiles got deleted get corrupted repo always rename fails somebody pulls plug loop
done
text rewritten
text rewritten
method deleted
method deleted
would call getstatistics fit javadoc call properties would think properties instance garbagecollectcommand
done
done
sure sufficient agree empty dir working tree prevent merge thought case base contain nothing path p/x worktree contains folder p/x contains file p/x after/during succesful merge want update working tree file p/x fail location folder p/x exists maybe need test
ok got problem confused commit message says gc class even call prepareindexbitmaps non-full-closure-packs
aware reaching line also packs contain full closure object graph gc writes potententially two packs one containing objects reachable heads one remaining objects e.g reachable tags least commit message makes think want called full-closure-packs
add inqueue 0
agree decided introduce nomergebaseexception enum describing merge base could determined
really work filesystem based index great get lot tests free parametrizing resolvemergetest run tests resolvemerge subclass resolvemerge recursivemerge first attempts run resolvemergetests recursivemerge look promising
right would also like use better jdk topic include proposal
wo compile jdk 1.5. contributor guide egit/jgit still stays java 5.0 eclipse 3.5 minimum requirement avoid references newer java versions get around writing copyof class jdk 6 implements public static copyof original int newlength return copyof original newlength original.getclass public static u copyof u original int newlength class extends newtype copy object newtype object object .class new object newlength array.newinstance newtype.getcomponenttype newlength system.arraycopy original 0 copy 0 math.min original.length newlength return copy
see
see
following method unused please remove
parameter cleanup unused please remove
accessing firstcommonancestor.name potential nullpointerexception firstcommonancestor may null
need calldepth clean would remove variable later simply call return mergerecursive 0
'll forget unlock dircache mergerecursive exists ioexception would use try/finally block make sure things locked getting unlocked end like resolvemerger.mergeimpl
need clean would remove variable end simply call return mergetrees
need mergedcommonancestors remove variable usages
proposed change 8372 makes resolvemergertest beeing capable run tests agains multiple strategies would rebase proposal top 8372. add resolvemergertest line datapoint public static mergestrategy recursive mergestrategy.recursive run tests strategies additionally need tests tests specifiic features recursivemerger would create new class recursivemergertest create test test specifics create new tests would simply copy paste code fragments recursivemergertest make sure test edges multiple merge bases merge-bases conflicts occur producing merge base
finally come reviews real coding george understand handling parameters h1 h2 method parameters never changed method save saved_b1 saved_b2 restore later would simply remove variables saved_b1 saved_b2 usages really need tests ensure statements correct
regarding handling calldepth instead f int calldepth calldepth++ f calldepth calldepth -- would use f int calldepth f calldepth+1 calldepth properly decremented return f
really clear index ca use existing one use temporary index imagine end recursive merge succeeds finally update 5 files repo 200000 files thrown away index example stores lastmodification times 200000 files know anymore 200000 files dirty read populate new index
asking whether need logic regarding protecting working tree call mergerecursive calldepth=0 want merge also update working tree files merge result call mergerecursive calldepth 0 intermediate merge done create good temporary tree serve merge base end maybe want persist tree definitely want update working tree creating temporary tree whenever call mergerecursive calldepth 0 make sure persist anything filesystem/objectdatabase
overriding method getbasecommit inherited merger.java therefore using default implementation throw ioexception find one common ancestor breaks mergecommannd.call important api jgit mergecommand.call calling getbasecommit populate mergeresult succesfull merge although recursive merge succesfull getting hit ioexception call finally fails override getbasecommit throw ioexception find one common predecessor proposed different implementation next patchset
loop strange final result stored ca resulttree somehow thought run loop every iteration merge one new commonancestor constructed far constructed far stored resulttree always merge new commonancestor never-changing firstcommonancestor statement matter many commonancestors look like end resulttree always contain result merge first last common ancestor intermediate commonancestors ignored ca ok
comes one problem imagine running gerrit environment bare repo without index construct recursivemerge instance new empty incore index instantiated stored this.dircache reach line 395 index filled finally contains state newly calculated mergebase reach line 415 start mergetrees mergetrees look given trees also take index account git merge algorithms assume index based first tree analogy git command line assume index based head always first tree whenever first tree index differ merge assume dirty index stop reason test lowlevelbarerepo_crisscrossmerge fails make sure reach point index set h1 content index filled calculation merge base dumped
extending enum first idea ca java enums final design anyhow suggested drop enum completely used anymore
done
currently written filesystem know make sure commits always found merges done deeper recursion referenced nevery transported gc delete especially server environments gerrit flaw proposal
done
done
need tw would leave private also remove comment
need t_base would leave private also remove comment
need t_ours would leave private also remove comment
need t_theirs would leave private also remove comment
need t_index would leave private also remove comment
need t_file would leave private also remove comment
need builder would leave private also remove comment
need unmergedpaths would leave private also remove comment
need modifiedfiles would leave private also remove comment
need tobecheckedout would leave private also remove comment
need tobedeleted would leave private also remove comment
need mergeresults would leave private also remove comment
need failingpaths would leave private also remove comment
need entersubtree would leave private also remove comment
need workingtreeiterator would leave private also remove comment
see comments mergetrees change accordingly
need createdir would leave private also remove comment true methods coming changed private protected need would leave
wanted pure refactoring without modification sematics changed sematics proposal next lines ioexception thrown dircache.unlock called anymore original code called finally clause severe bug solution easy refactor lines inside try block new method called mergetrees leave callers mergetrees handle exception cases resolvemerger would call try mergetrees finally dircache.unlock recursivemerger since currently care dircache unlocking simply call mergetrees
would put try/catch block inside method let method throw exceptions let caller handle exceptions already two users method different needs regarding exception handling therefore better let callers handle exceptions
need change method signature would leave private method
need change method signature would leave method private
need change method signature would leave method private
need change method signature would leave method private
need change method signature would leave method private
need change method signature would leave method private
need change method signature would leave method private remove javadoc private method handle robins comment
need change method signature would leave method private remove javadoc private method handle robins comment
need change method signature would leave method private
need change method signature would leave method private
need change method signature would leave method private
need change method signature would leave method private also remove javadoc
need change method signature would leave method private also remove javadoc
complete change needed exactly thing sides if-clause.i would simply remove change file
got point suggest run simple algorithm first succeeds run expensive one agree question put loop merge strategies somewhere add either recursivemerge callers merge merge.java mergecommand.java even higher code using jgit think like native git call git merge sidebranch even clue merge-strategies exist therefore suggest put loop either merge.java mergecommand.java recursive merge want
maybe want add also strategy default one classes merge.java mergecommand.java
comment still unanswered somewhere put code decides whether use recursivemerge resolvemerge cases higher layers explicitly set strategy use also native git merge.c trying different strategies similar probably mergecommand.java
happens cachelastmodified 1000 dfferent null getoptions .getcheckstat checkstat.minimal filelastmodifed cachelastmodified would unnecessarily cut filelastmodified make different cachelastmodified
oops robin think lost changes int last patch-set please compare patchset 2 vs 4 2 vs 5
please remove trailing whitespace
please remove trailing whitespace
please remove trailing whitespace
basedci.isassumevalid sufficient previous line know already basedci.isassumevalid equal newdci.isassumevalid need check values
would vote calling gc help people search commands know native git would like close native git naming possible reason called rm renamed remove lsremote vs. listremote remotelist
trailing whitespace
would say neither considered s/or/nor the/ s/is not/is/
see
method thas undocumented feature supports null values lastfile see 3 lines also line 705 gctest.java fstick null simply wait sees filesystem timer advance proposal break gctest either change lastfile null lastfile.exists add javadoc happens lastfile null alternativly could add fstick without parameters make explicit wait ticks without specifying file compare
would use getfullbranch method use getbranch additionally shorten refname feature need additionally shortening ref names lead problems two refs .git/xyz .git/refs/heads/xyz checked .git/refs/heads/xyz
utility method fstick wait tick filesystem timer write file1 content4 fstick wait see filesystem timer jumps write file1 content4 good think windows runs much faster code
delete line containing setlastmodified fstick +write file1 content4 replacement original asserttrue file1.setlastmodified
retreat attempts improve test avoiding setting lastmodified file1 date future work currently running test situations create new file e.g new temporary index file caused git.commit .*.setonly files like file1 younger lastmodified newly created file would like avoid since able fix without rewriting test much suggest go back changeset 1 robin fix specific problem 'll propose different version test later
robin take authorship intentionally mistake least small also-by would nice
intentional allow specify annotated tags refs collection thought method like 'git branch -- merged linux repo say 'git branch -- merged refs/tags/v3.5 jgit maybehead would revtag object would ignored
would move block 5 lines directly call contentmerge makes clearer thing preventing attempt content merge submodules current place obvious next thing would try content-merge
comment files marked removed index exist say 'git rm -- cached f.txt entry f.txt simply removed index trace anymore existed index
think found severe typo javadoc comment iirc wrote table first coded based table case 3 wrong say use suggestion keep fail correct wondering happened checked jgit history even history native git documentation maybe wrongly documented point time ca find better explanation typo much elaborated table used also development contains right data case https //docs.google.com/spreadsheet/ccc key=0ask8ntwp7sxedeliqwg3bglinenungtln0lqyvzvsfe authkey=cjn1mc4 seems used wrong javadoc comment implementing
sure case 4. conflict try git init mkdir touch d/b git add d/b git commit -m adding d/b git checkout -b side echo foo d/b git commit -a -m modifying d/b git checkout master git rm d/b touch git add git checkout side
keep result case 4 'update dircachecheckout modfied documentation keep result tests check conflict think sematicaly correct result case 4 conflict agree please correct javadoc dircachecheckout
done
done
files persisted loose objects would also wrong propose files used persist loose objects
done
done
done
good catch cut paste bug loops setting adding multiple parents could skip checking first parent bug 'll fix
sure
really thought future become complete gc inspecting also native git implementation saw 're name mentionend oft based came 5 steps gc planned implement ok 4 steps rerere_gc come soon class grows big enough reasons come steps beeing available classes split split repack class course wanted stay one class
done
done
done
done
done
done
yes also stumbled tests cases used bare repos beginning led empty treewalk aioob exceptions fixed
got renaming old files first temp files first guess long running gc works repo accessible consistent would rename old packs temp files would vanish git processes leaving repo consistent referenced objs found guess better write temp files rename valid files end renaming could delete uneeded pack files
replace packfile created packfile id x objectrepository already contains cached packfile id x cached packfile cached index data equivalent produced newly problem update pack indexdata atomically
done
yes prunes loose objects git-prune one wants get rid unreachable packed objects git-repack used right end want get rid old pack files maybe go repack method
right method currently native git command git-prune-packed 1 'll propose nex propoasal rename prune_packed 1 http //linux.die.net/man/1/git-prune-packed
done
yes course fetch_head come repo.getallrefs utility method refdatabase.getadditionalrefs 'll use also
sure whether got right mean allheads contain refs live alternate-repos heads pack right
agree could also pack everything one pack copied strategy dfsgarbagecollector splitting objects two packs one objects reachable branches another one rest objects reachable tags reflog case gerrit servers may quite lot second pack old proposals never got accepted imagine sure certain performance benefit deal packfiles huge contain everything packfile likely contains objects needed operations like submit merge
yes 'll change repo.getindexfile asked currently support setup repo.readdircache repo.lockdircache throw exceptions bare repo regardless whether index file think different bug
sure think currently supported feature packwriter
since want expose multiple methods prune repack packrefs class since class complicated state offer methods public static methods
done
done
done class grew greater need non-static methods
wrote two currently truth since size parameter right gc business know man packfiles packwriter write 'll remove two
called expireagemillis sasa requested add term age know specify timespan system.currenttimemillis returns
ok good point 'll go 'long expire expressing number milliseconds elapsed since file modified like date refers certain point time native git accepts timespans elapsed consider files pruning
done
done
ok found problem calling objectwalk.checkconnectivity solved problem
currently work reliable method prunes many objects asks objectwalk lookupornull whether knows certain objects null returned assume object unreferenced shown assumption wrong keep working
understand correctly check right 'll simply remove check expect lower layers determine requested index version
done
done
call file.createnewfile pack index know packfile name already exists directly leave method creating new files check already proposed mistake went follow-up change 5055. reorganized two changes
done
currently write new pack files already exist name pack file tell objects create pack file see exists already create reuse old one think change behavior different gc config parameters e.g pack.packsizelimit pack.compression may cause result repack different although pack set objects 'll change comment new pack files change code accordingly
done
'll rephrase
done
done
done
done
done
done
yes course done
done
fixed trying load object deleted associated file fail missingobjectexception remove object cache
done
done
done
yes got similar comments colleagues tried windows 'll close packfile
interesting argument never thought reason also add oldid make sense done
done
ok think understand part problem problem current code even worse let see whether got first packwriter heads told start a. pack b q second packwriter non-heads told start r stop traversing sees object allheads code would write r q q also written twice right anyhow 'll fix exposing index files packs calling excludeobjects
wrote test checks new behavior old code test fails misunderstanding thought start walk objects want stop walking see object learned also objects real starting points walk carrying uninteresting flag children done
done
yes know unpacking objects moment missing feature accept gc without feature know without unpacking expiration time packed objects packed objects pruned immediatly hand expiration time save new objects created current gc run objects packs old enough pruned
done
done
yes agree commented already patchset 10 matthias comment gc change always writing new packs course implies write temp files come subsequent pachtset
done write temp files
tried user java.nio.filechannel.force method flush modifications disk force method guarantees modifications done filechannel methods flushed disk guarantees modifications done associated outputstream means add methods packwriter.writepack packwriter.writeindex accept filechannels instead outputstream done intention
added todo getting late
done
done
took consume comment agree assume small number loose objects collect first make sure go expensive objectwalks loose objects left rewrote prune optimized cases mention thins found complicated although refs point objects last repack may new entries reflogs e.g somebody checkout old state switched back originial branch afterwards reflog entries save loose objects although refs changed index entries checked always
done
understand delete pack files .keep file alongside repack objects pack files pack files exist currently ongoing transport operations transport operation fails pack files may deleted right harmful objects pack files next gc get rid objects
understand yes important feature huge repos internally teams working 17gb repo size bare repo 'll need feature delete pack files .keep file already latest patchset 'll introduce repack objects packs .keep file
done
done
done
done
done
done
done
done
done
done
done
done
done
done added utility method packfile
done
oh right know thought support bare repos index anyhow remove comment think code still ok
done
done modified suggestion adding extra check npe expression treewalk.getobjectid 0 .name
done little bit strange since temporary pack files created createtempfile always create care exceptions temporary idx files computed name may hit situation file already exists
done
searching easy way close filehandles hold packfile could find good way even packfile.close seem close randomaccessfile also better solution allow repacks windows
done
done
still problem changed coding temporary pack files created createtempfile temporary indexes named similar associated pack files therefore think two threads work two different set temporary files comment ok code really problem describe next patch set vulnerable anymore
done
done
done
done
done kept one set parens around comparison find easier read
done
done
agree 'll change list string
done
done
done
done
done
done
done
wanted hide functionality normal usage enough experience trust putting debug package wanted express yet command everyday usage enough experience trust planned move debug pgm
done
done
care reflogs currently reflog handling come ignore reflogs writing tests
done
done
done
done
think simply copy previous index entry case brings nothing new minimal especially avoid filesystem access theoretically could even index different working tree file copying metadata file index entry would wrong
uff right severe bug frustrating although 3 people reviewed although spent much time writing big test much time fix course although tested advance real-world-non-jgit developers using egit merge although happened basic use case work merging two unchanged subtrees trying fix wanted write test captures bug found hard reproduce repos real index merging egit people start c clean index working tree entry entry index therefore fall code block guarded index null gerrit always working in-core in-memory index initially always empty think nobody detected advance
please remove trailing whitespace
right trailing whitespace description afterwards
would add check resulting commit one parent important fix
would also add somewhere test commit command delete squash_msg file succesfully commited commit command delete file nobody every commit prefilled commit message listed int sqash_msg
comment thought little bit whether ok report non-null newhead merge command new commit also touched head report something newhead failing merges also report null newhead already_up_to_date case also report old head newhead also javadocs mergeresult.getnewhead vote youre proposal ok
want spent new mergestatus users api e.g egit jgit-pgm may want decide mergestatus report end-user e.g egit detect mergestatus whether head moved already_up_to_date vs. merged|fast_forward actions may triggered decoration report merged status give higher layers chance act properly
would refer either merge man page explain little bit prepare next commit index working-tree guess lot users missinterprete know squash option interactive rebase different results
think something important missing merge command prepares text next commit message parents next commit writing .git/merge_head .git/merge_msg files 'git merge -- squash want explicitly next commit prepared command merge commit two parents also commit message prefilled text standard merges writemergecommitmsg writemergeheads previous two lines configured depending squash flag add tests check git merge -- squash fails due conflicts subsequent call commit resolving conflicts right number parents right message check script rm -fr .git git init echo initial readme git add readme git commit -m create_readme git checkout -b side echo initial b git add b git commit -a -m added_b git checkout -b side2 head^ echo added_b2 readme echo initial b2 git add b2 git commit -a -m added_b2_and_modified_readme git checkout master echo added_c readme echo initial c git add c git commit -a -m added_c_and_modified_readme git merge -- squash side git commit git merge -- squash side2 echo mergeconflict readme git commit -a
regarding merge_msg/squash_msg right write squash_msg like native git change-set write squash_msg writes exactly content non-squash merge wrong write different texts depending whether squash merge regarding merge_head squash_head would make sense see sign merge_head trying script native git exactly problem write file merge_head squash merges changeset writes write merge_head somebody touches repo native git simply calls git commit would end standard merge commit suggest something like squash repo.writemergecommitmsg mergemessage repo.writemergeheads arrays.aslist ref.getobjectid else repo.writesquashcommitmsg squashmessage squashmessage writesquashcommitmsg implemented squash_msg file must also interpreted everywhere parse merge_msg especially commitcommand
curiosity changed assertion
compare gerrit webui patchset 4 patchset 3 see forget -- latest patchset contains diff base version ok
oops sorry forget said mixed things together wrongly indeed smudge entries mark cant trust timestamps setting length 0 modification timestamp means test ok. sorry
ok index entry modification time 0 feature nut bug entries called smudged mark ca trust modification timestamp anymore detect dirtyness file imagine create file add index modify two ticks filesystem timer file index entry index file .git/index lastmodifed date handle tell file modified although index entry local file timestamp git solution described 1 set modification timestamp 0 smduge force content check next time check file dirtyness e.g checkout reset status content check happens time filesystem timer finally poceeded find content modified unsmduge entry last part something gues correctly 'll copy mailing list 're thread speeding reindexing let furhter discuss
sematically wrong copy files modification time index entry file may dirty updated since last added index therefore file index entry modification time different timestamps
wrong index entry filesystem may differ content modification time ok blindly copy filesystem modification time index entry let dicuss ml
great think found yes safe know file content index safe copy files modification time index entry would like change keep signature way telling keep say want entry entry reused unmodified saying keep telling want modify entry looks strange could instead simply update index entry give keep like dircacheentry entry i.getdircacheentry f null e.getlastmodified 0 e.setlastmodified f.getentrylastmodified keep entry remove modifications keep keep -callers ask explain checkout without head e.g rebase clone reset reach state modification timestamps 0. initial problem find
one blank line much
wrong workingtreeiterator workingtreeiterator instance given us initialize treewalk whenenver treewalk goes subdirectories new instances workingtreeiterators created changed code right iterator passed method
test work windows following cherrypick fails set core.filemode true means really look executable bit changes fail differences flag index worktree produce difference flag set executable bit true index call db.getfs .setexecute fail windows wanted set core.filemode flag false instead test would succeed
trailing whitespace
trailing whitespace
trailing whitespace
like proposal robin think remove redundancy points subclasses gitapiexception may thrown specific command important like every api user know specific checked exceptions occur 20 gitapiexceptions commands throw javadoc signature makes harder overlook difference javadoc javadoc signature programming eclipse eclipse helps handle relevant exceptions written call jgit api trigger quick-fixes ctrl-1 eclipse automatically create catch clauses exceptions signature described possible exceptions javadoc quickfix create catch gitapiexceptions course fix javadoc signature match please add transportexception signature
trailing whitespace
trailing whitespace
s/calleri/caller/
trailing whitespace
trailing whitespace
need check invalid pathes also
also think better trigger path validation want touch local filesystem checked dircachecheckout found following places adapted checkoutentry /* important */ docheckout /* trying delete files 'removed set calling mkdirs parent-dirs updated files */ removeemptyparents cleanupconflicts
test checkout head yet set kind checkouts e.g clone first checkout also add test standard dircachecheckout happens e.g commit would simply second commit refs/heads/master tries add malicious pathes completely different code dircachecheckout executed worth tested
checkout commit meant create second commit object check changed line 518 https //git.eclipse.org/r/ /c/4617/12/org.eclipse.jgit/src/org/eclipse/jgit/dircache/dircachecheckout.java covered tests line called much often line 309 provided test simply create another commit bad content check cover important line dircachecheckout head null non-trivial checkout
looks ok took time investigate think change correct
every test package test commands enter cli repeat name command class names simply call branchtest avoid developers two equally named classes workspace potentially navigate wrong one
two classes different packages similar things name avoid misunderstandings would rename clirepositorytestcase
rename argument let call commitandlogtest
add reference bug 359111
sorry beeing late review look mode changes difference working tree index executable bit set
change done intentionally
done
please remove trailing whitespace
two checkoutconflictexception classes org.eclipse.jgit.errors.checkoutconflictexception used internally jgit user using api org.eclipse.jgit.api org.eclipse.jgit.api.errors.checkoutconflictexception checkout exception thrown api org.eclipse.jgit.api since using api ideally use exception org.eclipse.jgit.api good example look like mergeoperation.java line 120 seems bug mergecommand.java throws org.eclipse.jgit.errors.checkoutconflictexception instead org.eclipse.jgit.api.errors.checkoutconflictexception maybe solve first change http //egit.eclipse.org/r/ change,4178 addressing yet accepted 'll try trigger change solves problem
change wanted trigger take time api change come new major release therefore suggest fix like proposed check e.getcause returns back org.eclipse.jgit.errors.checkoutconflictexception propose +1 fix style nit curly braces
replace 5 lines writetrashfile a.txt content1
got overlooked exit loop leave comment required
htree null mean htree null e.g new repo trying first commit master always believe processing non-empty commit htree null nothing added index would expect emptycommit true
commit message say need method able delete lock file retry failing operation would safer call classes unlock method instead method also tries delete lock file looks cleaner add static unlock file f method expose file file hand things e.g changing content rename need may harmful
would call class maxcountrevfilter implicitly clear works commits similar authorrevfilter
done
done
done
removed
done
yes course right conflicts content either contents equal conflict-free mergeable avoid reporting conflict mode changes happening one side additionally create new content content merge decide filemode new file revision also better solution picking first filemode find getfilemode 'll propose fix
done
trailing whitespace
confused name 'reserve nothing beeing reserved flag true something like escapereservedchars would clearer
done
done
thanks done
done
length 1 wrong cases
really severe api change break many users repository.java know class gitindex marked deprecated long time remove deprecated code belonging api inside release wait next major release
throw away tests tests dircachecheckout
allowed remove public methods inside release
code compile jdk 1.5. string.getbytes charset came 1.6. wondering hudson letting hudson builds also configured run 1.6
agree currently correct
change indention correct previous patchset
half table indented purely spaces case 10 cases 11-17 use tabs 18-19 use mixture sugguest use pure spaces
understand first two paragraphs tanks clear idea third paragraph objectinserter already writes temp files renames change aims deferring rename flush hit limit number modified files mass-renames os java performance gain proposed change increase propability consistent object store case buggy crashing clients
course questions understanding running jgit top traditional filesystem need right relevant inserter objectdirectoryinserter flush nop
easy pass inserter merger constructor propose add needed objectreader also
could explain failing test currently one hint change course adds execution workingtreeiterator.initrootiterator want also changes use use repo.getfs instead fs.detected
locale localelocal first
would use repository.getworktree leads directly directory want without getparentfile would also throw appropriate exception instead displaying wrong data called bare repo
change good robin could update commit message remove rfc better description accept
good catch also think bug keep index entry reproduced native git see removes index entries cases echo 1 git add git commit -m first master root-commit 90b3be1 first 1 files changed 1 insertions + 0 deletions create mode 100644 echo 2 b git add b git commit -m second master 67f8760 second 1 files changed 1 insertions + 0 deletions create mode 100644 b git ls-files -s 100644 d00491fd7e5bb6fa28c517a0bb32b8b506539d4d 0 100644 0cfbf08886fca9a91cb753ec8734c84fcbe52c9f 0 b echo 3 b git add b git ls-files -s 100644 d00491fd7e5bb6fa28c517a0bb32b8b506539d4d 0 100644 00750edc07d6415dcc07ae0351e9397b0222b7ba 0 b rm b git read-tree -m -u head~ git ls-files -s 100644 d00491fd7e5bb6fa28c517a0bb32b8b506539d4d 0
good test called testxxx
place add stuff 'ignoredpaths inside block enter find entry index files listed .gitignore added index git init echo git add git commit -m initial echo b b git add b echo b .gitignore processing b dm would different 0 although b ignored
two local variables wi workingtreeiterator pointing workingtree tw let use 'wi move initialisation place first need
maybe add comment explaining root folder ignored folder hierarchy reported a/b/c listed .gitignore expect a/b/c/d/e/f reported a/b/c reported
make consistent comments methods agree opinion would precise would call tree want checkout case course modifiy several places file
full test persisting unchanged index fire indexchanged event would also add test uses dircachebuilder quite easy detect dircacheeditor edits change index builder creates new dircacheentry instances happen content much demanding suggestion previous test testbuildonefile_commit_firesindexchangedevent add block end create builder add new dircacheentry values commit throw event
found dircacheeditor edit persist index commit detects nothing unlocks index therefore test good
sure called instead
done
done
done
done
done
done
done
done
whitespace error
removed rescource change listener works
like come closer native git would write wondering whether also mention diff algorithm used really influences merge result
check testing unborn branch complain unborn branch somehow opposite wanted achive
free anymore jump 2.0 anymore right could add method expects set least internally call new method jump 2.0 remove old method expects collections
want sets could also simply change signature accept set extends objectid would put burden converting lists sets caller benefit would callers create sets first place instead first creating lists converting sets many callers adapted go way
add option controls whehter trees included s/will include changed trees/allows specify whether changed trees included/
style-nit remove trailing whitespace
method returns pathes would suggest s/the paths are/a diffentry path is/
overwrite newtree checked explicitly set somebody sets newtree oldtree would ignore newtree
fix resetcommand instead writing fixed version egit functionality needed jgit users also offer jgit
thanks thomasz amazing bug unit tests covered every line succesfull unit tests covered functionality deleting empty dir worked removedemptyparents call outside loop code went multiple reviews still bug managed undetected good job
still push command potentially creates new branches remote although explicit refspec local branch names taken create branches remote repo although user explicitly requested really want native git also look bad names give local branches guess explicit operation publish local branch names since behaviour introduced touched change strangely tested suggest accept change create bug old behaviour
sure ssh authentication use egit push via ssh new dialogs pop ssh communication goes jsch component dialogs think proposal fixes http pushes https pushes asked http user/password https communication passphrases access certificate stores
style-nit please remove trailing whitespaces 13 places file gerrit web-ui tells red markers trainling whitespaces
style-nit please remove trailing whitespaces file
done
done
done
done
fault overlooked line regarding rfc change mine really wrote change completely days back checked open proposals saw similar open change would hate somebody hijacks open proposals without telling therefore important make clear copied work fact change contains mistakes would gives proof proceed problems take proposal let one overwrite change revert mine
great clarified day today propose fix one night
started solving problem similar aproach calling mergealgorithm.merge produce merge result full-fledged merge two complicated diffs ok one diff complicated one text empty although know exactly merge result look like modified version deleted expect conflict like complete content ==== idea create mergeresult manually much faster calling merger think let put optimization mergealgorithm 'll make proposal code stay
really like idea remove block also whole block make much sense know another problem cherry-pick merge-commits cherrypicklist contains merge-commit chance rebase command succed fast-forward way process cherry-pick merge commit anymore would suggest simply add one check beginning initfilesandrewind method call log command something like walk.ismergedinto headcommit upstreamcommit updatehead easy case simple fast-forward skip complicated cases cherry-picking every commit handling merge commits
would name method updatehead way update previous head
also check up-to-date could done log command start handling single commits check beginning method like check fast-forward
see last proposal open question anymore right
fast order explain wanted trying following lines walk.ismergedinto upstreamcommit headcommit return rebaseresult.up_to_date_result else walk.ismergedinto headcommit upstreamcommit checkoutcommit upstreamcommit updateprevioushead headname upstreamcommit return new rebaseresult rebaseresult.status.fast_forward see latest proposal nearly would change check up_to_date_result mine imagine somebody invokes rebase head head~3 also up-to-date result
1
test ok. please add copy test time add following lines writetrashfile file2 changess git.add .addfilepattern file2 .call git.commit .setmessage update file2 target .call remove possibility fast-forward rebase algorithm cherry-pick every single missing commit cherry-pick merge commits eyes rebase command know return error cherry-pick merge-commits
nearly simply add lines suggest get graph similar one say rebase b onto f f onto b question check problem rebasecommand even start rebasing see cases like check error conditions know situation handled already later could make sense first rebase expensive second check cheap anyhow visit every commit cherry-picked initialization phase rebase command simple check whether commits merge commit loop build cherrypicklist easy implement
done
text contain year month called yearsmonthsago strange
strategy converting age incrementally seconds minutes minutes days leads nice read understand code end much slower convert seconds long age system.currenttimemillis when.gettime 1000 age 90 else age 90*60 ..
agree let like
one case inside sap still investigate process holding file-handle outside eclipse maybe resource monitor decorator investigations yet 'll keep date
done
done
done
tried api modification causes many modifications already jgit worth proposal
filesnapshot solution need modification file anymore right
sorry overlooked proposal think proposal using filesnapshot would solve specific problem instable egit tests much better 'll review proposal could even abandon change understood correctly still need refresh method dht use cases would leave one open
+1 therefore leave proposal open abandon favour filesnapshot solution would solve specific problem
use simple system.currrenttimemillis instead systemreader
agree updated
agree work lightweight tags http //book.git-scm.com/3_git_tag.html tag objects 'll add code real tag objects
done typo comment actually support simple-two-way-in-core guess 'simple-two-way-in-core used recursive octopus strategies place therefore would like describe strategy
native git hard prereq index clean man page says git pull git merge stop without anything local uncommitted changes overlap files git pull/git merge may need update would like follow semantics check would merge strategies would fail trying overwrite uncommited data
done
checked-in code formatter like see would set tab width gerrit ui 4 breaking line manages stay maximum line length
done
thats string printed line next lines 'll print pathes files want overwrite
thats string printed line next lines 'll print pathes files want overwrite
coding changes speak 'failures would consequently call show failures
introduce cherrypickcommand abnormalmergefailure let mergecommand throw cherry-pick end also call mergecommand therefore also benefit new exceptions
maybe one sentence comment brackets could cause situations would good
nice refactoring really belong test infrastructure one specific test
would careful including smudge state could platform dependent whether hitting smudged situations want test leave
could add test case merge staged content file touched merge suceed whats test dirty working trees
commit message led wrong direction merge failing merge wanted modify dirty file wanted test checkout-from-theirs case
guess right if-statement real fix modifications file cleanups/refactorings/style nits right least youre new tests succeed add add test dirty-worktree file case checkout
maybe personal taste think kind methods make test code harder read method name already long still explain everything modifiying file took time understand test case overlooked method touches prefer longer test-methods using utility methods smaller scope long utility methods modify path creating-or-modifiying file checkout branch creating already switching branch commit adding everything
handled correctly also right think comment correct also catch tracked files newly created files added index exist base
always unchanged regarding base always take find -- without exception find something copy find copy one case get additional treatment contains deletion trigger explicit working tree cleanup point view liked old comments new one
done
done
replace lines writetrashfile also true writes files tests much easier read way
git.commit call already returns revcommit searching need call git.log explicitly wanted test log command finds last commit comment also true remaining new tests
really b.txt commit -o b.txt remove b.txt index index always contain files next commit files modified next commit would commit state next commit would contain .txt b.txt would version control anymore git log would tell last commit deleted b.txt would expect index containing a.txt b.txt would even expect commit -o changes index substantially try native git git init echo echo b b git add git ls-files -- stage git commit -o b -m only_b git ls-files -- stage git commit -m git ls-files -- stage git log -p
think crucial check commit also content brings file check files included commit miss test important -o functionality
thats problem delete original index instead process every single path original dircache path covered -o copy original index every path copy whats head words copy index work files covered -o option reset head state pathes covered -o copied
least mention whether support wildcards/special syntax
discussed person concentrate worktree content pathes included '-o native git works even make sure commit -o operation updated index entries entries included -o like would git add pathes included -o
change also means use different subset bits id input hashing least significant ignored high bits ignored see problem guess bits sha1 equally good input hashes
would forget performance would add check make sure sz power 2. would disastrous performance true size 1025 would lead mask one bit set therefore one bucket guessing right left checks performance reasons know 'll call method always powers 2
forget comment missed discussion load factors optimizations http //dev.eclipse.org/mhonarc/lists/jgit-dev/msg00980.html
means array grows filled 50 correct tried grow later increase
one source problem workingtreeiterator.ismodified much ever want content comparison idbuffer method detect metadata comparison reuse index-entry id want simply compute content-id file-content compare content index entry suggest introduce new comparison method workingtreeiterator compares metadata entry index entry method reused ismodified method called idbuffer remove infinite recursion problem 'll post proposal rebase change
ouch came regarding return idbuffer course right 'll propose fix regarding index update index updated currently scope change never hood updating index know 'git status/diff update index could imagine definitely make sense correct smudged status index entries walk get real info whether file dirty
faster ask path.indexof '/ need substrings beeing created stop first occurence
correct file a/b/c/f.txt wont path.split.. 0 construct return instead a/b/c expect want maybe better work lastindexof '/ substring lastslash path.lastindexof '/ lastslash -1 pathkey path.substring 0 lastslash
path.substring lastslash+1 maybe better
argument last file interested location last slash guess indexof+substring would faster
completely sure intentionally checked return code mkdirs mkdirs fails directory created subsequent createnewfile fail therefore 'll detect error situation want spend extra stats check file-existance file-type done fileutils
rename temp file rename typo called rename temp file set readonly
done
right calling differ_by_metadata sounds consistent 'll
done
yes right string may pop user would real developers fault covered possible cases guess hurt
philipp see see folder/file one thing shawn explained 'll get folder twice another bug explicitly call treewalk.issubtree treewalk.entersubtree dive subtrees 'll propose change
phillip propose new change successor one add test improvements
removed test-case fro nonrecursive specifically comment possible npes non-recursive treewalks added test since disallow usage filter non-recursive treewalks test
s/indexdifffitler/indexdifffilter/
one question file/folder conflict situation one iterator file another iterator tree path returned recursive treewalk walk.getfilemode indexofiteratorwithtree return missing
constant rawtext class
done
rule new thought parens together operator ok. ok 'll removed
done
done
agree histogramdiff default since already saw 3 diff algorithms myers patience histogram know think good idea give option configure algorithm
done
done
patient thats next proposal 1958. proposal meant make diff algorithm configurable 1958 switches default
done
done
currently checking pathes supported
need two getid calls get back gettree already sufficient
want call setupstreammode upstreammode different null either give defaultvalue upstreammode call null
lead reflog like checkout moving head want deref headref get branch name head points something like headref.gettarget .getname maybe take care headref.gettarget null
thats hard understand accept parameter called startpoint always set class attribute startpoint null would call parameter startcommit instead startpoint code would look clearer guess comment also true commands 'll check fix also
ca imagine reason commit content yet available create master branch first real commit create branch sideeffects anymore commit would remove line
master branch already created previous commit branch already points exactly commit creating branch refupdate skip next 5 lines
sure whether created wanted three commits two branches master test point last commit thats wanted would expected something like protected void setup throws exception super.setup git new git db commit something writetrashfile test.txt hello world git.add .addfilepattern test.txt .call initialcommit git.commit .setmessage initial commit .call create master branch switch git.branchcreate .setname test .call refupdate rup db.updateref constants.head rup.link refs/heads/test commit something test branch writetrashfile test.txt change git.add .addfilepattern test.txt .call secondcommit git.commit .setmessage second commit .call
least test switching branch pointing current head one check switch test master check content changed afterwards
s/bebase/rebase/
style-nit extra space
style-nit need empty line
test status add one
test detached head valid use-case working gerrit ui test case
s/sate/state/
create test wrong state
jgitinternalexception since nothing io
test unknown upstream
method replaced iteratorstate.initializedigestandreadbuffer right replacing method much smaller needed statement see method even initialized potentially present parent new method correct
done
fully agree ca explain kind loop went 'll repair
done
hmmm subtree path method called prescanonetree ignore head clone reset operations create non-recursive treewalk merge index worktree jump every path method clone use-case worktree index empty right reset likely e.g worktree contains folder path good news keep tests null values therefore lead npe bad news f.ismodified test null values npe would guess check ok needed think really need tests dircachecheckout.prescantwotrees well tested prescanonetree try create tests improve test coverage
done
class removed
done
reworked simplified completely
class removed
done
want text least one parameter want print pathes could deleted
sorry understand comment recidx
insert njd insert jtn right
done
typo fixed
done
right improve performance maybe little bit different way suggested looks like small change could bad regarding performance change force us read every single bit every file working tree problem m.idequal f triggers computation sha-1 content file working tree would like avoid computing id necessary e.g last-modification time file index know file index one already know id look workingtreeiterator.ismodified used end processentry abstracttreeiterator h abstracttreeiterator dircachebuilditerator workingtreeiterator f see could better decide overwrite file
anybody removing indexdiffs cache repositoryactionhandler longliving instance might consume memory needed commitdialog gone need cache anymore forget comment commitactionhandler instantiated newly every event
minor thing add initial capacity 4 save 6 slots default capacity 10
near solution beeing compatible c git valid argument aware 'git for-each-ref' functionality regarding orig_head fetch_head merge_head compatible agree repo.getallrefs return implicit ref-like things orig_head fetch_head merge_head head returned getallrefs suggestion would add 'getimplictrefsnames even expose 'public static string implicitrefsnames refsdatabase problem solved
ok understand argument hand jgit writing files write allow applications read us example ide integration like egit wants show available refs end-users really hard-code list merge_head orig_head fetch_head would strange internal refs real-world use case understand egit user might really want compare orig_head fetch change gerrit rebase current branch fetch_head whats option getrefs telling report also special refs
agree fetch_head merge_head really refs point potentially set objects single one since valid use-cases using ref'ish objects like refs e.g fetching changeset gerrit commands gerrit publishes support using ref-like objects refs native git yes support already call repo.getref fetch_head already nothing done 'll propose good getter fetch_head like merge_head one thing disagree still think responsibility jgit tell refs accept let talk java repo.getref fetch_head =null assert repo.getallrefs .containskey fetch_head currently assert might fail looks strange refdatabase accepts fetch_head returns single ref exposed asking refs way adding orig_head refsdatabase ok working rebase would like offer users possibility compare orig_head
done
done
done
regarding failure handling command stop first failing cherry-pick head point result last successful cherry-pick right report overall success command proposal 'll return revcommit points new head cherry-picks succesfull otherwise null returned additionally add getsuccesfullycherrypickedrefs publish list successful cherry-picks
done
'll line wrong costed hour development looked srcparent revcommit later set base merge srcparent.gettree base set null everything succeeded afterwards course merge result buggy
heard editor course change farewell ugly name long debugging sessions together time go
done
done
done
got
done
done
called pull current branch pull current branch pull current branch
see resulting menu looks strange lot actions look like action pull full sentence especially latter part current branch bring benefit pull always merge current head eyes pull would better solution
see removed
suggest maximum size kib scan per file revision mislead believing thats limit whole testcase diffalgorithms diffed int total amount bytes 'll stop
limit number comparisons 'll repo contains 1 file reach limit suggest number file revisions compared
prints strange heading last two columns thought columns titled n= string contain something related n. suggestion out.format compared bytes per file min n= max n= d\n minn maxn out.format -25s 12s 12s 12s \n algorithm time ns time ns time ns out.format -25s 12s 12s 12s \n smallest file biggest file out.println -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
method called 'included wrongly thought include would include something somewhere
min max mini-/maximal n runtime right
return list ref would return refs deleted already right
setmode command command line want delete remote tracking branch specify '-r otherwise operation prohibited sure whether really want feature api think ok delete remote tracking branches without given mode
missing copyright header
accept also revcommits starting point mergecommand.include .. accept strings well higher-level objects imagine create first branch command would return revcommit want create second branch first branch starting point already object right type hand forced convert string class convert back string revcommit
trailing whitespace error make sure standard jgit preferences active would delete whitespaces
wanted change comment
create file added initial commit
use writetrashfile filename data single call 4 lines comment applicable lot times file
delete commented lines
needed create localrepository test subclass repositorytestcase tests automatically access test repo call getrepository get access
implement mode class branchdelete branchcreate need mode enum anymore hope also get rid options map store options simply plain attributes
also think git porcelain commands different modes even share common paramenters like create vs. list go different commands implemented seperate classes
really commit message commit get message suggest reflogmessage
pull configuration talks name remote repo branch name remote repository mention name local remote tracking branch imagine configuration like remote eclipse url git //egit.eclipse.org/jgit.git fetch +refs/heads/* refs/heads/fromeclipse/* branch master remote eclipse merge refs/heads/master want finally merge refs/heads/fromeclipse/master master thats hard find look pull configuration also want parse fetch configuration fetch command tells us remote branch went local branch thats
done
copied proposed test bug 315571. right name ok. fixed
changed 'lead 'led 'to 'too really
done
previously special constructs scheme //host/~username/path needed anymore remove '~username reference javadoc 'll also reword part saying host 'contains user/pwd etc
done
done
sure cherry-picking think different story merge merge two states b merge result consists parts parts b conflicts cherry pick afaik different take diff one commit lines changed single commit try apply change state solve problems like target state add change line numbers sufficient find common lines context listed diff problems merge algorithm care
style unnecessary empty line
understanding 'incore mean ignore workingdir also update index right incore version dircache supposed ever persisted see use dircache.writetree end think permitted even incore dircache write object database merge result index updated correct
skip cleanup case incore attribute modifiedfiles may still filled wrongly incore-merge fails whatever reason clean modifiedfiles list maybe better modifiy cleanup case incore
agree
fillining failingpathes list case incore therefore able report incore merge failed
two additional mainloop one one mergeimpl great point view spent
think missed something guess easy standard java shawn provided class temporarybuffer.localfile may helpful may also decide leave optimization next proposal stay temporary file
way get rid using temporary files memory would fit better case incore mergeformatter also later objectinserter bound files input/outputstreams
style-nit please use tabs indention
style-nit wrong indention previous two lines
style-nit please remove trailing whitespaces
method also mergeimpl looks similar enough reused
s/know/now/
super small diff algorithm like general question guess end want configure diff algorithm use would nice silver bullet fitting situations likely even patience diff sometimes wants fall back diffs time diffalgorithm abstraction common superclass patiencediff myersdiff e.g patiencediff would get diffalgorithm constructor parameter knows algorithm fall back
field see use field anymore diff would return editlist
lot testcases make also sense myersdiff right would abstraction diffalgorithms could reuse know test specific patiencediff
first parameter called b would symmetric scana
want core algorithm stays maintainable add least documentation three main entrypoints scana scanb match know public hard time understanding
nad typo
one thing surprised expecting hashedsequence would also responsible triggering hash calculation certain elements getter hashcode element x would look hashcode already trigger calculation lazy way calculation hashes may reduce resource demand huge contents maybe huge contents switch diff needs hashes certain window sequence ok ok far away moment hashedsequence really dumb store prevent us
understand correctly hashedsequence add cache hashes sequence also offers funtionality work subset original sequence offset ignore prefix original sequence correct document
maybe understand better begin field hashedsequence expecting hashedsequencecomparator one thing provide fast equals hash using knowledge sequences hashes additionally index translation offset subsequence focusing index translation maybe could always use subsequences index translation remove aspect class
done
done
agree 'll propose something like suggested
done
removed incomplete sentence
yes thats right want make sure end commits positioned previously always true repaired unpositioned children occured parents one child child one parent us 'll add comment describing better
'll add comment
ok got two arguments performance default implementations interfaces sequence diffcomparator would allow us single classes implement like standard java equals hash every model class would help writing smaller tests real code would really want seperate implementations sequence diffcomparator runtime-performance argument beats smaller-tests fine abstract class
reason using interface
agree hash equivalence tied strongly together implemented class maybe class name disturbed comparator offers functionalities working single object comparing two objects since hashes may needed efficient equivalence calculation convinced
class comparator class tells us sizes hashes things nothing comparision expect comparator agree need comparator concept also auto-crlf stuff leave aspects belong one diff-able object seperate class/interface something previously called sequence something like abstract class diffcomparator extends sequence public abstract boolean equals int ai b int bi abstract class sequence public abstract int size public abstract int hash int ptr
agree let defer patience diff one comment avoiding calculating unneeded hashes think diff algorithms know hashes 'll need trigger calculation right
accept comparator store use constructor use fill hashes used anymore skip comparator remove hashes computehashes
somehow odd ask comparator object size
comment explicitly permissible something callers smart enough really want save one implementations brings huge performance gains could unterstand e.g measurable tests
surprising suggest guess spent method call know sure call comes free inlining right
yes myers use term distance length regions used context edit distances one reason call distance
stick term 'length something like 'return length region easier understand introducing 'distance
see getlengtha comment
accept locked dircaches requirement dircachebuilder.commit shawn commented would like use locked dircache instances sure
done
dircachecheckout would fail assertion workdircheckout succeed see comment handle
dircachecheckout would fail assertion workdircheckout succeed see comment handle
dircachecheckout would fail assertion workdircheckout succeed see comment handle
dircachecheckout would fail assertion workdircheckout succeed see comment handle
dircachecheckout would fail assertion workdircheckout succeed see comment handle
dircachecheckout would fail assertion workdircheckout succeed see comment handle
moved method workingtreeiterator
done
yes true could another proposal would like topics proposal workdircheckout handling proposal port semantics workdircheckout agree think make use checkout without racy git situations handled
sure right blindly copied gitindex code went workingtreeiterator compare ids may even needed anymore
aboth
check existence anymore new location method workingtreeiterator
done
different ismodified ismodified method put workingtreeiterator method writes workingtree workingtreeiterator intendet know would really like first merge move method dircachecheckout class knowing need better place one problem faced abstraction access worktree walking reading applications could use non-filesystem working-trees case working-tree abstraction allows create/update/delete files need trying first attempt workingtreewriters one implementation grew big enough decided would like seperate issue important merge
done
done
argument racy git agree would like follow-up proposal
cause saw like gitindex checkoutentry remember performance
done
done
done
done
argh quite lately removed worktreeiterator first version four iterators walk also description algorithm 1 contained workingtreeiterator description always walking three tree leaving head-commit always wondering workdircheckout solve problem make use workingtreeiterator tried 4 trees detected dozens cases need working tree iterator detect conflicts without looking workingdir thought maybe iterating costly filesystem default worth effort looking files need performant later got problems implementing asked 2 could wait answer proposal anyhow 'll propose another patchset workdiriterator 'll enhance interface egit pass iterator 1 http //dev.eclipse.org/mhonarc/lists/jgit-dev/msg00220.html 2 http //dev.eclipse.org/mhonarc/lists/jgit-dev/msg00377.html
ok suggested one thing different loop deleted file deleted emptyparents
done
done
done
done
changed tree references objectid need ids trees main thing trees feeding treewalk therefore strangly put tree id one problem remains one remaining call tree.findblobmember hasparentblob called mergetreehasparentblob asked http //dev.eclipse.org/mhonarc/lists/jgit-dev/msg00458.html meaning call would happy remove call problem still reference tree api class
done
method walks two real git trees head und merge two things walking really trees index dircache tree filesystem working tree also tree enter method end-user specified exactly two trees index working tree derived current repo guess method named prescantwotrees
done
see comment
done
done
right exception completely wrong changed
added boolean return value checkout method false returned means obsolete files could deleted gettobedeleted contains path names remaining files
put everything checkoutentry
created new exception
done
right bet although owe lot beers finding style-nits serious problems code never ever code well reviewed thinking removing method already walked every single file folder worktree know pathes empty folders first tryout grew complicated wrote todo list think mistake copy workdircheckout create dircachecheckout copy overwhelmed many topics thought would save effort understanding workdircheckout writing dircachecheckout scratch would better would copy strange code
done
done
done
done
done
done
done
done
done
done
done
yes todo similar workdircheckout copied
shawn found problems implementation problem go combinedf always saw happen gap file dir added tests nameconflicttreewalk tests show problem also sure whether always enter popentriesequal clean left d/f conflict path added another implementation http //egit.eclipse.org/r/ change,1169
'll propose change nameconflicttreewalk one confirmation needed third step mention popping reading code think t.back t.matchshift t.matchshift 0 pop implementation right
semantics clear see comment 'll document clear
get pathes ignore list even dangerouse delete files
done
want later optimization checkout would need delay decision certain entry treewalk walked also whole subtree example head foo/c index foo/c foo/d merge foo first entry deal foo detect file/folder conflict decide foo know wether index entry foo/c clean entry comes later treewalk planning store list path entry dirtyop cleanop triples finally found index path clean/dirty entry processed according cleanop/dirtyop operations could update conflict said reduce complexity proposal brute force attempt start new walk
stated explicitly docs parent folder exist method called course removed mkdirs
done
done
added also check m==0 original check went explicitly merge-tree file directory/file conflict testing detected isdirectoryfileconflict implemented wrong therefore put work nameconflicttreewalker change sure proposal sub-optimal works let focus change dircachecheckout
done
done
done
done
done
done
add another iterator dircache already one walk reuse
think block covering cases e.g file exist update flag set file index happening delete tracked file work-dir call add -u expect file deleted add check possible combinations update flag set file exists workdir file exists index -- 8 cases
really new problems personally never liked used declarations inside loops long discussion style style use jgit
done
done
wanted file working-dir trash files go inspect work-dir tests choose proposal delete directly method
done
knew would get trouble string handling sub-optimal fix need help nice implementation suggested http //egit.eclipse.org/r/ patch sidebyside,825,4 org.eclipse.jgit/src/org/eclipse/jgit/dircache/dircachecheckout.java see latest comment basically could find places detect d/f conflict places leave conflicting path combinedf called d/f conflicts sometimes fastmin finds something enter combinedf added marking d/f conflict two places fastmin saw got many conflicts guess popentriesequal place clean state
done
done
great since also last id gets \n get rid code one variable
remove comment content checked workspaceiterator.ismodified
done
done
done
yes todo 'll make clear
got wrote new version check working raw-mode bit operations 5 lines 8 lines comment
idea originally created comment method initally created copying gitindex.entry.ismodified comment introduced seems different filesystems different precisions ext3 supports precision seconds see http //www.coderanch.com/t/384700/java/java/file-lastmodified-windows-vs-linux come situation compare timestamps written different filesystems may deal
done
amazing find yesterday matthias also saw duplicate check check propose new patchset submit
done
added unresolvedconflictsexception exposing also conflicting pathes
done
shawn always thought ref combination name objectid introduce something else like source class agree course need add ways anyobjectid
'll use list ref
added invalidmergeheadexception
maybe misunderstanding stefan reading http //www.kernel.org/pub/software/scm/git/docs/git-merge.html _pre_merge_checks thought fast_forward already_up_to_date checks done contact merge strategy loop never intended big loop merges maybe combining merge operations wanted two pre-merge checks reading comment experimenting see pre-merge checks done merge strategy every strategy triggers explicitly right 'll remove loop keep fast-forward already-up-to-date checks 'll make sure one commit specifiied
oops missed merge stefans fix annotated tags calling getpeeledobjectid 'll add
done
damned eclipse auto formatter 'll revert
done
miracle parens came useless believe typed
done
sure anymore whether good idea jgit takes care installation native git-lfs would expect jgit based lfs-install routine needed jgit lfs implementation setting config_key_usejgitbuiltin happens native git changes done git lfs install maybe could simply call git lfs install configure config_key_usejgitbuiltin even call git lfs install leave user
support uninstall also -- local option especially replacing something exists locally imagine people want try jgit version specific repositories leave default implementation jgit case write repo specific config file user config file
would use camel-case 'sparsecheckout described native git documentation used also constants 3 lines
add 'removed understand docs git-read-tree correctly native git delete file skip-worktree flag switches false true file exists workingtree skip-worktree bit already true e.g manually copied deleted git subsequent checkout delete file although maybe common use case much experience effect dramatic user looses file content native git would keep check shows native git keeps d/f working tree jgit would git init initialized empty git repository /private/tmp/e/.git/ git config core.sparsecheckout true touch mkdir e touch e/f touch d/f git add git commit -qm initial git tag t1 echo x e/f git commit -qam mod_e/f echo e/* .git/info/sparse-checkout git checkout -q t1 find -type f e/f git ls-files -v d/f h e/f mkdir echo d/f git checkout -q master find -type f d/f e/f git ls-files -v d/f h e/f
update case check whether skip-worktree flag toggled
info thought situation skip-worktree set specific path merge leads conflict may multiple entries different stages path moment work combination skip-worktree bits
get completely want achieve help docs git-read-tree say git read-tree needs update working directory resets skip-worktree bit index based file uses syntax .gitignore files entry matches pattern file skip- worktree set entry otherwise skip-worktree set compares new skip-worktree value previous one skip-worktree turns set unset add corresponding file back turns unset set file removed means need save old value skip-worktree bit update dircacheentry written index new value based rules sparse-checkout file independent working-tree content configuration option sparsecheckout done added possibly change dircacheentry builder finally look filesystem skip-worktree bit toggled false true remove file regardless whether existed toggled true false rewrite file already right content modify workingtree file check whether dirty file content differs index content better delete unsaved content sure native git compare old state flag new state think 'll add tests sometimes easier explaining much
careful calls filesystem real performance killers platforms would avoid checking existence file see comments
decision whether write new dircacheentry affected fact whether working tree file exists populate index decision based old index tree want checkout working tree state plays role decided new index entry finally clean working tree create delete files
old index multiple stages conflicting file switch writing stage 0. write complete new entry uff complicated
even remove file worktree update index contains content file would like checkout asking clue native git
think need tests 'what happens used sparse checkout turned users comes back index skip-worktree bits set git-read-tree documentation tells native git tricky
code may problematic typically get config instance cfg=repo.getconfig modify cfg.set methods call cfg.save call getconfig twice line line theoretically could return two different config instances save line modified line sure would follow following pattern everywhere file config cfg= .getconfig cfg.setboolean cfg.save
s/rule/config option/ term rule made think modifying rules sparse-checkout file
test switching using sparse checkout using sparse checkout test index entries skip-worktree flag set working tree file exits/no-exists configuration change another checkout see files exist skip-worktree bit set overlooked tests
little bit distracted first sentence sounded little bit like special feature experts adds support sparse checkout checkout file sparse-checkout honored described 1
typically describe project file sentence user visible changes like describing new config constants enable/disable feature tell write sparse-checkout files refer explanation tell missing native-git sparse checkout feature
need mention
local mean could say code null sparse-checkout file exists
skipworktree attribute indexdiff directly entry index dircache case ca ask dircache pathes skips without full fledged diff
would 'flags better
info_len_extended
found severe bug call setskipworktree false entry ca parse resulting index anymore even native git ca parse index anymore added test addtest.java maybe extend entry extended call setskipworktree false tried native git call 'git update-index -- no-skip-worktree also forcefully extend entry sure whole problem
bug line set bits besides skip_worktree skip_worktree bit stays unchanged want want unset skip_worktree extendedflags ~skip_worktree scares able read index even jgit test showed
sure create second repo 'submodule create commits repo end test repo 'db 'db create folder 'one configure submodule never fetch content repo could write test use random guids firstsubcommit secondsubcommit 'db would never detect difference never fetches submodule repo would understand test repository 'submodule would located 'one folder workingtree 'db would tree like db -- .git/ -- .gitmodules -- initial -- one/ -- .git/ -- sub tree like db -- .git/ -- .gitmodules -- initial -- one submodule -- .git/ -- sub
strange method works repo db imagine worktree repo would start db changes config repository db /.git/config adds submodule url submodule location repo db cyclic reference intendet assuming would want add location 'submodule repository /t/jgit_test_4760626799335894783_tmp/tmp_3098717374613702227 left + git config submodule.one.url file /t/jgit_test_4760626799335894783_tmp/tmp_3098717374613702227/.git/
look comment reach code also merge index point commit submodule head contains nothing want update index index contains want checkout typically update index also touch working tree call update populates index problem index already contains mid mmode also remembers path updated forces checkout path check 1 see difference last checkout done native-git jgit + git init subrepo initialized empty git repository /private/tmp/x/subrepo/.git/ + cd subrepo/ + touch + git add + git commit -m adda master root-commit 190d5ae adda 1 file changed 0 insertions + 0 deletions create mode 100644 + cd .. + git init rootrepo initialized empty git repository /private/tmp/x/rootrepo/.git/ + cd rootrepo/ + touch b + git add b + git commit -m addb master root-commit 880f629 addb 1 file changed 0 insertions + 0 deletions create mode 100644 b + git branch side + git submodule add ../subrepo/ sub cloning '/private/tmp/x/rootrepo/sub done + git commit -m addsub master fb1a590 addsub 2 files changed 4 insertions + create mode 100644 .gitmodules create mode 160000 sub + git tag withsub + git reset -- soft side + rm -fr sub + jgit checkout withsub + ls b 1 https //gist.github.com/chalstrick/c743b10b1ccd7a6954f12260ea0c59b9
s/whre/where/
keep comment
sure perfomance issues computing next lines sha1 complete subtree working tree maybe really expensive maybe keep investigating
maybe mention functionalities native git ls-files support ls-files give lot useful info inspecting index -s -k think support -t deprecated native git -s would nice feature follow change could get rid pgm/debug/showdircache class
check entries exisiting head missing index files already executed 'git rm comitted symbolic links submodules even support bells whistles native git ls-files silently ignore links submodules
like reflog branch gets polluted amend commit branch test1 reflog gets one extra entry chris vblub14 ~/git/delve git reflog test cec2e97 test 0 commit amend test1 f37a26d test 1 head~ updating head 6aea04e test 2 commit test1 f37a26d test 3 branch created branch refs/remotes/origin/master maybe prohibit reflog entries
like idea grace period unknown tmp files could delete directly files know created delete remaining files older certain period
could delete files created different process gc jgit could files know temporary files created delete
1
would calculate threshold outside loop now- 24*60*60*1000 loop files lastmodified threshold deleted prune method delete loose unreferenced objects old enough calculate threshold advance use threshold delete decisions
imagine instant.now and/or filesystem modification timestamps resolution 500ms timers tick pack creation line 72 threshold check gc test would fail saver side would add 2 sec threshold hope clocks tick least 2 seconds like -24*60*62*1000
comment regarding whether right thing addcommand.java really native git root working tree say git add add files folder subfolders git add -- would also add files current directory git init initialized empty git repository touch mkdir touch d/b git add git commit -m initial master root-commit 8f03333 initial 2 files changed 0 insertions + 0 deletions create mode 100644 create mode 100644 d/b echo x echo d/b cd git add git status branch master changes committed use git reset head file unstage modified b changes staged commit use git add file update committed use git checkout -- file discard changes working directory modified ../a git add -- git status branch master changes committed use git reset head file unstage modified ../a modified b
test calling setremote url instead remotename
really name remote also possible specifiy url like git //myhost/myrepo.git
ok comments see man pages 4 git commands mention call repository push command man page e.g shows names remotes urls different things go parameter guess called remote even could convince since fetchcommand api included released jgit version ca change anymore agree beeing consistent fetch pull important maybe could add additional setters repository commands sync native git terminology
fetchcommand issue would prefer repository matches native git documentation remote would make think specify name remote correct specify remote names also able specify urls
api close native-git possible would like call parameter repository instead remote look http //www.kernel.org/pub/software/scm/git/docs/git-pull.html
another example mac/windows repo ref packed-refs file create new ref persisted loose ref filename know iterate known refs ref name come outside public api ask 'll find loose ref definitly bug
agree potential performance enhancements file d/f untracked file native gits git status -u also report course would report smaller sets back caller skip processing subtrees case neither index trees contain something path maybe need lookahead iterating trees 'll make proposal aware may adapt users indexdiff imagine e.g decorators called decorate d/f currently expects gets status d/f aware look whether superfolders reported untracked
.git files directories text files named '.git content line containing path local filesystem real .git file located e.g cd /tmp git clone -- recursive https //gerrit.googlesource.com/gerrit ls -la /tmp/gerrit/plugins/download-commands cat /tmp/gerrit/plugins/download-commands/.git jgit debug-show-dir-cache | grep download-commands
line inside try block sufficient close git2 work additionally close db2
maybe could different name dirnogitlinks reserved native git dirnogitlinks semantic semantic proposal looks workingtree named differently e.g dirforcenogitlinks
forced change class better fileentry constructor old signature falls back default filemodestrategy
please remove file
end want native gits dir_no_gitlink semantic would require discussed predecessor change https //git.eclipse.org/r/ /c/51405/ logic treewalk need access workingtreeiterator dircacheiterator change suggesting simple way looks filetreeiterator fear change api like discussed know would change full fledged dir_no_gitlink comes would move responsibility mode detection filetreeiterator treewalk looks good wanted suggest callback mechanism played saw looks much like filemodestrategy https //git.eclipse.org/r/ /c/51483 change first could implement first strategy change quite easily later could implement different strategy access dircache people could choose based use case fits best therefore suggest bring https //git.eclipse.org/r/ /c/51483 first sorry back forth
please remove commented lines
please remove commented lines git version control system older versions available need keep inactive code inside comments
better hide exceptions would like objectencryptionv2 situation always throw error e true also decryt
want validate stream ok check received 3 two lines
please remove trailing whitespace
need say equalsignorecase simply use equals also next two occurrences
please remove debug statements say else calg
sure really want fix really want allow git.checkout .setname xyz .addpath a.txt .call disallowed use git.checkout .setstartpoint xyz .addpath a.txt .call javadoc setname tells try change leave modifications block tests fail change test use setstartpoint instead setname work guess need modification maybe really enrich processoptions throw exceptions combination options set support like pathes specfied createbranch true pathes specfied name specified
fix really needed +1
currently found real problem wanted make aware following think changing semantics little bit one precondition getref throw ioexception caller specified needle contain even got ioexception readref sometimes rethrow simply moved next searchpath element true anymore even needle contains '/ may throw ioexception
+1 right overlooked leading fault reason looked longer removed complicated block controlling throw exceptions thought must semantic change convinced ok. check readandresolve whether full name contains really replaces beast
nullable
would suggest upload change javadoc discuss concrete proposal agree bare handling well documented let improve
yes also think introduce bare field already abstract isbare method left responsibility implementors repository consistent behavior create bare isbare maybe document better repository test implementations repository behave expect
field bare method isbare using strange
always end currently 'password must followed 'passphrase suffixed everything even space 'for required
much smaller test ideally succeed test shows bugs/limitations jgit 1 possible prevent reflog message written 'll propose fix commitcommand 2 garbage collection done reflogs inspected newid oldid taken account sure whether correct whether newid taken 'll inspect cgit upload change
already class name lot dircachecheckout tests please move test org.eclipse.jgit.lib.dircachecheckouttest
would mention option relevant failonconflict false important defalt failonconflict true commands like git.checkout use true mentioned javadoc would repeat commit message
also sure whether implementation efficient standard case checkout maybe expensive maybe could make use guaranteed order go index entries postordertraversal false know f/ visit f/a f/b enter subtree f/ could set flag 'insideconflictingfolder know pathes underneath folder conflicts
missing else branch method decide every path index workingtree path look like calls conflict keep update remove path reach block update==false simply take decision index contained f/a checkout detect file/folder conflict f stored index checkout propose keep f/a index least resulting index would call keep else branch achieve
checkout update workingtree also populates index even way round first decide go index afterwards update also working tree like git read-tree -u suggest enhance tests assertions index see assertions indexstate tests class assertions git.status .call .isclean
nit remove trailing whitespace
check whether destination exists thats native git root jgit repo git mv readme.md license fatal destination exists source=readme.md destination=license
would check return code even better use utility function renaming org.eclipse.jgit.util.fileutils.rename
think file tracked index means soon added istracked could simple repo.readdircache.get would solve problem solution rm path twice would allow jgit rm pom.xml jgit rm pom.xml native git throws error second attempt git rm pom.xml rm 'pom.xml' git rm pom.xml fatal pathspec 'pom.xml match files
nit remove trailing whitespace
nit remove trailing whitespace
yes right differentiate referenced loose objects loose objects unreferenced young deleted last gc late expensive repack loose objects exist start gc file creation date older last gc run good candidates could become referenced last gc run somehow persist loose objects survive young agree packing bookkeeping reasons expensive would go gc.log trick yes please send patch
different problem situation every fetch leads autogc fix decide whether autogc could count loose objects also persisted pack file first fetch would pack loose objects inside pack also keeps objects loose objects young next fetch triggering autogc would count objetcs loose inside packs therefore triggering new gc sounds good would propse change
limit amount bytes reporting otherwise one could crash server putting huge gc.log file
potentially unlocking lck anymore reached line lck.unlock finally try block starts line 663
imagine background==false reach line exceptions 687 691. would unlock file
wip gave -2. end change contain optimizations patchset starting point counting
would add hookerrorhandler interface change 35476
jgit sometimes needs help higher layers e.g egit introducing callbacks jgits rebasecommand needs definitly interaction egit notion interactivehandler lot commands want inform egit progress operation allow caller specify progressmonitor may think adding hookerrorhandler something like commitcommand.sethookerrorhandler errorhandler h egit may set jgit call handler hook handling leads errors
seen failing maybe test would nice e.g inspecting file mode see workingtree gitlink index see file would reach block case contentcheck anymore imagine differences metadata say contentcheck needed
proposed solution explicitly check whether repository instance cached
testing
course need configuration parameters time live
also needs configurable
method removed
using lock openrepository race condition fixed
done
done
testing see debug output
configuration removed latest patchset
please add add since 4.2 tag otherwise eclipse complains
void method javadoc return allowed
since tag needed
need since tag
method getsearchpath refdatabase let think return actual refsearchpath database returns default search path javadoc states correctly would getdefaultsearchpath better name
would nice able ask refdatabase actual search path e.g adding abstract getsearchpath implement refdirectory
done
right mac sed gnu sed easy fix done
always think means method returns true maybe one one sentence like true returned folders containing .git entries treated gitlinks added
unneeded import
nit trailing whitespaces
spent time understanding change method depend newly introduced dir_no_gitlink changing semantics also situations dir_no_gitlinks set course want prevent break previously working scenarios spent long understanding effects change gave wrote table shows different results old new code https //docs.google.com/spreadsheets/d/1gkq1xnyun-vnzkjukes7pax2nhbe2fx4oavntwownso/edit usp=sharing three situations new code differs case new code returns gitlink oldcode returned tree isfilemode ==true imode==gitlink wtmode==tree isfilemode ==false imode==gitlink wtmode==tree case new code returns tree oldcode returned gitlink isfilemode ==false imode==tree wtmode==gitlink seems code index mode precedence working-tree mode able code e.g change gitlink index tree index even dir_no_gitlink=false gitlink index change submodule normal files working tree add tree
hmm playing native git understand change better seems also native git tricky switch gitlink tree vice versa coding implements semantics native git think lacking test line 935-937
lines explicitly handle core.filemode==false situations change guaranteed lines executed core.filemode==false changed condition tests also executed core.filemode==true harmful know non clauses become true clarify suggest make explicit getoptions .isfilemode two clauses
unneeded import
even file named .git containing something like gitdir cause jgit interprete folder subdir would write directory file see first note https //git-scm.com/docs/gitrepository-layout
get condition especially precedence operators make hard change t.matches ch t.eof filemode.tree.equals t.mode b c means enter subtree following true point path treewalk currently looking b able provide least one element c pointing tree added your-condition end means would enter subtree always your-condition true even pointing src/a/ treewalk currently looking src/b/ even already processed entries sounds wrong would understand code would two paranthesis like t.matches ch t.eof filemode.tree.equals t.mode filemode.gitlink.equals t.mode t.isworktree upload test shows
eclipse says return tag missing
remove wip really explain commit actually
missing since tag api baseline configured
eclipse complains missing javadoc public method javadoc contain since tag
eclipse complains missing javadoc public method javadoc contain since tag
p happens filetreeiterator likely use p.filemodestrategy instead default one maybe test would great see filetreeiterator instances created subtrees contain filemodestrategy instance parent
eclipse complains missing javadoc public class javadoc contain since tag
eclipse complains missing javadoc public method javadoc contain since tag
eclipse complains missing javadoc public class javadoc contain since tag
eclipse complains missing javadoc public field
eclipse complains missing javadoc public method javadoc contain since tag
hoped one constructor taking filemodestrategy another one without ok. knowledge workingtreeoptions read config needed want create instances filemodestrategy fileentry need access config/workingtreeoptions delegates everything filemodestrategy right users use old api without specifying filemodestrategy get fileentry default default behaviour dir_no_gitlinks rest jgit use filetreeiterators filemodestrategy different semantics using low-level api calling high-level e.g git.open .status .call nice one solution would remove least deprecate constructor taking filemodestrategy guess many callers fileentry constructors see tests one place egit filetreeiterator possibility construct proper filemodestrategy agree may people outside using fileentry constructors config variable dir_no_gitlinks set people problems since introduce config variable currently even native git know config variable chances quite small hit problem
api baseline stuff became helpful eclipse warned line breaking api ok protected method important could break projects subclassing filetreeiterator api protected filetreeiterator final workingtreeiterator p final file root fs fs changed take filetreeiterator instead workingtreeiterator keep constructor taking workingtreeiterator fall back defaultfilemodestrategy case add constructor taking filetreeiterator one taking workingtreeiterator could marked deprecated uploaded patch
using writetrashfile save lot lines putting git construction try-with-resources block get rid warnings unclosed resources try git git new git db file f writetrashfile sub content git.add .addfilepattern sub .call assertequals sub mode:100644 content content indexstate content fileutils.delete f writetrashfile sub/a.txt
good found executing egit tests fault somehow looks strange store two different repositories treewalk walk working tree one repo reach points workingtree repositories submodules start dive could repo child differ repo parent 'll investigate
.gitmodules file deleted working tree still index git knows repo contained submodules next commit contain submodule commit contain .gitmodules file similar argument looking path x/y/z index tells underneath x/y/z submodule take hint x/y/z submodule regardless existence .gitmodules file worktree check see native git + git init sub initialized empty git repository /tmp/sub/.git/ + cd sub + touch + git add + git commit -m adda master root-commit 531d4d8 adda 1 file changed 0 insertions + 0 deletions create mode 100644 + cd .. + git init container initialized empty git repository /tmp/container/.git/ + cd container + touch b + git add b + git commit -m addb master root-commit 3be5e9b addb 1 file changed 0 insertions + 0 deletions create mode 100644 b + git submodule add ../sub plugins/sub cloning 'plugins/sub done + git commit -m addsubmodule master e9b19ab addsubmodule 2 files changed 4 insertions + create mode 100644 .gitmodules create mode 160000 plugins/sub + cd plugins/sub/ + echo 2 + git commit -a -m newa master 857c4f2 newa 1 file changed 1 insertion + + cd ../.. + rm .gitmodules + git add plugins/sub + git commit -m newversionofsub_deletedgitmodules master acd14b9 newversionofsub_deletedgitmodules 1 file changed 1 insertion + 1 deletion + git ls-files -s 100644 c16c5cbf89e80befa97ad60b5fd5dd3145751e4b 0 .gitmodules 100644 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0 b 160000 857c4f26427b28403bf3d7357fd2289315678a3e 0 plugins/sub /tmp
please remote empty line
ca expose new knowledge checkout/merge failed user mergecommand checkoutcommand
really mergefailurereason class used also normal checkouts resets sounds strange import org.eclipse.jgit.merge.resolvemerger want understand exceptions thrown checkout one example merge operation like dirty indexes publish mergefailurereason.dirty_index dircachecheckout dirty index alone reason fail checkout succesfully although index dirty suggestion let introduce checkoutfailurereason located org.eclipse.jgit.dircache
todos clear mergefailurereason choosen
agree feel free propose refactoring seperate predecessor commit
unneeded import removed otherwise eclipse complains
unneeded import removed otherwise eclipse complains
move also parent class make sense move one indexstate methods
attempt lazy guy would put flag already existing workingtreeoptions seems fit need new type deal correct propagation flags subwalks
sure whether tell repository low-level flag never exposed porcellain see comments filetreeiterator
one solution would add no_gitlinks attribute workingtreeoptions maybe even change repository class know something directoryflags whoever needs special filetreeiterator call constructor takes explicit workingtreeoptions take care no_gitlinks set constructors construct iterator know flag thought would lead small change api change sure whether wise let repository know default setting flag
right think crucial otherwise silently delete stuff next commit already existing submodule entries easily see inconsistencies calls status add diff use different values no_gitlinks doublechecking index problems much less want functionality check workingtree dircache put treewalk treewalk nows multiple iterators makes sure workingtreeiterator dircacheiterator sync using treewalk adding iterators could detect workingtree dircache let call already existing workingtreeiterator.setdircacheiterator workingtreeiterators nows dircacheiterator make use
1
done
introducing constants treewalk useless treewalk treewalk knowledge base etc make use afaik tree index 0 similar tree index 3. merge algorithm user treewalk could decide put base 1 0. user treewalk freely decides put responsible get right tree look commitcommand line 341-347 fill treewalk differently base index =0 worktree potentially commit safest way work treewalk always remember index treewalk gives variable treewalk treewalk new treewalk repo int dcidx treewalk.addtree new dircachebuilditerator existingbuilder hand quite common put base 0 etc would move constants e.g constants would clear treewalk rely constants
section key named config_http_section
know places jgit would make use http.proxy config constant surprised see currently supporting standard java programm expecting people call java program -dhttp.proxyhost -dhttp.proxyport think would make sense support config parameter currently therefore need constant planning add support would great
really needed without change would directly jump ldr.getbytes binaryfilethreshold throw exception reading binaryfilethreshold fix ldr.getbytes binaryfilethreshold may objectloaders determining size advance could expensive case may better read bytes stream count bytes throw exception case hit limit
mergeresult created merging two empty sequences definitly conflict still sequences empty would suggest add explict setter containsconflicts optionally could also add constructor takes containsconflicts parameter
maybe add test ask registry multiple pathes get back different mergedrivers would like see get one path another
interesting test case expecting sides add file git would consider tivial merge .learned something
test driver throwing ioexception
would avoid creating new temp files understand would like near native git merge driver interface explicitly defining interface merge drivers implemented java mergedriver would get three inputstreams one outputstream -- would better implement mergedriver java get three inputstreams instead three java.io.file objects -- would care much expose internals avoid touching filesystem looked merge drivers proposed problems solution lot places jgit thought lot touching filesystem invent writing three new files without good reason think windows machines sometimes content write go virus scanners
right also think look available versions binary use binary mode case would need pass also base method order check base binary content matthias suggested
one question plan handle renames maybe single filepath base file call src/a.txt renamed demo/x renamed ssh.bin wondering whether simply give three canonicaltreeparsers method ask current path looking would prepared situations single filepath
previously method processentry dealing directly content merges non-content-merge operations direclty method factored everything dealing content merge file i/o streams methods inlined reading writing content method making eaven bigger suggest factor content merge topics methods one method triggering content merge finding right driver opening closing content streams one writing merge result
javadoc treewalk.getpathstring warns bad performance method called path old code failed calling getpathstring often introduced variable store maybe add beginning processentry let calls getpathstring use
create internally array initially 32 bytes array increased need costly copy operations would help java specify size creating bytearrayoutputstream 1.5*max len len something like
agree
would give another name mergealgorithm variable hides field maybe readers code get confused later parts code think still use mergealgorithm field
argument isworktreedirty method please choose different parameter name
tricky introduced new parameter method choosed parameter name matches field name parameter hides field would make explicit want work field choosing different name
need parameters repository base need path find right driver
right returning merge results becoming complicated introducing merge drivers may good generic way return resolve merge hand really think resolve merger using textual merge somehow able present merge results also chunk-level file a.txt found conflict beginning line x common ancestor wants add xxx want right maybe responsibilty mergers present low-level merge results
please remove trailing blank
registry works static methods application using jgit may want deal multiple repositories code one big registry merge drivers regardless many git repositories dealing work thought registry merge drivers must something specific repository would expected registry retriveable repository object e.g java app git.open /git/a git.open /git/b config /git/a/.git/config contains different merge driver *.txt one /git/b/.git/config java program find driver /git/b
would say null driver registered
associate pattern explicitly default merge driver e.g write merge driver everything java files *.java files would like use default merge driver would allow specify default driver could say associate mydriver associate *.java default
given path contains completely ignore everything last take last segment path account give pathmatcher pathmatcher able differentiate src1/a.txt src2/a.txt code handle src1/a.txt manner src2/a.txt ca intendet look test fails mergedriverregistry.clear mergedriverregistry.associate src1/*.txt ours.getname mergedriverregistry.associate src2/*.txt theirs.getname mergedriverregistry.associate **/*.bin failing.getname assertsame failing mergedriverregistry.findmergedriver src1/a.bin assertsame mergedriverregistry.findmergedriver src1/a.txt assertsame mergedriverregistry.findmergedriver src2/a.txt
help merge drivers expected determine whether handle given entry would expect something like canhandle entry e method contract look interface would guess merge drivers know entries handle
contract merge drivers also explain put result merge understood native git merge driver get 3 strings input base current strings interpreted pathes filesystem merge driver expected write result file referred current java api want strings discussed comments suggest 3 inputstreams fourth parameter outputstream mergedriver write result sure whether need repository gives merge drivers rights need also write repo merge drivers realy create new git objects change refs maybe safer give merge driver config object look parameters control hand may merge drivers really look objects object database already use case mind merge drivers need config
know also handle native git merge drivers thought exposing occurred conflicts merge driver one decide conflicts occur way tell contract
trailing whitespace
versions changed content also call merge driver
interesting question tried merge algorithm e.g recursive-merge decide whether content merge needed therefore custom merger driver called decide also look content two branches change file content merge branches already merge algorithm sees need content merge tried native git merge driver called sides changed file content
lines file seem sorted please put line correct place
question expecting base always folder
interprete base strings current filesystem maybe take care case sensitivity e.g windows base= c \git\jgit ours= c \git\test\d\f.txt lead ..\test\d\f.txt current implementation would return ..\..\git\test\d\f.txt windows c \git c \git refer folder shame ca use java7 path.relativize think need tests
time windows also mac hfs+ specific behavior differs e.g standard linux filesystems instead ask fs class fs.iscasesensitive tests rely windows
default method uses stdout stderr chance choosing something different would simply say hook standard
would spent return value class enum suggested allows also write tests check behaviour needed usages api package users use api may interested maybe commitcommand may emit warning hooks present executed
chance find whether hook called depending environment may want warn caller e.g hook present could executed fs caller may skip certain steps knows hook executed therefore nothing changed repo
spent much effort filefilter listfiles calls guess overlooking something implement method public file findhook repository repository final hook hook file hookf new file new file repository.getdirectory hooks hook.getname non-nls-1 return hookf.isfile hookf null
method specific hooks
yes runprocess already done
create buffer store content want throw away end output null initialize writer call method writer initialized read lines
nit trailing blank
thinking multiple levels submodules workingtree /.git /.git/ /src /src/plugins /src/plugins/a /src/plugins/a/.git /.git/modules/plugins/a /src/plugins/a/src1 /src/plugins/a/sub/ /src/plugins/a/sub/.git /.git/modules/plugins/a/modules/sub /src/plugins/a/sub/src2 getrepositoryornestedsubmodulerepository /src/plugins/a/sub/src2 would return /.git/modules/plugins/a could leave feature request follow commit document
may run trouble caller method know whether submodule repos returned case method triggered opening new repository caller might want close repository done work method returned db caller maybe want close repo think root problem method hides whether opened new repo cause also problem first proposal solution could return submodulerepositories null null returned caller calls getrepository
done
done
done
done
done
done
trailing blank
add add get error message changed
really think forgot remove hardcoded path
throw error 4 parts
allow set values two parts e.g core.autocrlf
look javadoc length parameter determine many bytes read stream tell stream must empty afterwards tell read 10 bytes stream empty 8 bytes worth exception streams contains bytes ok. imagine receiving git objects network network connection one inputstream receive git objects know next objects receive blob 200 bytes blob 300 bytes case possible say idfor blob 200 netinputstream idfor blob 300 netinputstream change would let first call fail
would severe inconsistency server repo exists even push server would advertised ref commit tree missing server refs knows object dependent objects know cases recently explained commit without tree occur area unreferenced objects object garbage collected explanation situation occur gerrit server repo area referenced objects answer question client side ca detect problem know trees exist server side server detected one previous pushes moving ref commit dependent objects missing gerrit even change beeing active
put name
message 'commitisamergebutnomainlinewasspecified parameters specify two parameters thats bug suggest write test cherrypickcommandtest also explicitly produce two errors check exceptions thrown otherwise overlook kind bugs
message 'invalidcommitparentnumber parameters specify two parameters
description class think add link original description even copy also description modified could explain modified
need since 3.3 annotation annotate new public classes/methods/.. get introduced eclipse complains missing since tag
sentence correct please rephrase
need since 3.3 annotation annotate new public classes/methods/.. get introduced eclipse complains missing since tag
field initialized -1 0. javadoc setsetmaxpacksizelimit says 0 means limit default want limit
optional using implicit boxing long long messageformat.format expects objects trailing parameters give primitive 'long eclipse least worth warning 'long.valueof limit would remove warning code less complex easier read decide
according javadoc setmaxobjectsizelimi value 0 means limit maxpacksizelimit 0 means want limit would simply avoid overhead create limitedinputstream achieved s/ =/ javadoc setmaxobjectsizelimit wrong setting limit 0 means want receive single byte
need since 3.3 annotation annotate new public classes/methods/.. get introduced eclipse gives warnings
using eclipse right line produces errors eclipse uncommented protected variables
protected member javadoc produces errors eclipse
guess uncommented protected member
clear limit 0 means single byte received stream without exception 0 mean limit guess first
missing javadoc ioexception eclipse see would complain expect something useful javadoc would cause red error markers jgit developers choose develop eclipse
done
done
done
exactly still missing working
currently see usecase need something different tls need context set hostnameverifiers keystores https connections think need tls
done
done
done
big change proposing look javadoc trying compare file previous code explicitly checking file versus switching comparing file index previously file would differ method would return true already staged file method would compare index report false aware sure implications maybe somewhere really want know whether working tree file contains something different head
one method 'mergecontent another one 'contentmerge class nice hard find method therefore refactored resolvemerger one method content merge see change 4366 would suggest rebase change top 4366 adapt new structure look much cleaner
would better named class instead anonymous one default content merger could reuse instances defaultcontentmerger would need one defaultcontentmerger per repository
think casual users gitapi confused many people problems understanding difference mergestrategies resolve recursive content-mergers even would first look expect mergewith expects strategy also native git allows specify merge strategy together git merge command suggest name contentmergewith setmergetool consistent set content merger native git course argument goes commands touched
wrong ignore autocrlf==input case staged content crlf workingtree file contains exactly bytes staged set autocrlf input would mean report contents differ file different read eol-canonicalized index
unsmudge entries smudged setting length independently whether looking smudged entry also true case autcrlf false
right wrong path idea imagine staged file crlf autocrlf=false switch autocrlf=input expectation file immediatly dirty file would say git rm -- cached git add would get new content learned even native git picky overlooks potentially new content file reports clean let talk git tried situation git init git config core.autocrlf false echo -ne 'line1\r\nline2\r\n dos.txt echo -ne 'line1\nline2\n unix.txt echo -ne 'line1\r\nline2\n mixed.txt git add git commit -m add unix dos mixed style file working tree files index look like git think status file git ls-files -s -t -- debug set repo autocrlf=input git config core.autocrlf input get status aware git tells dos.txt clean although would say git rm dos.txt git add dos.txt would get new content git ls-files -s -t -- debug -- dos.txt delete index content add files autocrlf=input git rm -- cached git add compare len content-sha1 previous status -- len fields changed reflect length files working tree sha1 eol-canonicalization means add brought new content although status clean git ls-files -s -t -- debug
right also gitattributes files considered also start supporting sufficient good cgit reconfiguring core.autocrlf requires additional manual steps effective
file changed calling entry.setlength twice different values looks strange maybe setlength 'else block
first thought overkill introduce formatter interface simply always work steps see helps writing steps list revcommits nice idea
simply remove sb change body loop step null continue fw.write formatter.gettoken step fw.write non-nls-1 fw.write formatter.getname step fw.write non-nls-1 fw.write formatter.getshortmessage step fw.newline need pre-buffer string writing bufferedwriter
would expose concrete implementation linkedlist rather would say queue step steps loadsteps methods call steps queue interface
queue step loadsteps throws ioexception
queue step r new linkedlist step
another change move rebasecommand.loadsteps repository.readgitrebasetodo seems common practice methods read files .git directory repository class example see repository.readmergecommitmsg repository.readmergeheads spread knowledge certain git repository reads/writes standard files files also cgit knows much code ideally repository knows read write data structures helps think repository implementations read/write everything into/from filesystem
yes algorithm complicated eyes also also contributed mess happy current state imagine could go long discussions present graph correct robin said matter taste would suggest save discussion time take gitk git log -- graph show goal really find thing dislike heavily gitk shows could diverge -- see moment 'll try find time weekend add comments algorithm also know certain really wrongly displayed graphs topology displayed wrong 'll put tests 'll also try finally bring change https //git.eclipse.org/r/ /c/4863 brings lot complicated tests easier way test complicated graphs
change jgit positioning commits like gitk git log -- graph change position commit jgit specific fashion know matter taste prefer lane positions gitk shows
robin changed mind modify fileutils.rename way following test succeeds windows use fileutils.rename also dircachecheckout 'll propose
renaming target tmp file would safer costs one fs call end delete tmp file spent effort e.g update ref update index
way deleting target case rename fails even central lockfile class protects ref updates index updates lockfile.commit coding lck.renameto ref return true ref.exists deleteref renamelock return true unlock return false first rename fails target file exists call deleteref deletes target file another rename attempt renamelock non-atomic better chance also want run windows reading convinced fileutils.rename
yes risk fileutils.rename fileutils.rename would atomic anymore robin added javadoc explicitly stating changed rename method non-atomic way 11414. think get atomic rename conditions platforms e.g windows rename fails windows target file already exists good think always try atomic file.renameto first initial attempt fails go mode retry failing call delete empty folder hierarchy target location delete target file first suggestion
test working windows exactly problem caused corrupted repo gc windows ca rename file file b b already exists always thought work windows long correctly returned handles b beforehand current rename retry windows seem enough change fileutils.rename delete target file initial rename fails retry
done
done
done
done
done
done construction string moved loop
robin currently usage gitdateparser master branch one know uses open changes number people force change code one maybe open change would like parser api able support never always force users parser special handling special value able express instances date would vote expressing clearly api always valid dates returned imagine would happen miss opportunity fix api return fake far-future date never jgit programmers start using parser come introduce always represented null really force people change code expect null values correctly
may first idea also new date long.max_value thoughts readings discussions believe better express ca return real date instead returning fake dates never something different date far future although agree far future date would represent never quite good lot use cases example image program jgit want sleep reach point time specified git configuration parameter return date long.max_value sleep forever return never constant null indicate parser ca return date obvious make sense sleep reach never mentioning even better example always really chance return good fake date represent always means chance parser return valid date every parseable date-strings every caller check null-values react suggestion return null never always methods parser isnever isalways allow callers find parser returns null date
done
unreachable loose objects currently pruned prune loose objects made packfiles following assertion currently work maybe invent option gc tells prune loose unreachable objects currently parameter set never
unreachable loose objects currently pruned see
create tag object database tag object referenced ref tag object unreachable therefore save blob pruned object gc 'd
unreachable loose objects currently pruned see
unreachable loose objects currently pruned see
test worked luck add fix prune describe comment nonreferencedexiredobject_pruned test also fails fails reason described comment nonreferencedobjects_onlyexpiredpruned
object pruned filesystem repository instance ask end still caches know object a. since ca tell jgit ojbectdatabase remove certain object 'll added call close complete objectdatabase end prune call invalidates caches makes test green
caching problem nonreferencedexiredobject_pruned fixed next patchset
test work reliable multiple problems 1 may able create blobs fast two calls system.currenttimemillis return value system create 20 new files system.currenttimemillis returns new value cases call setexpireagemillis 0 object pruned 2 filesystem may store timestamps granularity system.currenttimemillis returns example look clock get back 12345678 create file file may lastmodifed 12345000. linux system create 20000 files row lastmodified test means create file currenttimemillis 12345678. create file gets lastmodified 12345000 creation look clock see 12345679. call expireagemillis 1 course object pruned would problem expireagemillis would expect absolute time specifications suggest wait filesystem timer advances creating first blob repositorytestcase.fstick help file file_a repo.getobjectdatabase .filefor long start=file_a.lastmodified repositorytestcase.fstick file_a revblob b tr.blob b file file_b repo.getobjectdatabase .filefor b gc.setexpireagemillis file_b.lastmodified start
looks strange need org.junit.runner org.junit.runners
pick parent ok complaining error cases differentiate anymore picked non-existing parent picked parent specified merge commit also native git gives different error messages situations try git init touch git add git commit -m adda git branch target git checkout -b side touch b git add b git commit -m addb git checkout master echo git commit -a -m modifya git merge side git checkout target git cherry-pick master previous command returned fatal commit 9ee535192272b65a6911fd19403176be7ba5c759 merge -m option given git cherry-pick -m 3 master previous command returned fatal commit 9ee535192272b65a6911fd19403176be7ba5c759 parent 3 two last cherry-picks gave different error messages would like two different exceptions nosuchparentexception multipleparentsnotallowedexception express
replaced multipleparentsnotallowedexception nosuchparentexception ok called setmainline try cherry-pick merge commit would still expect multipleparentsnotallowedexception case nosuchparentexception meaningful
remove jgitinternalexception signature
remove jgitinternalexception signature
remove jgitinternalexception signature
remove jgitinternalexception signature
remove jgitinternalexception signature
remove jgitinternalexception signature
remove jgitinternalexception signature
remove jgitinternalexception signature
remove jgitinternalexception signature
remove jgitinternalexception signature
remove jgitinternalexception signature
remove jgitinternalexception signature
remove jgitinternalexception signature
remove jgitinternalexception corresponding javadoc entry signature explanation give javadoc helpful enough keep exception documentation signature
remove jgitinternalexception signature
remove jgitinternalexception signature
remove jgitinternalexception signature
remove jgitinternalexception signature
remove jgitinternalexception signature
remove jgitinternalexception signature
remove jgitinternalexception signature
remove jgitinternalexception signature
give better explanation cause jgitinternalexception nicely explain error throw checked exception case suggest refnotfoundexception remove jgitinternalexception api
remove jgitinternalexception signature
remove jgitinternalexception signature
remove jgitinternalexception signature
remove jgitinternalexception signature
would remove jgitinternalexception javadoc entry would loose explanation explanation much help consistency would remove exception also
let remove rfc
remove jgitinternalexception signature
remove jgitinternalexception signature
remove jgitinternalexception signature
remove jgitinternalexception signature
remove fully qualified jgitinternalexception signature
remove jgitinternalexception signature
remove jgitinternalexception signature
remove jgitinternalexception signature
remove jgitinternalexception signature
remove jgitinternalexception signature
remove jgitinternalexception signature
remove jgitinternalexception signature
remove jgitinternalexception signature
remove jgitinternalexception signature
remove jgitinternalexception signature
remove jgitinternalexception signature
remove jgitinternalexception signature
remove jgitinternalexception signature
remove jgitinternalexception signature
remove jgitinternalexception signature
remove jgitinternalexception signature
remove jgitinternalexception signature
remove jgitinternalexception signature
remove jgitinternalexception signature
ah understand current commit message tells problem see right something fixed added 'll fix commit message fix failing test
like test -- relate commit message commit message expecting something different test succeeds checkout failing
think code jgit suggest git checkout -- path right pure git logic try keep things jgit good place would checkoutcommand would add method addpath string path could move code right location user jgit api could make use code sorry know late comment let commit change refactor directly afterwards officially copying code egit jgit licenses easy better put code right
annotated tags special attributes taggeridents message may want process would write code list annotated tags tagged person x tagcommand.call method would instantiate revtag objects need get data throw info away give refs instead caller use revwalks distinguish refs gave annotated tags recreate revtag objects
ref right type introduce type hold lightweight annotated tags like shawn suggested http //egit.eclipse.org/r/ patch unified,4346,1 org.eclipse.jgit.test/tst/org/eclipse/jgit/api/tagcommandtest.java introduce user api care details checking ref 'refs/tags differentiate different types tags since belongs public api get right first shot
gitapi meant high-level api developers willing sacrifice performance order get api offers exactly methods native-git commandline commands want penalty use tradiditional api repository .. walk dircachecheckout api find ok explicitly create tag get back something tag specific quite use-cases handle tags differently refs tags point tags even object types e.g branches always point commits want know commit tag pointing common use case guess tag specific way reasons enough introduce type representing tags high-level api especially look listtagcommand
needed anymore since latest proposal pm field topic handled constructor
agree documented throw ioexception 'll see far come lot reasons throw ioexception refdirectory.pack methods calls lot methods may throw ioexceptions reading files writing files checking existence files public methods class need javadoc 'll see one
uuuh sorry always run git log -p directly submit forget
done
initially wanted refupdates knew lock ref maybe user already locked refupdates hand believe unlikely string-based interface easier 'll change side topic thinking ref based interface think right let user specify refs implies user also specifies targets refs think users pack interested specifying target refs would document behave refs updated user created ref instances string based easier
done
done
done
understand todo anymore set storage packed peeledpackedref cached ref still exists wrong storage 'll remove todo
done
done
code sometimes produce conflict head merge commit decide throwing conflict without looking head commit true try git init echo 1 git add git commit -m initial echo 2 b git add b git commit -m second git checkout -b side head~ echo 3 chmod a+x git add git checkout master native git allows checkout without conflict although index working dirty means content mode want achieve checkout touch file filesystem silently overwrite files mode failed detect correctly touch file filesystem
merge index hava different modes
head index different modes
remove last line comment may touch index file
need first statement current code call update call keep merge head equal mode content merge index differ comment shows misunderstanding always try update index merge differ need second statement current code call conflict call keep merge index equal mode content merge head differ mode file dirty comment shows misunderstanding always conflict workingtree head merge different content sorry know sounds far complicated git checkout really complicated look cases 15 19 carry forward rules http //linux.die.net/man/1/git-read-tree see explanation two cases 'll propose testcases cover
head merge equal content mode touch index file true head index equal would add mid.equals hid mmode h.getentryrawmode keep dce mid.equals iid mmode imode keep dce
right looks much nicer done
really always crlf conversion even binary files would corrupt checked-in jpegs even file contains e.g null byte first x bytes something used check binary/non-binary files overlooked check always felt lack git attributes could use specify binary biggest obstacle autocrlf
spent another filesystem call autocrlf true look fs needed
trailing whitespace
miss test binary data
shame already processed every little byte content know enough info decide whether file binary call rawtext.isbinary read bytes ok read memory stop first 0 byte chance incrementally ask rawtext binary/not-binary processing bytes write int b could also stop buffering rawtext tells us binary
attempt always reading first 8000 bytes buffer even already first byte null buffered first 8000 bytes process first null suggest solution buffers everything first null byte 8000th byte whatever comes first potentially buffer much smaller amount data whenever detect first binary artefact decision taken rawtext stop buffering conversion rest stream see one problem suggest would method rawtext.isbinary byte ask rawtext every single byte get expect e.g utf-16 support come situation rawtext ca decide binary/not-binary looking single byte yes agree better stay approach
regarding marking direct parents uninteristing found answer would help much 99 cases visit direct parent commit x would visited commit x one step would stopped walk commit x. therefore nearly never reach direct parents commit x
repo long history might cost lot memory would make sense limit size cutoff list even incomplete cutoff list helps another idea ca mark direct parents commit uninteresting revwalk
found answer added multiple starting points find commit still know starting points led commit exactly want know starting refs lead commit
depth first search one ref look revwalk api could also mark refs starting refs using breadth first search
little bit like api change practically break applications worked catched org.eclipse.jgit.errors.checkoutconflictexception throw exception anymore org.eclipse.jgit.api.errors.checkoutconflictexception suggest cleaner method signature tells still may break running applications
struggeling little bit find higher layer would make use logger know suggest one small test somebody registers destination implementation would make clear potential users use class
like change would change commit message remove rfc better description accept
testxxx would remove 3 x
fully agree reset hard commit contains something path index remove index entry
please remove trailing blank
branches command return tags
think need unit tests please check happens repos without tags sort order expected official api contain code covered tests
also like open wrap express nicely side-effects would expect git repo creation case like static methods commands real equivalent op native git command line really want create new git repo empty dir filesystem think going git.init quite consistent would native git therefore personally would like add check open make sure repo yet exist 'll suggest something like new change
hmmm right logic miss already git.init .setdirectory .call need constructor initcommand everything abandon one
compile checked eclipse settings documented exception javadoc look change eclipse use checked-in warning/error levels another thing wondering break builds introducing new unchecked exception found method used egit/jgit
compile eclipse standard warning/error settings method throwing ioexception catching
style-nit use curly braces one-line blocks maybe something like file .equals uri.getscheme uri.getscheme null fs.resolve new file pwd uri.getpath .isdirectory throw new notsupportedexception uri.getpath + exist return true
sure whether notsupportedexception correct hand chance report error without breaking api
fear /path/to/non-existing/repository.git chance really exist want create pathname exist easier ways create repo delete maybe something like string path new file system.getproperty java.io.tmpdir transporttest + long.tostring system.currenttimemillis .getabsolutepath
oops sorry right approved comment println 'll
yes right line println already commented removed currently really want output local versions interested values performance optimizations end lines removed
yes measured runtime behaviour histogramdiff match expectations error message looks frightening fact tells explicitly went wrong happing testhistogram told testframework feed example-texts different sizes beginning 10.000 1.280.000 histogramdiff run measure much cputime used calculate diff calculate different performance indexes index perf1 perf1=cputime/ n*d perf2=cputime/ n*d*d interested actual values indexes algorithm expected runtime behaviour n*d index perf1 quite constant n*d algorithms perf2 constant quite constant means max perfx /min perfx must less given constant said testhistogram histogramdiff behave like n*d algorithm check perf1 max/min 15 maxfactor perf1 decreases longer texts means algorithms behaves test data better n*d algorithm hhmmm good result true sure depend n number differences really influencing performance much increasing accepted factor maxfactor 20 calculate different performance index e.g t/ n*log see whether like kind algorithm
